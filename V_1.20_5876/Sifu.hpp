#ifndef UE4SS_SDK_Sifu_HPP
#define UE4SS_SDK_Sifu_HPP

#include "Sifu_enums.hpp"

struct FAIActionAttackClassInstance
{
    TSubclassOf<class UAIActionAttack> m_DefaultClassObject;                          // 0x0000 (size: 0x8)
    class UAIActionAttack* m_Instance;                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAIActionReaction : public FAIConditionedAction
{
    float m_fTestFrequency;                                                           // 0x0038 (size: 0x4)
    bool m_bCanCancelPendingActions;                                                  // 0x003C (size: 0x1)
    bool m_bOnlyWhenAlerted;                                                          // 0x003D (size: 0x1)

}; // Size: 0x40

struct FAIActionTraversalMemory : public FSCAIActionMemoryEntry
{
}; // Size: 0x28

struct FAIActionWallJumpAttackMemory : public FSCAIActionMemoryEntry
{
}; // Size: 0xA0

struct FAIArchetypeBankRow : public FTableRowBase
{
    EAIArchetype m_eAIArchetype;                                                      // 0x0008 (size: 0x1)
    TArray<FAICharacterSpawnParams> m_SpawnParams;                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAIAttackHitDetectionCone
{
    FFloatRange m_fRange;                                                             // 0x0000 (size: 0x10)
    float m_fAngle;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FAIAttackHitDetectionVolume
{
    TArray<FAIAttackHitDetectionCone> m_RangedCones;                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAIAttackJokerSituationConfig
{
    bool m_bEnabled;                                                                  // 0x0000 (size: 0x1)
    float m_fJokerDuration;                                                           // 0x0004 (size: 0x4)
    float m_fCooldown;                                                                // 0x0008 (size: 0x4)
    bool m_bShouldBeDeactivatedByTargetAttack;                                        // 0x000C (size: 0x1)
    EAIJokerBehaviorAgainstAttacks m_eJokerBehaviorOnAIAttacks;                       // 0x000D (size: 0x1)
    FSCAITicketEnum m_FallbackTicket;                                                 // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FAIAttackJokerSituationConfigsPerDominationStep
{
    FAIAttackJokerSituationConfig m_Configs;                                          // 0x0000 (size: 0x180)

}; // Size: 0x180

struct FAIAttackReaction
{
    TArray<class UComboTransitionCondition*> m_Conditions;                            // 0x0000 (size: 0x10)
    TArray<FAIConditionClassInstance> m_ConditionsArray;                              // 0x0010 (size: 0x10)
    bool m_bCanInterruptMoveToAttack;                                                 // 0x0020 (size: 0x1)
    bool m_bCanInterruptAttackWhenAvailable;                                          // 0x0021 (size: 0x1)
    bool m_bCanEndComboAfterOnGoingAttack;                                            // 0x0022 (size: 0x1)
    bool m_bCanInterruptPassiveTicket;                                                // 0x0023 (size: 0x1)
    FSCAITicketEnum m_TicketNameEnumValue;                                            // 0x0028 (size: 0x50)

}; // Size: 0x78

struct FAICancelCondition
{
    float m_fTestFrequency;                                                           // 0x0000 (size: 0x4)
    FAIConditionClassInstance m_condition;                                            // 0x0008 (size: 0x10)
    bool m_bInvert;                                                                   // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FAICharacterSpawnParams
{
    FName m_ParamsName;                                                               // 0x0000 (size: 0x8)
    TSubclassOf<class ABaseCharacter> m_SpawningClass;                                // 0x0008 (size: 0x8)
    class UAIPhaseScenario* m_PhaseScenarios;                                         // 0x0010 (size: 0x18)
    TArray<FCarriedProps> m_carriedProps;                                             // 0x0028 (size: 0x10)
    TSubclassOf<class ABaseWeapon> m_carriedWeapon;                                   // 0x0038 (size: 0x8)
    FName m_CharacterPoolName;                                                        // 0x0040 (size: 0x8)
    FName m_CarriedWeaponPoolName;                                                    // 0x0048 (size: 0x8)
    FName m_CustomImpostorName;                                                       // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FAIComboLaunchParameters
{
    bool m_bCheckCanAttack;                                                           // 0x0000 (size: 0x1)
    bool m_bCheckTicketAvailable;                                                     // 0x0001 (size: 0x1)
    FSCAITicketEnum m_Ticket;                                                         // 0x0008 (size: 0x50)
    bool m_bMoveToTargetRange;                                                        // 0x0058 (size: 0x1)
    class AActor* m_Target;                                                           // 0x0060 (size: 0x8)
    int32 m_iRepeats;                                                                 // 0x0068 (size: 0x4)
    bool m_bCancelPendingActions;                                                     // 0x006C (size: 0x1)
    bool m_bTestInputActionAvailable;                                                 // 0x006D (size: 0x1)

}; // Size: 0x80

struct FAIConditionClassInstance
{
    TSubclassOf<class UComboTransitionCondition> m_DefaultClassObject;                // 0x0000 (size: 0x8)
    class UComboTransitionCondition* m_Instance;                                      // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAIConditionTraceOffset
{
    EAIConditionTraceOffsetContext m_eRelativeTo;                                     // 0x0000 (size: 0x1)
    FVector m_vOffset;                                                                // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FAIConditionedAction
{
    TArray<class UComboTransitionCondition*> m_Conditions;                            // 0x0000 (size: 0x10)
    TSubclassOf<class USCAiAction> m_ActionClass;                                     // 0x0010 (size: 0x8)
    TArray<FAIConditionClassInstance> m_ConditionsArray;                              // 0x0018 (size: 0x10)
    FSCAiActionClassInstance m_Action;                                                // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FAIConditionedActionArray
{
    TArray<FAIConditionedAction> m_Actions;                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAICustomBehaviorTree
{
    FGameplayTag m_DynamicBehaviorGameplayTag;                                        // 0x0000 (size: 0x8)
    class UBehaviorTree* m_BehaviorToUse;                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAICustomBehaviorTreeList
{
    TArray<FAICustomBehaviorTree> m_DynamicBehaviorList;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAIDebugSpawnerInstance
{
    class AAISpawner* m_Spawner;                                                      // 0x0000 (size: 0x8)
    class UArchetypeAsset* m_Archetype;                                               // 0x0008 (size: 0x8)

}; // Size: 0x28

struct FAIDefenseTargetAttackInfos
{
    EAIDefendedAttackType m_eType;                                                    // 0x0000 (size: 0x1)
    uint8 m_uiHitBoxIndex;                                                            // 0x0001 (size: 0x1)
    uint8 m_uiOrderID;                                                                // 0x0002 (size: 0x1)

}; // Size: 0xC

struct FAIDifficultyLevel
{
    FName m_DifficultyName;                                                           // 0x0000 (size: 0x8)
    FInt32Range m_DifficultyGaugeRange;                                               // 0x0008 (size: 0x10)
    float m_fDifficultyVariationMultFactor;                                           // 0x0018 (size: 0x4)
    class UCombo* m_Combo;                                                            // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FAIDominationGaugeSteps
{
    float m_Steps;                                                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAIInfo
{
}; // Size: 0x1

struct FAILocalizedConditionedAction : public FAIConditionedAction
{
    FSCMathExpressionFloat m_DistanceTestExpression;                                  // 0x0038 (size: 0x20)

}; // Size: 0x58

struct FAIPhaseNodeHardLink : public FAIPhaseNodeLink
{
    class UAIPhaseScenario* m_Scenario;                                               // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FAIPhaseNodeLink
{
    FGuid m_Guid;                                                                     // 0x0000 (size: 0x10)
    FName m_Name;                                                                     // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FAIPhaseNodeSoftLink : public FAIPhaseNodeLink
{
    TSoftObjectPtr<UAIPhaseScenario> m_PhaseScenario;                                 // 0x0018 (size: 0x28)

}; // Size: 0x40

struct FAIPhaseNodeSoftLinkByMCDomination
{
    FAIPhaseNodeSoftLink m_PhaseLink;                                                 // 0x0000 (size: 0x40)
    uint32 m_uiMCDominationFlags;                                                     // 0x0040 (size: 0x4)

}; // Size: 0x48

struct FAIPhaseTransitionData
{
    int32 m_iNewPhase;                                                                // 0x0000 (size: 0x4)
    int32 m_iPreviousPhase;                                                           // 0x0004 (size: 0x4)
    FName m_ArchetypeName;                                                            // 0x0008 (size: 0x8)
    class ALevelSequenceActor* m_SequenceActor;                                       // 0x0010 (size: 0x8)

}; // Size: 0x40

struct FAIPositionningPOI
{
    FFloatRange m_EnemyDistanceRange;                                                 // 0x0000 (size: 0x10)
    float m_fEnemyDistanceZTolerance;                                                 // 0x0010 (size: 0x4)
    bool m_bUseRotation;                                                              // 0x0014 (size: 0x1)
    bool m_bKeepLockMoveOnWayToPOI;                                                   // 0x0015 (size: 0x1)
    bool m_bCanUseAttackTickets;                                                      // 0x0016 (size: 0x1)
    bool m_bCanBecomeDirectOpponent;                                                  // 0x0017 (size: 0x1)
    bool m_bJiggle;                                                                   // 0x0018 (size: 0x1)
    int32 m_eCombatRolesMask;                                                         // 0x001C (size: 0x4)
    float m_fCooldownWhenOccupantLeaves;                                              // 0x0020 (size: 0x4)
    FSCGestureContainer m_GestureAnimations;                                          // 0x0028 (size: 0x10)
    ESCAICombatRoles m_eRoleOnTargetCloserToMinRange;                                 // 0x0038 (size: 0x1)

}; // Size: 0x60

struct FAIRangePerCircleIndex
{
    TMap<int32, FFloatRange> m_RangePerCircle;                                        // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FAIResistanceActions
{
    TArray<FAITimedConditionedAction> m_OnTick;                                       // 0x0000 (size: 0x10)
    TArray<FAIConditionedAction> m_OnEnd;                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAISituationNamedActor
{
    FName m_Name;                                                                     // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAISpawnedDescription
{
    uint8 m_uiSpawnerGroupIndex;                                                      // 0x0000 (size: 0x1)
    int32 m_iSpawnerIndexInLayer;                                                     // 0x0004 (size: 0x4)
    bool m_bKilled;                                                                   // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FAISuperDizzyParams
{
    bool m_bCanBeSuperDizzy;                                                          // 0x0000 (size: 0x1)
    float m_fSuperDizzyResistance;                                                    // 0x0004 (size: 0x4)
    float m_fSuperDizzyRecoveryCooldown;                                              // 0x0008 (size: 0x4)
    float m_fSuperDizzyRecoveryCooldownWhenComplete;                                  // 0x000C (size: 0x4)
    float m_fSuperDizzyGaugeRatioAfterSuperDizzy;                                     // 0x0010 (size: 0x4)
    float m_fSuperDizzyRecoveryPerSec;                                                // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FAITicketCooldowns
{
    FTimerAndOffset m_Cooldowns;                                                      // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FAITimedConditionedAction
{
    FFloatRange m_TimeRange;                                                          // 0x0000 (size: 0x10)
    FAIConditionedAction m_Action;                                                    // 0x0010 (size: 0x38)

}; // Size: 0x48

struct FAIWaveBucketDescription
{
    int32 m_iNumberInBucket;                                                          // 0x0000 (size: 0x4)
    int32 m_iMaxInCombat;                                                             // 0x0004 (size: 0x4)
    TArray<FAIWeaponBucketDescription> m_WeaponBuckets;                               // 0x0008 (size: 0x10)
    FInt32Range m_iWeaponSpawnFrequency;                                              // 0x0018 (size: 0x10)

}; // Size: 0x40

struct FAIWaveParams
{
    FName m_WaveName;                                                                 // 0x0000 (size: 0x8)
    TMap<class EAIArchetype, class FAIWaveBucketDescription> m_ArchetypesBuckets;     // 0x0008 (size: 0x50)
    FInt32Range m_iMinMaxInCombat;                                                    // 0x0058 (size: 0x10)
    EStartWaveType m_eStartWaveType;                                                  // 0x0068 (size: 0x1)
    FGameplayTag m_WaveTag;                                                           // 0x006C (size: 0x8)
    FGameplayTagContainer m_WaveTags;                                                 // 0x0078 (size: 0x20)
    FFloatRange m_fDelayBeforeWave;                                                   // 0x0098 (size: 0x10)
    TSoftObjectPtr<AAISituationActor> m_RelatedAISituation;                           // 0x00A8 (size: 0x28)

}; // Size: 0xD0

struct FAIWaveParamsRow : public FTableRowBase
{
    TMap<class EAIArchetype, class FAIWaveBucketDescription> m_ArchetypesBuckets;     // 0x0008 (size: 0x50)
    int32 m_iMaxAIInCombatDuringWave;                                                 // 0x0058 (size: 0x4)

}; // Size: 0x60

struct FAIWeaponBucketDescription
{
    TSubclassOf<class ABaseWeapon> m_WeaponClass;                                     // 0x0000 (size: 0x8)
    int32 m_iWeaponNumber;                                                            // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FAIWeaponInfo
{
    class UWeaponInfoForAIDataAsset* m_WeaponInfoForAI;                               // 0x0000 (size: 0x8)
    bool m_bCanFetch;                                                                 // 0x0008 (size: 0x1)
    bool m_bUseThiWeaponAtStart;                                                      // 0x0009 (size: 0x1)
    bool m_bWeaponShouldBreakWhenDropped;                                             // 0x000A (size: 0x1)
    bool m_bWeaponShouldRegenerateAfterThrown;                                        // 0x000B (size: 0x1)
    bool m_bWeaponCanTakeDamage;                                                      // 0x000C (size: 0x1)
    FWeaponOverrideInfo m_WeaponOverride;                                             // 0x0010 (size: 0x118)

}; // Size: 0x128

struct FAbandoningAnimations
{
    FAnimContainer m_GoingDown;                                                       // 0x0000 (size: 0x18)
    FAnimContainer m_Loop;                                                            // 0x0018 (size: 0x18)

}; // Size: 0x30

struct FAbilityDelegateHandler
{
    TArray<FAbilityDelegateHandler_OnActivated> m_OnActivated;                        // 0x0000 (size: 0x10)
    TArray<FAbilityDelegateHandler_OnDeactivated> m_OnDeactivated;                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAbsorbWindow
{
    FFrameRange m_FrameRange;                                                         // 0x0000 (size: 0x10)
    int32 m_iAbsorbID;                                                                // 0x0010 (size: 0x4)
    class UAbsorbPropertyDB* m_AbsorbPropertyDB;                                      // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FActionConditions
{
    bool bAllowedOnEmptyGauge;                                                        // 0x0000 (size: 0x1)
    bool bAllowedOnBrokenGuard;                                                       // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FActionMappingCompatibilityRule
{
    EInputMappingCompatibilityRuleType m_eRule;                                       // 0x0000 (size: 0x4)
    TSet<InputAction> m_Actions;                                                      // 0x0008 (size: 0x50)

}; // Size: 0x58

struct FAddVariableWeightInfo
{
    FName m_Name;                                                                     // 0x0000 (size: 0x8)
    bool m_bMirror;                                                                   // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FAimOffsetStruct
{
    class UAimOffsetBlendSpace* m_aimOffset;                                          // 0x0000 (size: 0x8)
    bool m_bMirror;                                                                   // 0x0008 (size: 0x1)
    float m_fMaxHeadDiffYaw;                                                          // 0x000C (size: 0x4)
    float m_fMaxHeadDiffPitch;                                                        // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FAlternativeAttackComboDB
{
    FName m_Attacks;                                                                  // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FAlternativeAttackComboRealNamesDB
{
    FText m_Attacks;                                                                  // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FAlwaysCollidingActions
{
    TArray<InputAction> m_Actions;                                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnalogInputSequenceStep
{
    FFloatRange m_SizeTolerance;                                                      // 0x0000 (size: 0x10)
    FFloatRange m_VelocityFromRefDirTolerance;                                        // 0x0010 (size: 0x10)
    bool m_bAbsAngle;                                                                 // 0x0020 (size: 0x1)
    FFloatRange m_AngleDegTolerance;                                                  // 0x0024 (size: 0x10)
    FFloatRange m_fHoldDuration;                                                      // 0x0034 (size: 0x10)
    float m_fMaxValidityDuration;                                                     // 0x0044 (size: 0x4)
    bool m_bIsReferenceDirection;                                                     // 0x0048 (size: 0x1)
    EAnalogInputReferenceDirection m_eReferenceDirBehavior;                           // 0x0049 (size: 0x1)
    bool m_bIsResultDirection;                                                        // 0x004A (size: 0x1)
    bool m_bParallelizeOnValidation;                                                  // 0x004B (size: 0x1)

}; // Size: 0x4C

struct FAngleRange
{
    float m_fMinAngle;                                                                // 0x0000 (size: 0x4)
    float m_fAngleSize;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FAnimByCardinalThenHeight
{
    FAnimByHeight m_Array;                                                            // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FAnimByHeight
{
    class UAnimSequence* m_Array;                                                     // 0x0000 (size: 0x18)

}; // Size: 0x18

struct FAnimInfo
{
    bool m_bActionInProgress;                                                         // 0x0000 (size: 0x1)
    EWeaponAnimType m_eWeaponAnimType;                                                // 0x0001 (size: 0x1)
    class UAnimSequence* m_AnimToPlay;                                                // 0x0008 (size: 0x8)
    class UBlendSpaceBase* m_BlendSpaceToPlay;                                        // 0x0010 (size: 0x8)
    FVector m_vBlendSpaceValue;                                                       // 0x0018 (size: 0xC)
    float m_fPlayRate;                                                                // 0x0024 (size: 0x4)
    bool m_bMirror;                                                                   // 0x0028 (size: 0x1)
    bool m_bWeaponInFakieAtStart;                                                     // 0x0029 (size: 0x1)
    float m_fStartRatio;                                                              // 0x002C (size: 0x4)
    bool m_bLoop;                                                                     // 0x0030 (size: 0x1)
    float m_fBlendSpaceAngle;                                                         // 0x0034 (size: 0x4)
    float m_fOwnerVelocityLength;                                                     // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FAnimQuadrantStruct
{
    bool m_bIsInFrontLeft;                                                            // 0x0000 (size: 0x1)
    bool m_bIsInFrontRight;                                                           // 0x0001 (size: 0x1)
    bool m_bIsInBackRight;                                                            // 0x0002 (size: 0x1)
    bool m_bIsInBackLeft;                                                             // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FAnimSequenceDBCache
{
    TMap<class TSubclassOf<ABaseWeapon>, class UAnimSequenceEntryDB*> m_Sequences;    // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FAnimSequenceDBEntry
{
    class UAnimSequence* m_AnimSequence;                                              // 0x0000 (size: 0x8)
    FText m_DisplayText;                                                              // 0x0008 (size: 0x18)
    TArray<float> m_Positions;                                                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FAnimStruct4
{
    bool m_bInProgress1;                                                              // 0x0008 (size: 0x1)
    bool m_bInProgress2;                                                              // 0x0009 (size: 0x1)
    bool m_bInProgress3;                                                              // 0x000A (size: 0x1)
    bool m_bInProgress4;                                                              // 0x000B (size: 0x1)
    bool m_bInProgress1Or2Or3Or4;                                                     // 0x000C (size: 0x1)
    FVariableWeightInfo m_variableWeightLayers1;                                      // 0x0010 (size: 0x20)
    FVariableWeightInfo m_variableWeightLayers2;                                      // 0x0030 (size: 0x20)
    FVariableWeightInfo m_variableWeightLayers3;                                      // 0x0050 (size: 0x20)
    FVariableWeightInfo m_variableWeightLayers4;                                      // 0x0070 (size: 0x20)

}; // Size: 0x90

struct FAnimStructAttack : public FAnimStructBase
{
    bool m_bStartBlendOut1;                                                           // 0x0088 (size: 0x1)
    bool m_bStartBlendOut2;                                                           // 0x0089 (size: 0x1)

}; // Size: 0x90

struct FAnimStructBase : public FSwapperStructBase
{
    FAnimContainer m_AnimContainer1;                                                  // 0x0058 (size: 0x18)
    FAnimContainer m_AnimContainer2;                                                  // 0x0070 (size: 0x18)

}; // Size: 0x90

struct FAnimStructDeath : public FAnimStructBase
{
    bool m_bCancelled;                                                                // 0x0088 (size: 0x1)

}; // Size: 0x90

struct FAnimStructEmote : public FAnimStructBase
{
}; // Size: 0x90

struct FAnimStructHandPose : public FAnimStructBase
{
    EHandPoseBlendInTypes m_eHandPoseBlendInType1;                                    // 0x0088 (size: 0x1)
    EHandPoseBlendInTypes m_eHandPoseBlendInType2;                                    // 0x0089 (size: 0x1)
    EHandPoseBlendOutTypes m_eHandPoseBlendOutType1;                                  // 0x008A (size: 0x1)
    EHandPoseBlendOutTypes m_eHandPoseBlendOutType2;                                  // 0x008B (size: 0x1)

}; // Size: 0x90

struct FAnimStructItemUse : public FAnimStructBase
{
}; // Size: 0x90

struct FAnimStructMoveTransition : public FAnimStructBase
{
    EMoveTransitionType m_eTransitionType1;                                           // 0x0088 (size: 0x1)
    EMoveTransitionType m_eTransitionType2;                                           // 0x0089 (size: 0x1)

}; // Size: 0x90

struct FAnimStructOverride : public FAnimStructBase
{
    int32 m_iAnimIndex;                                                               // 0x0088 (size: 0x4)

}; // Size: 0x90

struct FAnimStructSpawn : public FAnimStructBase
{
    float m_fPlayRate;                                                                // 0x0088 (size: 0x4)

}; // Size: 0x90

struct FAnimStructTraversal
{
    bool m_bTraversalInProgress;                                                      // 0x0000 (size: 0x1)
    ETraversalPhase m_eTraversalPhase;                                                // 0x0001 (size: 0x1)
    FAnimContainer m_animationContainersPerPhase;                                     // 0x0008 (size: 0x78)

}; // Size: 0x80

struct FAnimStructVariableWeight : public FAnimStructBase
{
}; // Size: 0x90

struct FAnimStructWeaponAction : public FAnimStructBase
{
}; // Size: 0x90

struct FAnimSyncContainer
{
    FAnimContainer m_InstigatorAnim;                                                  // 0x0000 (size: 0x18)
    FAnimContainer m_VictimAnim;                                                      // 0x0018 (size: 0x18)

}; // Size: 0x30

struct FAppliedDeflectImpact : public FAppliedHitImpact
{
    class UCurveFloat* m_KnockBackDynamic;                                            // 0x0018 (size: 0x8)
    float m_fSelfStructureDamage;                                                     // 0x0020 (size: 0x4)
    float m_fSelfSuperDizzyDamage;                                                    // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FAppliedHitImpact
{
    float m_fDamage;                                                                  // 0x0000 (size: 0x4)
    float m_fStructureDamage;                                                         // 0x0004 (size: 0x4)
    float m_fSuperDizzyDamage;                                                        // 0x0008 (size: 0x4)
    uint8 m_iNbFrameStuned;                                                           // 0x000C (size: 0x1)
    bool m_bUseKnockBackDistance;                                                     // 0x000D (size: 0x1)
    float m_fKnockBackDistance;                                                       // 0x0010 (size: 0x4)
    int32 m_iFreezeFrames;                                                            // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FApplyImpactStruct
{
    FHitDescription m_hitDescription;                                                 // 0x0000 (size: 0x568)
    bool m_bUseForcedHittedAnim;                                                      // 0x0568 (size: 0x1)
    FHittedAnimContainer m_ForcedAnim;                                                // 0x0570 (size: 0x68)
    bool m_bPlayOrderHitted;                                                          // 0x05D8 (size: 0x1)
    bool m_bEnterRagdoll;                                                             // 0x05D9 (size: 0x1)
    bool m_bDropWeaponOnDeath;                                                        // 0x05DA (size: 0x1)
    bool m_bPlayOrderFightingState;                                                   // 0x05DB (size: 0x1)
    uint8 m_uiPlayFightingStateOrderAfter;                                            // 0x05DC (size: 0x1)
    class UAttackPropertiesResistanceDB* m_specialResistanceDB;                       // 0x05E0 (size: 0x8)
    uint8 m_uiSpecificOrderIDToPlayBeforeFightingStateOrder;                          // 0x05E8 (size: 0x1)
    bool m_bUseForcedFightingStateAnim;                                               // 0x05E9 (size: 0x1)
    FAnimContainer m_ForcedFightingStateAnim;                                         // 0x05F0 (size: 0x18)
    bool m_bInstantPlayStructureBrokenOrder;                                          // 0x0608 (size: 0x1)
    bool m_bUseForcedFightingStateRecoveryAnim;                                       // 0x0609 (size: 0x1)
    FAnimContainer m_ForcedFightingStateAnimRecovery;                                 // 0x0610 (size: 0x18)
    bool m_bUseForceMirrorFightingState;                                              // 0x0628 (size: 0x1)
    bool m_bForceMirrorFightingState;                                                 // 0x0629 (size: 0x1)
    bool m_bNotifyInstigator;                                                         // 0x062A (size: 0x1)

}; // Size: 0x630

struct FArchetypeSituationDescription
{
    class UArchetypeAsset* m_Archetype;                                               // 0x0000 (size: 0x8)
    int32 m_iLevelMin;                                                                // 0x0008 (size: 0x4)
    int32 m_iLevelMax;                                                                // 0x000C (size: 0x4)
    uint8 m_uiWeightLevel;                                                            // 0x0010 (size: 0x1)
    uint32 m_uiAppearanceProbabilities;                                               // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FArenaBatch
{
    TArray<class TSubclassOf<UArenaChallengeDescription>> m_ChallengesList;           // 0x0000 (size: 0x10)
    FText m_Name;                                                                     // 0x0010 (size: 0x18)
    FGameplayTag m_IdentifierTag;                                                     // 0x0028 (size: 0x8)
    FGameplayTag m_ContentRestrictionTag;                                             // 0x0030 (size: 0x8)
    int32 m_iStarsCountToUnlock;                                                      // 0x0038 (size: 0x4)
    FGameplayTag m_WorldMapPathTag;                                                   // 0x003C (size: 0x8)

}; // Size: 0x48

struct FArenaBatchProgressionInfo
{
    int32 m_iCurrentStarsCount;                                                       // 0x0000 (size: 0x4)
    int32 m_iTotalStarsCount;                                                         // 0x0004 (size: 0x4)
    bool m_bIsUnlocked;                                                               // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FArenaChallengeRefillDescription
{
    TSoftObjectPtr<AAIWaveRefillDirector> m_RefillDirector;                           // 0x0000 (size: 0x28)
    TArray<FAIWaveParams> m_Waves;                                                    // 0x0028 (size: 0x10)
    TSoftObjectPtr<UDataTable> m_ArchetypeBank;                                       // 0x0038 (size: 0x28)
    bool m_bUseDistanceForSpawnerEvaluation;                                          // 0x0060 (size: 0x1)
    FFloatRange m_fDistanceRangeForSpawnerScore;                                      // 0x0064 (size: 0x10)

}; // Size: 0x78

struct FArenaChallengeSave
{
    int32 m_iHighScore;                                                               // 0x0000 (size: 0x4)
    int32 m_iBestStarCount;                                                           // 0x0004 (size: 0x4)
    bool m_bHasBeenSeen;                                                              // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FArenaParams
{
    TArray<class TSubclassOf<UArenaChallengeDescription>> m_ChallengesList;           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FArenaProgressionInfo
{
    int32 m_iCurrentStarsCount;                                                       // 0x0000 (size: 0x4)
    int32 m_iTotalStarsCount;                                                         // 0x0004 (size: 0x4)
    TArray<FArenaBatchProgressionInfo> m_ArenaBatchesInfo;                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAsyncTextureStruct
{
    TSoftObjectPtr<UTexture2D> m_AsyncAsset;                                          // 0x0000 (size: 0x28)

}; // Size: 0x28

struct FAttackComboDB
{
    FMainAttackComboDB m_MainAttacksComboDB;                                          // 0x0000 (size: 0x80)
    FAlternativeAttackComboDB m_AlternativeAttacksComboDB;                            // 0x0080 (size: 0xA0)

}; // Size: 0x120

struct FAttackComboRealNamesDB
{
    FMainAttackComboRealNamesDB m_MainAttacksComboNamesDB;                            // 0x0000 (size: 0x80)
    FAlternativeAttackComboRealNamesDB m_AlternativeAttacksComboNamesDB;              // 0x0080 (size: 0x1E0)

}; // Size: 0x260

struct FAttackDataRow : public FBaseAttackDataRow
{
    TSoftObjectPtr<UAnimationAsset> m_Anim;                                           // 0x0028 (size: 0x28)
    bool m_bCanBeMirrored;                                                            // 0x0050 (size: 0x1)
    EAttackMirroringMethod m_eMirroringMethod;                                        // 0x0054 (size: 0x4)
    float m_fMirrorUseNextFootMarkerThreshold;                                        // 0x0058 (size: 0x4)
    EQuadrantTypes m_eStartQuadrant;                                                  // 0x005C (size: 0x1)
    EQuadrantTypes m_eEndQuadrant;                                                    // 0x005D (size: 0x1)
    float m_fMeasuredForwardMovement;                                                 // 0x0060 (size: 0x4)
    float m_fMovementRightLength;                                                     // 0x0064 (size: 0x4)
    bool m_bDirectRightMovementFollow;                                                // 0x0068 (size: 0x1)
    int32 m_iLastBuildupFrame;                                                        // 0x006C (size: 0x4)
    float m_fHitFrame;                                                                // 0x0070 (size: 0x4)
    bool m_bStrikelessAttack;                                                         // 0x0074 (size: 0x1)

}; // Size: 0x78

struct FAttackFilter
{
    EQuadrantTypes m_eStartQuadrant;                                                  // 0x0000 (size: 0x1)
    EQuadrantTypes m_eEndQuadrant;                                                    // 0x0001 (size: 0x1)
    bool m_bIsAlternativeAttack;                                                      // 0x0002 (size: 0x1)
    bool m_bExcludeUsedAttacks;                                                       // 0x0003 (size: 0x1)
    FName m_AllowedAttack;                                                            // 0x0004 (size: 0x8)
    bool m_bIgnoreUknownAttacks;                                                      // 0x000C (size: 0x1)
    bool m_bIgnoreLearningAttacks;                                                    // 0x000D (size: 0x1)
    bool m_bIgnoreUnlockedAttacks;                                                    // 0x000E (size: 0x1)
    bool m_bExcludeOtherWeaponFamilies;                                               // 0x000F (size: 0x1)
    bool m_bNewAttacksOnly;                                                           // 0x0010 (size: 0x1)
    int32 m_iAttackStyle;                                                             // 0x0014 (size: 0x4)
    int32 m_iSpecialAbilityMask;                                                      // 0x0018 (size: 0x4)
    bool m_bIgnoreMirrored;                                                           // 0x001C (size: 0x1)
    EAttackLearningState m_eLearningState;                                            // 0x001D (size: 0x1)

}; // Size: 0x20

struct FAttackHitRequest : public FHitRequest
{
}; // Size: 0x418

struct FAttackIKLimbProfiles
{
    FAttackIKProfileInfos m_Profiles;                                                 // 0x0000 (size: 0xB0)

}; // Size: 0xB0

struct FAttackIKProfileInfos
{
    FSCUserDefinedEnumHandler m_Profile;                                              // 0x0000 (size: 0x50)
    FName m_AnimCurveName;                                                            // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FAttackMemoryData
{
    TWeakObjectPtr<class AActor> m_Instigator;                                        // 0x0000 (size: 0x8)
    uint8 m_uiOderId;                                                                 // 0x0008 (size: 0x1)
    EGuardType m_eGuardType;                                                          // 0x0009 (size: 0x1)
    TSoftClassPtr<AThrowableActor> m_ThrowableActorClass;                             // 0x0010 (size: 0x28)
    FGameplayTagContainer m_AttackProperties;                                         // 0x0038 (size: 0x20)
    int32 m_iComboID;                                                                 // 0x0058 (size: 0x4)
    bool m_bHasHit;                                                                   // 0x0068 (size: 0x1)
    bool m_bDodged;                                                                   // 0x0069 (size: 0x1)
    bool m_bAvoided;                                                                  // 0x006A (size: 0x1)

}; // Size: 0x70

struct FAttackPropertyLevel
{
    uint32 m_Level;                                                                   // 0x0000 (size: 0xC)
    bool m_bUseCustomDuration;                                                        // 0x000C (size: 0x1)
    float m_fCustomDuration;                                                          // 0x0010 (size: 0x4)
    bool m_bUseHitAnimDuration;                                                       // 0x0014 (size: 0x1)
    bool m_bKeepCurrentStateDuration;                                                 // 0x0015 (size: 0x1)
    float m_fKeepCurrentStateThresold;                                                // 0x0018 (size: 0x4)
    bool m_bUseCustomDistance;                                                        // 0x001C (size: 0x1)
    float m_fCustomDistance;                                                          // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FAttackPropertyResistanceMatrixByFightingState
{
    FAttackPropertyLevel m_Matrix;                                                    // 0x0000 (size: 0x144)

}; // Size: 0x144

struct FAttackRequest
{
    InputAction m_eInputAction;                                                       // 0x0000 (size: 0x1)
    EQuadrantTypes m_eCurrentQuadrant;                                                // 0x0001 (size: 0x1)
    FName m_AttackName;                                                               // 0x0004 (size: 0x8)
    FName m_ComboState;                                                               // 0x000C (size: 0x8)
    class UCombo* m_Combo;                                                            // 0x0028 (size: 0x8)
    int32 m_iComboNodeID;                                                             // 0x0030 (size: 0x4)
    float m_fStartRatio;                                                              // 0x0038 (size: 0x4)
    class UAttackDB* m_AttackDB;                                                      // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FAttackTicketConfig
{
    FAttackTicketBehavior m_eBehavior;                                                // 0x0000 (size: 0x1)
    bool m_bTicketIsAlwaysAvailable;                                                  // 0x0001 (size: 0x1)
    ESCAICombatRoles m_eCombatRole;                                                   // 0x0002 (size: 0x1)
    int32 m_eCombatRolesMask;                                                         // 0x0004 (size: 0x4)
    int32 m_iCount;                                                                   // 0x0008 (size: 0x4)
    FTimerAndOffset m_Cooldowns;                                                      // 0x000C (size: 0x20)
    bool m_bUsePerDifficultyCounters;                                                 // 0x002C (size: 0x1)
    int32 m_iCountPerDifficulty;                                                      // 0x0030 (size: 0xC)
    FAITicketCooldowns m_CooldownsPerDifficulty;                                      // 0x003C (size: 0x60)
    float m_fCooldownOffsetOnSynchedFires;                                            // 0x009C (size: 0x4)
    float m_fCooldownSynchFiresTolerance;                                             // 0x00A0 (size: 0x4)
    float m_fForcedCooldownOnDirectOpponentDeath;                                     // 0x00A4 (size: 0x4)
    bool m_bIsRepeated;                                                               // 0x00A8 (size: 0x1)
    FInt32Range m_Repeats;                                                            // 0x00AC (size: 0x10)
    bool m_bUseMinDistanceToPosition;                                                 // 0x00BC (size: 0x1)
    float m_fMinDistanceToPosition;                                                   // 0x00C0 (size: 0x4)
    bool m_bEnableIneligibleTimerOnRelease;                                           // 0x00C4 (size: 0x1)
    bool m_bIsNotUsedInCombo;                                                         // 0x00C5 (size: 0x1)
    float m_fMoveToTimeoutValue;                                                      // 0x00C8 (size: 0x4)
    EPassiveTicketBehaviorAginstJoker m_eBehaviorAgainstJoker;                        // 0x00CC (size: 0x1)
    FSCAITicketEnum m_FallbackTicket;                                                 // 0x00D0 (size: 0x50)

}; // Size: 0x120

struct FAttackUnlockProgress
{
    int32 m_iXP;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FAudioOutput
{
    FText m_DisplayText;                                                              // 0x0000 (size: 0x18)
    AkChannelConfiguration m_eChannelConfig;                                          // 0x0018 (size: 0x1)
    bool m_bUse3DOutput;                                                              // 0x0019 (size: 0x1)

}; // Size: 0x20

struct FAutoAvoidInfos
{
    class AFightingCharacter* m_AttackerChar;                                         // 0x0000 (size: 0x8)
    FHitBox m_AttackerHitBox;                                                         // 0x0008 (size: 0x298)
    ESCCardinalPoints m_eAttackerCardinalPoint;                                       // 0x02A0 (size: 0x1)

}; // Size: 0x2A8

struct FAvailabilityLayerCache
{
    class UGenericAvailabilityLayerDB* m_DB;                                          // 0x0000 (size: 0x8)
    int32 m_iPriority;                                                                // 0x0008 (size: 0x4)

}; // Size: 0x28

struct FAvailabilityLayerCaches
{
    int32 m_iPriority;                                                                // 0x0000 (size: 0x4)
    TArray<FAvailabilityLayerCache> m_layers;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAvailabilityLayerCombinations
{
    class UAvailabilityLayerData* m_LayerData;                                        // 0x0000 (size: 0x8)
    EALBinaryOperation m_eOperator;                                                   // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FAvailabilityLayerContainer
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0000 (size: 0x8)
    EALBinaryOperation m_eOperation;                                                  // 0x0008 (size: 0x1)
    int32 m_iPriority;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FAvailabilityLayerPushParams
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0000 (size: 0x8)
    EALBinaryOperation m_eOperation;                                                  // 0x0008 (size: 0x1)
    int32 m_iPriority;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FAvailabilityLayerWindow
{
    int32 m_uiHitConditions;                                                          // 0x0000 (size: 0x4)
    FFrameRange m_FrameRange;                                                         // 0x0004 (size: 0x10)
    class UAvailabilityLayerData* m_Layer;                                            // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FAvoidPropertyContainer
{
    class UAvoidPropertyDB* m_AvoidPropertyDB;                                        // 0x0000 (size: 0x38)

}; // Size: 0x38

struct FAvoidWindow
{
    FFrameRange m_FrameRange;                                                         // 0x0000 (size: 0x10)
    int32 m_iAvoidID;                                                                 // 0x0010 (size: 0x4)
    EAvoidType m_eAvoidType;                                                          // 0x0014 (size: 0x1)
    class UAvoidPropertyDB* m_AvoidPropertyDB;                                        // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FBPOrderServiceInstance
{
    TWeakObjectPtr<class ABaseCharacter> m_Owner;                                     // 0x0000 (size: 0x8)

}; // Size: 0x28

struct FBTTaskNodeRelevancyCondition
{
    FBaseActorConditionInstance m_RelevancyCondition;                                 // 0x0000 (size: 0x10)
    TEnumAsByte<EBTNodeResult::Type> m_eResultWhenIrrelevant;                         // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FBaseActorConditionInstance
{
    TSubclassOf<class UBaseActorCondition> m_DefaultClassObject;                      // 0x0000 (size: 0x8)
    class UBaseActorCondition* m_Instance;                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBaseActorTargetConditionInstance
{
    TSubclassOf<class UBaseActorTargetCondition> m_DefaultClassObject;                // 0x0000 (size: 0x8)
    class UBaseActorTargetCondition* m_Instance;                                      // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBaseAttackDataRow : public FTableRowBase
{
    FName m_Name;                                                                     // 0x0008 (size: 0x8)
    FText m_RealAttackName;                                                           // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FBaseFightingStateBehavior
{
    bool m_bIsPersistent;                                                             // 0x0000 (size: 0x1)
    int32 m_iPersistencePriority;                                                     // 0x0004 (size: 0x4)
    class UAvailabilityLayerData* m_SuperAvailabilityLayer;                           // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBaseHitBoxConditionInstance
{
    TSubclassOf<class UHitBoxCondition> m_DefaultClassObject;                         // 0x0000 (size: 0x8)
    class UHitBoxCondition* m_Instance;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBaseStatBindings
{
    FText m_Text;                                                                     // 0x0008 (size: 0x18)
    FSlateColor m_ComparisonColor;                                                    // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FBaseWeaponOverrideInfo
{
    float m_fLifeDamageModiferOnGuard;                                                // 0x0000 (size: 0x4)
    float m_fStructureDamageModifierOnGuard;                                          // 0x0004 (size: 0x4)
    TArray<class TSubclassOf<UGameplayEffect>> m_GrantedEffects;                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBlendProfileBySpeedStateStruct
{
    class UBlendProfile* m_BlendProfileBySpeedState;                                  // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FBlendProfileBySpeedStateTableRow : public FTableRowBase
{
    class UBlendProfile* m_BlendProfileBySpeedState;                                  // 0x0008 (size: 0x20)

}; // Size: 0x28

struct FBlendSpaceContainer
{
    class UBlendSpaceBase* m_BlendSpace;                                              // 0x0000 (size: 0x8)
    bool m_bMirror;                                                                   // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FBlendSpaceDirectionContainer
{
    FBlendSpaceContainer m_BlendSpaceFront;                                           // 0x0000 (size: 0x10)
    FBlendSpaceContainer m_BlendSpaceBack;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBlendSpaceHitRequestAdditionalInfo : public FHitRequestAdditionalInfo
{
}; // Size: 0x20

struct FBlendSpaceStructBase : public FSwapperStructBase
{
    class UBlendSpaceBase* m_BlendSpace1;                                             // 0x0058 (size: 0x8)
    float m_fPlayRate1;                                                               // 0x0060 (size: 0x4)
    FVector m_Coordinates1;                                                           // 0x0064 (size: 0xC)
    class UBlendSpaceBase* m_BlendSpace2;                                             // 0x0070 (size: 0x8)
    float m_fPlayRate2;                                                               // 0x0078 (size: 0x4)
    FVector m_Coordinates2;                                                           // 0x007C (size: 0xC)

}; // Size: 0x90

struct FBoneHitDBInfo
{
    FBoneReference m_boneRef;                                                         // 0x0000 (size: 0x10)
    EHitShapeType m_eShapeType;                                                       // 0x0010 (size: 0x1)
    float m_fHalfHeight;                                                              // 0x0024 (size: 0x4)
    int32 m_iNumLines;                                                                // 0x0028 (size: 0x4)
    bool m_bOneSided;                                                                 // 0x002C (size: 0x1)
    FVector m_Extent;                                                                 // 0x0030 (size: 0xC)
    float m_fRadius;                                                                  // 0x003C (size: 0x4)
    float m_fCapsuleHalfHeight;                                                       // 0x0040 (size: 0x4)
    FRotator m_RotationOffset;                                                        // 0x0044 (size: 0xC)
    FVector m_vPositionOffset;                                                        // 0x0050 (size: 0xC)
    float m_fChainHitBoxSpacing;                                                      // 0x005C (size: 0x4)
    float m_fChainValidDistance;                                                      // 0x0060 (size: 0x4)
    TArray<FBoneReference> m_bonesInChain;                                            // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FBoneIK
{
    FBoneReference m_Bone;                                                            // 0x0010 (size: 0x10)
    float m_fWeight;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x90

struct FBuffer
{
    TArray<uint8> m_BufferArray;                                                      // 0x0000 (size: 0x10)
    TArray<FName> m_BufferFnames;                                                     // 0x0010 (size: 0x10)
    TArray<class AActor*> m_BufferActors;                                             // 0x0020 (size: 0x10)
    TArray<class UObject*> m_BufferUObjects;                                          // 0x0030 (size: 0x10)

}; // Size: 0x48

struct FButtonAction
{
    FText m_Text;                                                                     // 0x0000 (size: 0x18)
    InputAction m_eAction;                                                            // 0x0018 (size: 0x1)
    EUIInputModes m_eInputMode;                                                       // 0x0019 (size: 0x1)
    EControllerIconAxisTypes m_eAxisType;                                             // 0x001A (size: 0x1)
    TArray<class UGenericInputData*> m_InputDatas;                                    // 0x0020 (size: 0x10)
    EActionMouseButtons m_Mouse;                                                      // 0x0030 (size: 0x1)
    class UTexture2D* m_MouseModeTexture;                                             // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FCameraCollisionSideRaycast
{
    FVector m_vStartLocal;                                                            // 0x0000 (size: 0xC)
    FVector m_vEndLocal;                                                              // 0x000C (size: 0xC)

}; // Size: 0x18

struct FCameraCollisionSideRaycastList
{
    TArray<FCameraCollisionSideRaycast> m_ListOfRayCast;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCameraDataModifierWithBehavior
{
    TSubclassOf<class UCameraDataModifier> m_Modifier;                                // 0x0000 (size: 0x8)
    ECameraDataModifierTickBehavior m_eBehavior;                                      // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FCameraLookAtServiceBehavior
{
    ELookAtType m_eLookATType;                                                        // 0x0000 (size: 0x1)
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0004 (size: 0x8)
    FVector m_vTargetPosition;                                                        // 0x000C (size: 0xC)
    FCameraLookAtServiceBehaviorTime m_timeParams;                                    // 0x0018 (size: 0x20)
    FCameraLookAtServiceBehaviorConfig m_configParams;                                // 0x0038 (size: 0xA8)

}; // Size: 0xE0

struct FCameraLookAtServiceBehaviorConfig
{
    bool m_bLookAtUsePitch;                                                           // 0x0000 (size: 0x1)
    bool m_bLookAtUseYaw;                                                             // 0x0001 (size: 0x1)
    bool m_bUseForcePitch;                                                            // 0x0002 (size: 0x1)
    float m_fForcePitch;                                                              // 0x0004 (size: 0x4)
    bool m_bUseForceYaw;                                                              // 0x0008 (size: 0x1)
    float m_fForceYaw;                                                                // 0x000C (size: 0x4)
    bool m_bStayLock;                                                                 // 0x0010 (size: 0x1)
    bool m_bDeactivateOnManual;                                                       // 0x0011 (size: 0x1)
    float m_fMinYawDiffAbsoluteToCancelLookAtLaunch;                                  // 0x0014 (size: 0x4)
    bool m_bUseYawDampingBasedOnDistance;                                             // 0x0018 (size: 0x1)
    bool m_bUseRepulsionAngleToComputeYaw;                                            // 0x0019 (size: 0x1)
    bool m_bRelaunchLookAtIfYawDampingNonZeroAgain;                                   // 0x001A (size: 0x1)
    class UCurveFloat* m_YawOrientationDampingFromDistanceCurve;                      // 0x0020 (size: 0x8)
    class UCurveFloat* m_YawNearOrientationDampingFromDistanceCurve;                  // 0x0028 (size: 0x8)
    class UCurveFloat* m_YawOrientationDampingCurveRatioFromDist;                     // 0x0030 (size: 0x8)
    bool m_bUsePitchDampingBasedOnDistance;                                           // 0x0038 (size: 0x1)
    class UCurveFloat* m_PitchOrientationDampingFromDistanceCurve;                    // 0x0040 (size: 0x8)
    class UCurveFloat* m_PitchNearOrientationDampingFromDistanceCurve;                // 0x0048 (size: 0x8)
    class UCurveFloat* m_PitchOrientationDampingCurveRatioFromDist;                   // 0x0050 (size: 0x8)
    bool m_bUsePitchComputedWithSlope;                                                // 0x0058 (size: 0x1)
    class UCurveFloat* m_PitchValuePerSlopeAngleMinDist;                              // 0x0060 (size: 0x8)
    class UCurveFloat* m_PitchValuePerSlopeAngleMaxDist;                              // 0x0068 (size: 0x8)
    FFloatRange m_PitchWithSlopeRangeMinMaxDist;                                      // 0x0070 (size: 0x10)
    bool m_bTeleportPointComputation;                                                 // 0x0080 (size: 0x1)
    bool m_bUseCollisionAnticipationCorrection;                                       // 0x0081 (size: 0x1)
    bool m_bUsePositionToLockDamping;                                                 // 0x0082 (size: 0x1)
    float m_fTargetPosDampingValue;                                                   // 0x0084 (size: 0x4)
    bool m_bUsePositionZOffset;                                                       // 0x0088 (size: 0x1)
    float m_fLookAtUpOffset;                                                          // 0x008C (size: 0x4)
    bool m_bUsePositionRatio;                                                         // 0x0090 (size: 0x1)
    float m_fPositionRatioToTarget;                                                   // 0x0094 (size: 0x4)
    float m_fPositionRatioDistanceMaxToComputeRatioForLockRange;                      // 0x0098 (size: 0x4)
    float m_fPositionRatioLockDistMin;                                                // 0x009C (size: 0x4)
    float m_fPositionRatioLockDistMax;                                                // 0x00A0 (size: 0x4)
    float m_fPositionRatioLookAtUpOffsetCompensation;                                 // 0x00A4 (size: 0x4)

}; // Size: 0xA8

struct FCameraLookAtServiceBehaviorTime
{
    float m_fReachDuration;                                                           // 0x0000 (size: 0x4)
    class UCurveFloat* m_CurveReachDurationPerAngleDiff;                              // 0x0008 (size: 0x8)
    ESCBlendType m_eReachBlendType;                                                   // 0x0010 (size: 0x1)
    class UCurveFloat* m_ReachCurveDynamic;                                           // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FCameraMirrorManagementConfig
{
    ECameraMirrorManagementType m_eMirrorType;                                        // 0x0000 (size: 0x1)
    float m_fTargetValue;                                                             // 0x0004 (size: 0x4)
    float m_fSpringSpeed;                                                             // 0x0008 (size: 0x4)
    bool m_bInstantSpring;                                                            // 0x000C (size: 0x1)
    ESCBlendType m_eBlenderBlendType;                                                 // 0x000D (size: 0x1)
    class UCurveFloat* m_BlenderCustomCurve;                                          // 0x0010 (size: 0x8)
    float m_fBlenderDuration;                                                         // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FCameraNodeStruct
{
    ECameraTrackingMode m_eTrackingTranslationMode;                                   // 0x0000 (size: 0x1)
    ECameraTrackingMode m_eTrackingRotationMode;                                      // 0x0001 (size: 0x1)
    FVector4 m_vFulcrumOffset;                                                        // 0x0010 (size: 0x10)
    bool m_bDynamicFulcrumOffsetEnabled;                                              // 0x0020 (size: 0x1)
    FVector4 m_vSafeOffset;                                                           // 0x0030 (size: 0x10)
    bool m_bUseAboveIdealOffset;                                                      // 0x0040 (size: 0x1)
    FVector m_vAboveIdealOffset;                                                      // 0x0044 (size: 0xC)
    FVector4 m_vIdealOffset;                                                          // 0x0050 (size: 0x10)
    bool m_bUseBelowIdealOffset;                                                      // 0x0060 (size: 0x1)
    FVector m_vBelowIdealOffset;                                                      // 0x0064 (size: 0xC)
    bool m_bIsCollisionEnabled;                                                       // 0x0070 (size: 0x1)
    float m_fFov;                                                                     // 0x0074 (size: 0x4)
    bool m_bIsFovVertical;                                                            // 0x0078 (size: 0x1)
    bool m_bConstraintAspectRatio;                                                    // 0x0079 (size: 0x1)
    float m_fContraintAspectRatio;                                                    // 0x007C (size: 0x4)
    bool m_bIsAnimDriven;                                                             // 0x0080 (size: 0x1)
    bool m_bAllowAnimDrivenFov;                                                       // 0x0081 (size: 0x1)
    bool m_bFovFromPreviousCameraData;                                                // 0x0082 (size: 0x1)
    bool m_bSnapRefLocation;                                                          // 0x0083 (size: 0x1)
    float m_fRefDampingFactor;                                                        // 0x0084 (size: 0x4)
    float m_fCoolDownAfterManualCameraTouch;                                          // 0x0088 (size: 0x4)
    bool m_bAllowComfortService;                                                      // 0x008C (size: 0x1)
    float m_fHorizontalSpeed;                                                         // 0x0090 (size: 0x4)
    float m_fVerticalSpeed;                                                           // 0x0094 (size: 0x4)
    bool m_bFixedYaw;                                                                 // 0x0098 (size: 0x1)
    bool m_bFixedPitch;                                                               // 0x0099 (size: 0x1)
    bool m_bFixedRoll;                                                                // 0x009A (size: 0x1)
    float m_fFixedYaw;                                                                // 0x009C (size: 0x4)
    float m_fFixedPitch;                                                              // 0x00A0 (size: 0x4)
    float m_fFixedRoll;                                                               // 0x00A4 (size: 0x4)
    float m_fAboveLimitPitch;                                                         // 0x00A8 (size: 0x4)
    float m_fBelowLimitPitch;                                                         // 0x00AC (size: 0x4)
    class UCurveFloat* m_curveCameraShakeFactorByDistToOwner;                         // 0x00B0 (size: 0x8)
    bool m_bFollow;                                                                   // 0x00B8 (size: 0x1)
    float m_fFollowPitchOffset;                                                       // 0x00BC (size: 0x4)
    float m_fFollowPitchDampingFactor;                                                // 0x00C0 (size: 0x4)
    float m_fFollowPitchMultiplier;                                                   // 0x00C4 (size: 0x4)
    class UCurveFloat* m_followYawDampingFactorCurve;                                 // 0x00C8 (size: 0x8)
    float m_fFollowWakeUpMaxPitchDiffAngle;                                           // 0x00D0 (size: 0x4)
    float m_fFollowWakeUpMaxYawDiffAngle;                                             // 0x00D4 (size: 0x4)
    bool m_bIsCamOverTheShoulderDisabled;                                             // 0x00D8 (size: 0x1)
    bool m_bLockOnTarget;                                                             // 0x00DA (size: 0x1)
    float m_fLockOnTargetWakeUpMaxPitchDiffAngle;                                     // 0x00DC (size: 0x4)
    float m_fLockOnTargetWakeUpMaxYawDiffAngle;                                       // 0x00E0 (size: 0x4)
    bool m_bLockFollowing;                                                            // 0x00E4 (size: 0x1)
    float m_fLockFollowingWakeUpMaxPitchDiffAngle;                                    // 0x00E8 (size: 0x4)
    float m_fLockFollowingWakeUpMaxYawDiffAngle;                                      // 0x00EC (size: 0x4)
    bool m_bLockFramingContainer;                                                     // 0x00F0 (size: 0x1)
    float m_fLockFraimingContainerDeadZonenCenterX;                                   // 0x00F4 (size: 0x4)
    float m_fLockFraimingContainerDeadZonenCenterY;                                   // 0x00F8 (size: 0x4)
    float m_fScreenPercentSoftEdgeX;                                                  // 0x00FC (size: 0x4)
    float m_fScreenPercentSoftEdgeY;                                                  // 0x0100 (size: 0x4)
    float m_fScreenPercentHardEdgeX;                                                  // 0x0104 (size: 0x4)
    float m_fScreenPercentHardEdgeY;                                                  // 0x0108 (size: 0x4)
    float m_fMinRangeDistanceToOwner;                                                 // 0x010C (size: 0x4)
    float m_fMaxRangeDistanceToOwner;                                                 // 0x0110 (size: 0x4)
    float m_fDistanceDampingFactor;                                                   // 0x0114 (size: 0x4)
    bool m_bCameraFramingLerpOnDistance;                                              // 0x0118 (size: 0x1)
    float m_fHeightAboveOwner;                                                        // 0x011C (size: 0x4)
    float m_fCameraFramingHeightDampingFactor;                                        // 0x0120 (size: 0x4)
    bool m_bCameraFramingLerpOnHeight;                                                // 0x0124 (size: 0x1)
    bool m_bUsePitchAtRest;                                                           // 0x0125 (size: 0x1)
    bool m_bPitchAtRestComputationMethodSlope;                                        // 0x0126 (size: 0x1)
    bool m_bPitchAtRestComputationMethodTarget;                                       // 0x0127 (size: 0x1)
    bool m_bPitchAtRestComputationMethodTargetThenSlope;                              // 0x0128 (size: 0x1)
    float m_fPitchAtRestSprintSpeedValue;                                             // 0x012C (size: 0x4)
    class UCurveFloat* m_PitchAtRestValuePerSlopeAngle;                               // 0x0130 (size: 0x8)
    class UCurveFloat* m_PitchAtRestOffsetPerSafeZoneSize;                            // 0x0138 (size: 0x8)
    class UCurveFloat* m_PitchAtRestOffsetFactorByDistToTarget;                       // 0x0140 (size: 0x8)
    float m_fPitchAtRestOffsetSpringSpeedValue;                                       // 0x0148 (size: 0x4)
    float m_fPitchAtRestWakeUpMaxPitchDiffAngle;                                      // 0x014C (size: 0x4)
    bool m_bUseAboveHeadIdealOffset;                                                  // 0x0150 (size: 0x1)
    class UCurveFloat* m_AboveHeadIdealOffsetOffsetPerSafeZoneSize;                   // 0x0158 (size: 0x8)
    class UCurveFloat* m_AboveHeadIdealOffsetFactorByDistToTarget;                    // 0x0160 (size: 0x8)
    float m_fAboveHeadIdealOffsetSpringSpeedValue;                                    // 0x0168 (size: 0x4)
    bool m_bAboveHeadIdealOffsetApplyOnAbove;                                         // 0x016C (size: 0x1)
    bool m_bAboveHeadIdealOffsetApplyOnBelow;                                         // 0x016D (size: 0x1)
    bool m_bUseRepulsionFromDeadZone;                                                 // 0x016E (size: 0x1)
    float m_fCollisionRatioToConsideredAsNearInRepulsion;                             // 0x0170 (size: 0x4)
    bool m_bCanBeMirrored;                                                            // 0x0174 (size: 0x1)
    bool m_bUseCameraSideCollisionMirror;                                             // 0x0175 (size: 0x1)
    bool m_bUseCameraCombatMirrorService;                                             // 0x0176 (size: 0x1)
    float m_fCameraCombatMirrorCursorAvoidRangeAroundMiddle;                          // 0x0178 (size: 0x4)
    float m_fCameraCombatMirrorCursorAvoidRangeMinRailCollisionRatio;                 // 0x017C (size: 0x4)
    float m_fCameraCombatMirrorCursorAvoidRangeMinCamDist;                            // 0x0180 (size: 0x4)
    class UCurveFloat* m_CombatMirrorWeightWhiskerCastByAngularDistToRight;           // 0x0188 (size: 0x8)
    float m_fCombatMirrorCachedAngleDistAtWeightZero;                                 // 0x0190 (size: 0x4)
    class UCurveFloat* m_CameraCombatMirrorProjRemapNotInMirror;                      // 0x0198 (size: 0x8)
    class UCurveFloat* m_CameraCombatMirrorSideTraceDistRatioRemap;                   // 0x01A0 (size: 0x8)
    float m_fCombatMirrorProjSpringSpeedInsideCollisionBoundary;                      // 0x01A8 (size: 0x4)
    float m_fCombatMirrorProjSpringSpeedOutsideCollisionBoundary;                     // 0x01AC (size: 0x4)
    bool m_bAllowCameraLookAtToExtractCollision;                                      // 0x01B0 (size: 0x1)
    bool m_bAllowDodgeToTriggerMirrorChange;                                          // 0x01B1 (size: 0x1)

}; // Size: 0x1C0

struct FCameraNodeStructInherited
{
}; // Size: 0x1

struct FCameraRepulsionConfig
{
    float m_fRepulsionSleepTimerAfterManualCam;                                       // 0x0000 (size: 0x4)
    TArray<FCameraRepulsionConfigElement> m_RepulsionsElements;                       // 0x0008 (size: 0x10)
    float m_fDeadZoneHidingTargetPositionSpringSpeed;                                 // 0x0018 (size: 0x4)
    float m_fCollidingDeadZoneExtraAngleOffset;                                       // 0x001C (size: 0x4)
    float m_fLookAtYawDampingValueThisFrameToDisableRepulsion;                        // 0x0020 (size: 0x4)
    float m_fCollisionRailRatioToActivateRepulsionFromCollidingDeadZone;              // 0x0024 (size: 0x4)
    bool m_bUseMergedDeadZonesWhenRepulsingFromOnlyHidingZone;                        // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FCameraRepulsionConfigElement
{
    TArray<FBaseActorConditionInstance> m_Conditions;                                 // 0x0000 (size: 0x10)
    TArray<FBaseActorTargetConditionInstance> m_ActorTargetConditions;                // 0x0010 (size: 0x10)
    class UCurveFloat* m_DeadZoneHidingAngleSizePerSafeZoneSizeFront;                 // 0x0020 (size: 0x8)
    class UCurveFloat* m_DeadZoneHidingAngleSizePerSafeZoneSizeBack;                  // 0x0028 (size: 0x8)
    class UCurveFloat* m_DeadZoneHidingSizeFactorPerDistanceToTargetFront;            // 0x0030 (size: 0x8)
    class UCurveFloat* m_DeadZoneHidingSizeFactorPerDistanceToTargetBack;             // 0x0038 (size: 0x8)
    class UCurveFloat* m_RepulsionSpringValuePerCameraRailCollisionRatio;             // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FCameraSafePointCondition
{
    bool m_bUseDeadZoneCountRange;                                                    // 0x0000 (size: 0x1)
    FInt32Range m_iDeadZoneCountRange;                                                // 0x0004 (size: 0x10)
    bool m_bUseDeadZoneAngleRange;                                                    // 0x0014 (size: 0x1)
    FFloatRange m_fDeadZoneAngleRange;                                                // 0x0018 (size: 0x10)
    bool m_bUseSafeZoneAngleRange;                                                    // 0x0028 (size: 0x1)
    FFloatRange m_fSafeZoneAngleRange;                                                // 0x002C (size: 0x10)

}; // Size: 0x3C

struct FCameraSafePointConditionalPlacement
{
    FCameraSafePointCondition m_condition;                                            // 0x0000 (size: 0x3C)
    FCameraSafePointPlacement m_placement;                                            // 0x003C (size: 0x1C)

}; // Size: 0x58

struct FCameraSafePointPlacement
{
    FFloatRange m_fSafePointDistRange;                                                // 0x0000 (size: 0x10)
    bool m_bOrientateTowardsCamForward;                                               // 0x0010 (size: 0x1)
    bool m_bUseDeadZoneBissector;                                                     // 0x0011 (size: 0x1)
    float m_fSafeZoneAngleOffset;                                                     // 0x0014 (size: 0x4)
    float m_fBlendInTime;                                                             // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FCameraTargetPosition
{
    class AActor* m_Actor;                                                            // 0x0000 (size: 0x8)
    FVector m_vPreProcessedTargetPosition;                                            // 0x0008 (size: 0xC)
    FVector m_vRawTargetPosition;                                                     // 0x0014 (size: 0xC)
    float m_fLifeTime;                                                                // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FCameraTransitionEventStruct
{
    float m_fRatio;                                                                   // 0x0000 (size: 0x4)
    TSubclassOf<class UCameraTransitionEvent> m_Event;                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCameraTransitionInfoPairStruct
{
    class UAbstractCameraData* m_CameraData;                                          // 0x0000 (size: 0x8)
    class UCameraTransitionInfo* m_CameraTransitionInfo;                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCancelAnimContainerQuadrantArray
{
    FAnimContainer m_Array;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FCaptureInputResult
{
    TArray<FInputMappingKeySlot> m_Slots;                                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCardinalAnimContainer
{
    FAnimContainer m_Anims;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FCardinalChangementAnimContainer
{
    FCardinalAnimContainer m_Cardinals;                                               // 0x0000 (size: 0x180)

}; // Size: 0x180

struct FCardinalMatchArray
{
    TArray<ESCCardinalPoints> m_Array;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCardinalSpeed
{
    bool m_bUseCommonSpeed;                                                           // 0x0000 (size: 0x1)
    FFloatRange m_CommonSpeed;                                                        // 0x0004 (size: 0x10)
    FFloatRange m_CardinalSpeeds;                                                     // 0x0014 (size: 0x40)

}; // Size: 0x54

struct FCarriedPropDataRow : public FTableRowBase
{
    FName m_LocatorName;                                                              // 0x0008 (size: 0x8)
    TSubclassOf<class AActor> m_ClassToSpawn;                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FCarriedProps
{
    FDataTableRowHandle m_props;                                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCarriedPropsContainer
{
    FCarriedProps m_CarriedProp;                                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCarriedWeaponContainer
{
    TSubclassOf<class ABaseWeapon> m_carriedWeapon;                                   // 0x0000 (size: 0x8)
    FName m_CarriedWeaponPoolName;                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCharacterProgressionReward
{
    ECharacterProgressionRewardConditions m_eUnlockCondition;                         // 0x0000 (size: 0x1)
    int32 m_iUnlockParameter;                                                         // 0x0004 (size: 0x4)
    TArray<class UCharacterProgressionUnlockDB*> m_Unlocks;                           // 0x0008 (size: 0x10)
    bool m_bAddToNewRewards;                                                          // 0x0018 (size: 0x1)
    FText m_NotificationText;                                                         // 0x0020 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_NotificationIcon;                                    // 0x0038 (size: 0x28)

}; // Size: 0x60

struct FCharacterStatsBindings
{
    FAsyncTextureStruct m_FightingStyleIcon;                                          // 0x0000 (size: 0x28)
    FIntStatBinding m_CurrentLevelXP;                                                 // 0x0028 (size: 0x50)
    FIntStatBinding m_XPToNextLevel;                                                  // 0x0078 (size: 0x50)
    float m_fLevelProgress;                                                           // 0x00C8 (size: 0x4)
    FIntStatBinding m_AttributePoints;                                                // 0x00D0 (size: 0x50)
    FIntStatBinding m_PrestigePoints;                                                 // 0x0120 (size: 0x50)
    FIntStatBinding m_PrestigeGrade;                                                  // 0x0170 (size: 0x50)
    FIntStatBinding m_Fragments;                                                      // 0x01C0 (size: 0x50)
    FIntStatBinding m_Level;                                                          // 0x0210 (size: 0x50)
    FFloatStatBinding m_BareHandsWeightRatio;                                         // 0x0260 (size: 0x50)
    FFloatStatBinding m_WeaponWeightRatio;                                            // 0x02B0 (size: 0x50)

}; // Size: 0x300

struct FCharacterStatsValues
{
    TMap<ECharacterStat, float> m_Values;                                             // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FChargedAttackNameByQuadrants
{
    FName m_Attacks;                                                                  // 0x0000 (size: 0x20)
    float m_StartRatio;                                                               // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FChargedBuildUpStructByQuadrant
{
    FAnimContainer m_BuildUpByQuadrant;                                               // 0x0000 (size: 0x60)
    FChargedBuildUpStructGenericInfos m_Infos;                                        // 0x0060 (size: 0xC)

}; // Size: 0x70

struct FChargedBuildUpStructGenericInfos
{
    float m_fDurationOfCharging;                                                      // 0x0000 (size: 0x4)
    float m_fExtraHoldingTimeAfterChargeIscomplete;                                   // 0x0004 (size: 0x4)
    bool m_bAllowQuadrantToRecompute;                                                 // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FChargedCap
{
    FFrameRange m_FrameRange;                                                         // 0x0000 (size: 0x10)
    float m_fDuration;                                                                // 0x0010 (size: 0x4)
    TArray<FChargedOverridingHitBox> m_HitBoxes;                                      // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FChargedOverridingHitBox
{
    uint8 m_uiHitBoxToOverride;                                                       // 0x0000 (size: 0x1)
    FDataTableRowHandle m_HitRow;                                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCheckPointStruct
{
    FName m_SpawnPoint;                                                               // 0x0000 (size: 0x8)
    TArray<FName> m_LevelToStreams;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FChosenAttackProperties
{
}; // Size: 0x2

struct FClusterStruct
{
    class UStaticMeshComponent* m_MeshComp;                                           // 0x0000 (size: 0x8)
    TSubclassOf<class AThrowableActor> m_ThrowableSubClass;                           // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCombatCircleDescription
{
    float m_fRadius;                                                                  // 0x0000 (size: 0x4)
    float m_fOffsetRotation;                                                          // 0x0004 (size: 0x4)
    int32 m_NbPositionsToGenerate;                                                    // 0x0008 (size: 0x4)
    float m_fPositionGenerationThreshold;                                             // 0x000C (size: 0x4)
    bool m_bAllowSnapAfterRaycast;                                                    // 0x0010 (size: 0x1)
    float m_fSnapSafeDistance;                                                        // 0x0014 (size: 0x4)
    float m_fNavPickingTolerance;                                                     // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FCombatDeckDetails
{
    FCombatDeckStat m_TotalDamage;                                                    // 0x0000 (size: 0x88)
    FCombatDeckStat m_StatsDamage;                                                    // 0x0088 (size: 0x88)
    FCombatDeckStat m_WeaponDamage;                                                   // 0x0110 (size: 0x88)
    FCombatDeckStat m_WeaponDamageScale;                                              // 0x0198 (size: 0x88)
    FCombatDeckStat m_BaseAttackDamage;                                               // 0x0220 (size: 0x88)
    FCombatDeckStat m_AttackBonus;                                                    // 0x02A8 (size: 0x88)
    FCombatDeckStat m_Range;                                                          // 0x0330 (size: 0x88)
    FCombatDeckStat m_Speed;                                                          // 0x03B8 (size: 0x88)
    FCombatDeckStat m_StrengthScale;                                                  // 0x0440 (size: 0x88)
    FCombatDeckStat m_AgilityScale;                                                   // 0x04C8 (size: 0x88)
    FCombatDeckStat m_WRScale;                                                        // 0x0550 (size: 0x88)
    TSoftObjectPtr<UTexture2D> m_eWeaponFamilyMiniIcon;                               // 0x05D8 (size: 0x28)
    FAsyncTextureStruct m_eWeaponFamilyMiniIconAsync;                                 // 0x0600 (size: 0x28)
    FEquipmentCategoryInfos m_WeaponFamilyInfos;                                      // 0x0628 (size: 0xC0)
    FText m_ComboName;                                                                // 0x06E8 (size: 0x18)
    TArray<FName> m_Attacks;                                                          // 0x0700 (size: 0x10)
    float m_fTotatDamageWithCoef;                                                     // 0x0710 (size: 0x4)

}; // Size: 0x718

struct FCombatDeckStat
{
    float m_fAverage;                                                                 // 0x0014 (size: 0x4)
    FString m_AverageString;                                                          // 0x0018 (size: 0x10)
    float m_fRating;                                                                  // 0x0028 (size: 0x4)
    FSlateColor m_ComparisonColor;                                                    // 0x0030 (size: 0x28)
    FSlateColor m_RatingComparisonColor;                                              // 0x0058 (size: 0x28)

}; // Size: 0x88

struct FCombatSpeedTransitionsAnimContainer : public FSpeedTransitionsAnimContainer
{
    FCardinalChangementAnimContainer m_Start_FR;                                      // 0x02D0 (size: 0x180)

}; // Size: 0x450

struct FCombinationInput
{
    class UGenericInputData* m_Input;                                                 // 0x0000 (size: 0x8)
    float m_fLifeSpan;                                                                // 0x0008 (size: 0x4)
    bool m_bRegisterPressTimeOnStack;                                                 // 0x000C (size: 0x1)
    bool m_bRemovePressedTimeFromTimeLeft;                                            // 0x000D (size: 0x1)

}; // Size: 0x10

struct FComboAIConditionFindActorsEnvQueryResult
{
    TWeakObjectPtr<class AActor> m_Actor;                                             // 0x0000 (size: 0x8)
    FVector m_vLocation;                                                              // 0x0008 (size: 0xC)

}; // Size: 0x14

struct FComboAttack
{
    FDataTableRowHandle m_AnimationRow;                                               // 0x0000 (size: 0x10)
    class UAnimationAsset* m_animation;                                               // 0x0010 (size: 0x8)
    FWeaponAnimInfo m_weaponAnimInfoAssociated;                                       // 0x0018 (size: 0x90)
    bool m_bUsePreviousAttackFakieState;                                              // 0x00A8 (size: 0x1)
    float m_fAnimFrameRate;                                                           // 0x00AC (size: 0x4)
    float m_fAnimFrameDeltaTime;                                                      // 0x00B0 (size: 0x4)
    int32 m_iWantedBuildupFrames;                                                     // 0x00B4 (size: 0x4)
    bool m_bOverrideMinBuildupForwardDisplacement;                                    // 0x00B8 (size: 0x1)
    float m_fMinBuildupForwardDisplacement;                                           // 0x00BC (size: 0x4)
    bool m_bOverrideAnimRange;                                                        // 0x00C0 (size: 0x1)
    float m_fGameplayRange;                                                           // 0x00C4 (size: 0x4)
    bool m_bIgnoreRange;                                                              // 0x00C8 (size: 0x1)
    bool m_bWantCustomMaxDisSnap;                                                     // 0x00C9 (size: 0x1)
    float m_fCustomMaxDisSnap;                                                        // 0x00CC (size: 0x4)
    float m_fSnapbackMargin;                                                          // 0x00D0 (size: 0x4)
    bool m_bWantSnap;                                                                 // 0x00D4 (size: 0x1)
    bool m_bWantSnapBack;                                                             // 0x00D5 (size: 0x1)
    bool m_bWantSnapDuringStrike;                                                     // 0x00D6 (size: 0x1)
    bool m_bIsRushAttack;                                                             // 0x00D7 (size: 0x1)
    bool m_bAlwaysTrackHittedTarget;                                                  // 0x00D8 (size: 0x1)
    float m_fMaxTrackingAngle;                                                        // 0x00DC (size: 0x4)
    bool m_bApplyHitWithoutAttack;                                                    // 0x00E0 (size: 0x1)
    TArray<FHitBox> m_HitBoxes;                                                       // 0x00E8 (size: 0x10)
    EApplyDamageOnWeaponType m_eApplyDamageOnWeaponType;                              // 0x00F8 (size: 0x4)
    TArray<FAvailabilityLayerWindow> m_AvailabilityLayerWindows;                      // 0x0100 (size: 0x10)
    TArray<FAvoidWindow> m_AvoidWindows;                                              // 0x0110 (size: 0x10)
    TArray<FAbsorbWindow> m_AbsorbWindows;                                            // 0x0120 (size: 0x10)
    FGameplayTagContainer m_AttackProperties;                                         // 0x0130 (size: 0x20)

}; // Size: 0x150

struct FComboConditionValueToNodeMap
{
    TMap<uint8, uint8> m_Map;                                                         // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FComboNode
{
    FGameplayTagContainer m_RequiredTags;                                             // 0x0000 (size: 0x20)
    FComboNodeAttackInfos m_AttackInfos;                                              // 0x0020 (size: 0x40)
    TMap<class FGameplayTag, class FComboNodeAttackInfos> m_ConditionalAttacks;       // 0x0060 (size: 0x50)
    UClass* m_AIAttackActionClass;                                                    // 0x00B0 (size: 0x8)
    FAIActionAttackClassInstance m_AIAttackAction;                                    // 0x00B8 (size: 0x10)
    FComboTransitions m_Transitions;                                                  // 0x00C8 (size: 0x18)
    int32 m_NodeRedirect;                                                             // 0x00E0 (size: 0x4)
    FAvailabilityLayerContainer m_NodeRedirectAvailabilityLayer;                      // 0x00E8 (size: 0x10)
    TArray<EComboTransition> m_NodeRedirectIgnoredTransitions;                        // 0x00F8 (size: 0x10)
    class UComboEvent* m_Event;                                                       // 0x0108 (size: 0x8)
    FName m_Name;                                                                     // 0x0110 (size: 0x8)
    bool m_bSkip;                                                                     // 0x0118 (size: 0x1)

}; // Size: 0x120

struct FComboNodeAttackInfos
{
    FName m_Attacks;                                                                  // 0x0000 (size: 0x20)
    TArray<FChargedAttackNameByQuadrants> m_ChargedAttacks;                           // 0x0020 (size: 0x10)
    TArray<FChargedBuildUpStructByQuadrant> m_BuildUpForChargedAttack;                // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FComboOverride
{
    FName m_DifficultyName;                                                           // 0x0000 (size: 0x8)
    class UCombo* m_ComboOverride;                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FComboStartNode
{
    FSCUserDefinedEnumHandler m_EnumState;                                            // 0x0000 (size: 0x50)
    FComboTransitions m_ComboTransitions;                                             // 0x0050 (size: 0x18)
    FName m_PhaseName;                                                                // 0x0068 (size: 0x8)
    uint32 m_uiMCDominationFlags;                                                     // 0x0070 (size: 0x4)

}; // Size: 0x78

struct FComboTransition
{
    EComboTransition m_eInputTransition;                                              // 0x0000 (size: 0x1)
    class UComboTransitionCondition* m_ConditionInstance;                             // 0x0008 (size: 0x8)
    TMap<uint8, int32> m_TargetNodes;                                                 // 0x0010 (size: 0x50)
    float m_fProbability;                                                             // 0x0060 (size: 0x4)

}; // Size: 0x68

struct FComboTransitions
{
    TArray<FComboTransition> m_Transitions;                                           // 0x0000 (size: 0x10)
    FName m_ParentNodeName;                                                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FConditionOnTargetWeightEvaluation
{
    FBaseActorTargetConditionInstance m_condition;                                    // 0x0000 (size: 0x10)
    float m_fBonus;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FContainedCameraDataModifierWithBehavior
{
}; // Size: 0x1

struct FContainedCameraTransitionInfoPairStruct
{
}; // Size: 0x1

struct FContainedCameraTransitionInfoStruct
{
}; // Size: 0x1

struct FControllerAxisIcons
{
    TArray<FKey> m_Keys;                                                              // 0x0000 (size: 0x10)
    FControllerAxisTypeIcons m_AxisIcons;                                             // 0x0010 (size: 0x3C0)
    bool m_bShowText;                                                                 // 0x03D0 (size: 0x1)
    FText m_ReplacementText;                                                          // 0x03D8 (size: 0x18)

}; // Size: 0x3F0

struct FControllerAxisTypeIcons
{
    TSoftObjectPtr<UTexture2D> m_AxisTypeIcons;                                       // 0x0000 (size: 0x140)

}; // Size: 0x140

struct FControllerIcons
{
    TArray<FName> m_Controllers;                                                      // 0x0000 (size: 0x10)
    TArray<EPlatform> m_Platforms;                                                    // 0x0010 (size: 0x10)
    TArray<FControllerKeyIcons> m_KeyIcons;                                           // 0x0020 (size: 0x10)
    TArray<FControllerAxisIcons> m_AxisIcons;                                         // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FControllerKeyIcons
{
    FKey m_Key;                                                                       // 0x0000 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_Icons;                                               // 0x0018 (size: 0x78)
    bool m_bShowText;                                                                 // 0x0090 (size: 0x1)
    FText m_ReplacementText;                                                          // 0x0098 (size: 0x18)

}; // Size: 0xB0

struct FCoopGroup
{
    TArray<FCoopGroupMemberInfo> m_GroupMemberInfos;                                  // 0x0000 (size: 0x10)
    EGameModeTypes m_eGameModeType;                                                   // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FCoopGroupMemberInfo
{
    FUniqueNetIdRepl m_UniqueNetId;                                                   // 0x0000 (size: 0x28)
    ECoopGameModeAnswerStatus m_eAnswerStatus;                                        // 0x0034 (size: 0x1)

}; // Size: 0x38

struct FCreditCategoryStruct
{
    FText m_CategoryName;                                                             // 0x0000 (size: 0x18)
    TArray<FCreditContributorStruct> m_Contributors;                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FCreditCompanyStruct
{
    FName m_CompanyName;                                                              // 0x0000 (size: 0x8)
    TArray<FCreditCategoryStruct> m_Categories;                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCreditContributorStruct
{
    FName m_FirstName;                                                                // 0x0000 (size: 0x8)
    FName m_LastName;                                                                 // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCustomUIInfosPerSlot
{
    int32 m_iSlotIndex;                                                               // 0x0000 (size: 0x4)
    EControllerIconAxisTypes m_AxisTypes;                                             // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FCustomWidgetNavigationData
{
    bool m_bAnalogNavigation;                                                         // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FDLCContent
{
    TArray<FName> m_entitlements;                                                     // 0x0000 (size: 0x10)
    TArray<FInventoryItem> m_Gears;                                                   // 0x0010 (size: 0x10)
    TArray<FName> m_Emotes;                                                           // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FDamageInfos
{
    TWeakObjectPtr<class AActor> m_Instigator;                                        // 0x0008 (size: 0x8)
    bool m_bTakenDown;                                                                // 0x0013 (size: 0x1)

}; // Size: 0x28

struct FDamagedWeaponInfo
{
    TSubclassOf<class UBaseWeaponData> m_WeaponDataToApplyOnBrokenWeapon;             // 0x0000 (size: 0x8)
    TSubclassOf<class UWeaponGameplayData> m_WeaponGameplayDataToApplyOnBrokenWeapon; // 0x0008 (size: 0x8)
    float m_fDamagedWeaponHealth;                                                     // 0x0010 (size: 0x4)
    class USkeletalMesh* m_StateSkeletalMesh;                                         // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FDeadZone
{
    FAngleRange m_angleRange;                                                         // 0x0000 (size: 0x8)
    float m_fMinDistance;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FDeathAnimAttackCardinalArray
{
    class UAnimSequence* m_Array;                                                     // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FDeathAnimAttackHeightArray
{
    FDeathAnimAttackCardinalArray m_Array;                                            // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FDeathAnimAttackPowerArray
{
    FDeathAnimAttackHeightArray m_Array;                                              // 0x0000 (size: 0x120)

}; // Size: 0x120

struct FDeathAnimQuadrantArray
{
    FDeathAnimAttackPowerArray m_Array;                                               // 0x0000 (size: 0x480)

}; // Size: 0x480

struct FDeathRadialImpulse
{
    float Radius;                                                                     // 0x0000 (size: 0x4)
    TEnumAsByte<ERadialImpulseFalloff> Falloff;                                       // 0x0004 (size: 0x1)
    float ImpulseStrength;                                                            // 0x0008 (size: 0x4)
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypesToAffect;                        // 0x0010 (size: 0x10)
    bool bImpulseVelChange;                                                           // 0x0020 (size: 0x1)
    float DestructibleDamage;                                                         // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FDeathStandupAnimationFromAnimation
{
    class UAnimSequence* m_DeathAnim;                                                 // 0x0000 (size: 0x8)
    FAnimContainer m_StandAnim;                                                       // 0x0008 (size: 0x18)

}; // Size: 0x20

struct FDeathStandupAnimations
{
    FAnimContainer m_FaceDown;                                                        // 0x0000 (size: 0x18)
    FAnimContainer m_FaceUp;                                                          // 0x0018 (size: 0x18)
    FAnimContainer m_SideLeft;                                                        // 0x0030 (size: 0x18)
    FAnimContainer m_SideRight;                                                       // 0x0048 (size: 0x18)
    float m_fMinFaceAngle;                                                            // 0x0060 (size: 0x4)
    TArray<FDeathStandupAnimationFromAnimation> m_SpecialCases;                       // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FDefenderAnimInfos : public FDefenseAnimInfos
{
    bool m_bParryToStructureBrokenDisableReorient;                                    // 0x01A8 (size: 0x1)
    bool m_bParryToDizzyDisableReorient;                                              // 0x01A9 (size: 0x1)
    bool m_bParrySuccessDisableReorient;                                              // 0x01AA (size: 0x1)

}; // Size: 0x1B0

struct FDefenseAnimInfos
{
    FAnimContainer m_Anim;                                                            // 0x0000 (size: 0x18)
    FHittedAnimContainer m_ParryToStructureBrokenAnim;                                // 0x0018 (size: 0x68)
    FHittedAnimContainer m_ParryToDizzyAnim;                                          // 0x0080 (size: 0x68)
    bool m_bMirrorFightingStateLoop;                                                  // 0x00E8 (size: 0x1)
    TMap<class ESCCardinalPoints, class FAnimContainer> m_PushFromGrabAnims;          // 0x00F0 (size: 0x50)
    TMap<class ESCCardinalPoints, class FAnimContainer> m_PushFromGrabCloseWallAnims; // 0x0140 (size: 0x50)
    FAnimContainer m_ParrySuccessAnim;                                                // 0x0190 (size: 0x18)

}; // Size: 0x1A8

struct FDefenseGauge
{
    float m_fMaxValue;                                                                // 0x0000 (size: 0x4)
    float m_fCooldownBeforeRecovery;                                                  // 0x0004 (size: 0x4)
    float m_fRecoveryRatePerSec;                                                      // 0x0008 (size: 0x4)
    float m_fRecoveryRatePerSecWhenComplete;                                          // 0x000C (size: 0x4)

}; // Size: 0x18

struct FDeflectImpact : public FHitImpact
{
    class UCurveFloat* m_KnockBackDynamic;                                            // 0x0030 (size: 0x8)
    bool m_bSelfStructureDamageCanGuardBreak;                                         // 0x0038 (size: 0x1)
    bool m_bUseSelfStructureDamage;                                                   // 0x0039 (size: 0x1)
    float m_fSelfStructureDamage;                                                     // 0x003C (size: 0x4)
    bool m_bUseSelfSuperDizzyDamage;                                                  // 0x0040 (size: 0x1)
    float m_fSelfSuperDizzyDamage;                                                    // 0x0044 (size: 0x4)

}; // Size: 0x48

struct FDeltaTransformAudioStep
{
    float m_fMinDistance;                                                             // 0x0000 (size: 0x4)
    float m_fMinDeltaAngle;                                                           // 0x0004 (size: 0x4)
    class UAkAudioEvent* m_akEvent;                                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDestructibleStateInfo
{
    int32 m_iHealthThreshold;                                                         // 0x0000 (size: 0x4)
    class UStaticMesh* m_StateStaticMesh;                                             // 0x0008 (size: 0x8)
    class USkeletalMesh* m_StateSkeletalMesh;                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FDetailedMoveTransition
{
    ESpeedState m_eInSpeedState;                                                      // 0x0000 (size: 0x1)
    bool m_bAllowAllInCardinal;                                                       // 0x0001 (size: 0x1)
    ESCCardinalPoints m_eInCardinalPoint;                                             // 0x0002 (size: 0x1)
    ESpeedState m_eOutSpeedState;                                                     // 0x0003 (size: 0x1)
    ESCCardinalPoints m_eOutCardinalPoint;                                            // 0x0004 (size: 0x1)
    bool m_bFilterByVelocityRotation;                                                 // 0x0005 (size: 0x1)
    ETransitionRotation m_eVelocityRotation;                                          // 0x0006 (size: 0x1)
    bool m_bOverrideVelocityRotationRange;                                            // 0x0007 (size: 0x1)
    FFloatRange m_fVelocityRotationRangeOverride;                                     // 0x0008 (size: 0x10)
    ETransitionRotationDirection m_eVelocityRotationDirection;                        // 0x0018 (size: 0x1)
    EMoveTransitionType m_eResultingTransition;                                       // 0x0019 (size: 0x1)
    FString m_Description;                                                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FDisabledTargetInfos
{
    EActionType m_eActionType;                                                        // 0x0000 (size: 0x1)
    bool m_bTargettableWhenAlone;                                                     // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FDizzyReaction : public FPropertyReaction
{
    FAnimContainer m_Loop;                                                            // 0x00D0 (size: 0x18)
    bool m_bMirrorableLoop;                                                           // 0x00E8 (size: 0x1)
    bool m_bAllowDizzyOnTopOfDizzy;                                                   // 0x00E9 (size: 0x1)

}; // Size: 0xF0

struct FDodgeConfigStruct
{
    float m_fMinDuration;                                                             // 0x0000 (size: 0x4)
    float m_fMaxDurationArray;                                                        // 0x0004 (size: 0x10)
    float m_fMovementLengthArray;                                                     // 0x0014 (size: 0x10)
    bool m_bOverrideAnimDynamicByCurve;                                               // 0x0024 (size: 0x1)
    class UCurveFloat* m_OverrideDodgeDynamicCurve;                                   // 0x0028 (size: 0x8)
    int32 m_iFrameBuildUp;                                                            // 0x0030 (size: 0x4)
    int32 m_iNbFrameDodgeWindowMiddle;                                                // 0x0034 (size: 0x4)
    int32 m_iFrameInterruptibleRelease;                                               // 0x0038 (size: 0x4)
    int32 m_iFrameRelease;                                                            // 0x003C (size: 0x4)
    bool m_bHasImpactOnGuardGauge;                                                    // 0x0040 (size: 0x1)
    float m_fGuardGaugeCost;                                                          // 0x0044 (size: 0x4)
    bool m_bForceDirOnNeutralDodge;                                                   // 0x0048 (size: 0x1)
    ESCCardinalPoints m_eForcedCardinalDirOnNeutralDodge;                             // 0x0049 (size: 0x1)

}; // Size: 0x50

struct FDuplicatedSaveData
{
    ECharacterGender m_eGender;                                                       // 0x0000 (size: 0x1)
    TArray<class TSubclassOf<UGameplayEffect>> m_ShrineEffects;                       // 0x0008 (size: 0x10)
    TArray<class TSubclassOf<USkillGameplayEffect>> m_UnlockedSkills;                 // 0x0018 (size: 0x10)
    TMap<TSubclassOf<USkillGameplayEffect>, int32> m_SkillConsolidationLevel;         // 0x0028 (size: 0x50)
    TMap<ECharacterStat, float> m_DefaultStats;                                       // 0x0078 (size: 0x50)
    FGameplayTagContainer m_PlayerTags;                                               // 0x00C8 (size: 0x20)
    FGameplayTagContainer m_GameplayTagContainer;                                     // 0x00E8 (size: 0x20)
    float m_fMCDominationGauge;                                                       // 0x0108 (size: 0x4)
    int32 m_iLastManGauge;                                                            // 0x010C (size: 0x4)
    TArray<uint8> m_duplicatedSaveEntries;                                            // 0x0110 (size: 0x10)

}; // Size: 0x120

struct FDynamicMaterialInput
{
    FName m_ParameterToUpdate;                                                        // 0x0000 (size: 0x8)
    float m_fValue;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FDynamicMaterialsPerType
{
    TArray<class UMaterialInstanceDynamic*> m_DynamicMaterials;                       // 0x0008 (size: 0x10)
    TArray<class UMaterialInstance*> m_RefMaterials;                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FETS_NextHitExtraInfos
{
    FHitBox m_HitBox;                                                                 // 0x0000 (size: 0x298)
    bool m_bMirror;                                                                   // 0x0298 (size: 0x1)
    float m_fHitTime;                                                                 // 0x029C (size: 0x4)

}; // Size: 0x2A0

struct FEditableOrderType
{
    EOrderType m_eOrderType;                                                          // 0x0000 (size: 0x1)
    FSCUserDefinedEnumHandler m_BPOrderID;                                            // 0x0008 (size: 0x50)

}; // Size: 0x58

struct FEmoteDataRow : public FTableRowBase
{
    FName m_Name;                                                                     // 0x0008 (size: 0x8)
    FText m_RealName;                                                                 // 0x0010 (size: 0x18)
    FText m_Description;                                                              // 0x0028 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_Icon;                                                // 0x0040 (size: 0x28)
    class UAnimSequence* m_Anim;                                                      // 0x0068 (size: 0x8)
    class UAnimSequence* m_AnimWoman;                                                 // 0x0070 (size: 0x8)
    EEmoteAction m_eEmoteAction;                                                      // 0x0078 (size: 0x1)

}; // Size: 0x80

struct FEmoteShopDataRow : public FTableRowBase
{
    FName m_RowName;                                                                  // 0x0008 (size: 0x8)
    int32 m_iGMLevelRequired;                                                         // 0x0010 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0014 (size: 0x4)
    int32 m_iFragmentPrice;                                                           // 0x0018 (size: 0x4)
    int32 m_iPrestigePointPrice;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FEnvPushInfos
{
}; // Size: 0x1030

struct FEquipmentCategoryInfos
{
    FText m_Name;                                                                     // 0x0000 (size: 0x18)
    FText m_Description;                                                              // 0x0018 (size: 0x18)
    FText m_Lore;                                                                     // 0x0030 (size: 0x18)
    FAsyncTextureStruct m_SelectedIcon;                                               // 0x0048 (size: 0x28)
    FAsyncTextureStruct m_Icon;                                                       // 0x0070 (size: 0x28)
    FAsyncTextureStruct m_MiniIcon;                                                   // 0x0098 (size: 0x28)

}; // Size: 0xC0

struct FEquipmentPreset
{
    FEquipmentStruct m_Items;                                                         // 0x0000 (size: 0x438)
    uint8 m_IsEmpty;                                                                  // 0x0438 (size: 0x9)
    bool m_Init;                                                                      // 0x0441 (size: 0x1)

}; // Size: 0x448

struct FEquipmentShopDataRow : public FTableRowBase
{
    class UBaseItemData* m_Equipment;                                                 // 0x0008 (size: 0x8)
    int32 m_iGMLevelRequired;                                                         // 0x0010 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0014 (size: 0x4)
    bool m_bAbsolverRequired;                                                         // 0x0018 (size: 0x1)
    int32 m_iFragmentPrice;                                                           // 0x001C (size: 0x4)
    int32 m_iPrestigePointPrice;                                                      // 0x0020 (size: 0x4)
    int32 m_iMaterialIndex;                                                           // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FEquipmentStruct
{
    class ABaseWeapon* m_EquipmentActor;                                              // 0x0000 (size: 0x8)
    class UBaseItemData* m_EquipmentDataAsset;                                        // 0x0008 (size: 0x8)
    int32 m_iMaterialIndex;                                                           // 0x0010 (size: 0x4)
    ESchoolItemType m_eSchoolItemType;                                                // 0x0014 (size: 0x1)
    class UMaterialInterface* m_BaseFXMaterials;                                      // 0x0018 (size: 0x50)
    TArray<class UMaterialInterface*> m_VariationChosenMaterials;                     // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FEquipmentValues
{
    int32 m_iFragmentValue;                                                           // 0x0000 (size: 0x4)
    int32 m_iDirtValue;                                                               // 0x0004 (size: 0x4)
    int32 m_iDyeCost;                                                                 // 0x0008 (size: 0x4)
    int32 m_iRepairCost;                                                              // 0x000C (size: 0x4)

}; // Size: 0x10

struct FFXInfo
{
    class UParticleSystem* m_ParticleSystem;                                          // 0x0000 (size: 0x8)
    FVector m_vScale;                                                                 // 0x0008 (size: 0xC)

}; // Size: 0x18

struct FFallOnSlopeConfiguration
{
    float m_fWakeVelocityThreshold;                                                   // 0x0000 (size: 0x4)
    float m_fMaxDuration;                                                             // 0x0004 (size: 0x4)
    class UCurveFloat* m_ImpulseCurve;                                                // 0x0008 (size: 0x8)
    float m_fAngularDamping;                                                          // 0x0010 (size: 0x4)
    float m_fLinearDamping;                                                           // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FFallOnSlopeSetup
{
    TArray<class AActor*> m_IgnoredActors;                                            // 0x0458 (size: 0x10)

}; // Size: 0x468

struct FFidgetDBDescription
{
    class UFidgetDB* m_FidgetDB;                                                      // 0x0000 (size: 0x8)
    class UFidgetDB* m_OnAlertLevelChangedFidgetDB;                                   // 0x0008 (size: 0x8)
    uint32 m_uiAllowedSpeedState;                                                     // 0x0010 (size: 0x4)
    FBlendProfileBySpeedStateStruct m_BlendProfiles;                                  // 0x0018 (size: 0x20)

}; // Size: 0x38

struct FFightingStateElement
{
    bool m_bPause;                                                                    // 0x0000 (size: 0x1)
    float m_fStateDuration;                                                           // 0x0004 (size: 0x4)
    float m_fElapsedTime;                                                             // 0x0008 (size: 0x4)
    bool m_bInfinite;                                                                 // 0x000C (size: 0x1)
    float m_fMaxAccumulatedDamages;                                                   // 0x0010 (size: 0x4)
    float m_fAccumulatedDamages;                                                      // 0x0014 (size: 0x4)
    int32 m_iMaxAccumulatedHits;                                                      // 0x0018 (size: 0x4)
    bool m_bGroupMaxAccumulatedHitsByAttack;                                          // 0x001C (size: 0x1)
    int32 m_iAccumulatedHits;                                                         // 0x0020 (size: 0x4)
    FName m_LastAttackName;                                                           // 0x0024 (size: 0x8)
    EFightingState m_eState;                                                          // 0x002C (size: 0x1)
    ESubFightingState m_eSubFightingState;                                            // 0x002D (size: 0x1)
    TWeakObjectPtr<class UAttackPropertiesResistanceDB> m_specialResistanceDB;        // 0x0080 (size: 0x8)

}; // Size: 0x90

struct FFilterPresetCache
{
    TArray<FFilterPresetData> m_Filters;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FFilterPresetData
{
    FPostProcessSettings m_PostProcessSettings;                                       // 0x0000 (size: 0x560)
    FText m_DisplayText;                                                              // 0x0560 (size: 0x18)

}; // Size: 0x580

struct FFilterProperties
{
    bool m_bUserConfigured;                                                           // 0x0000 (size: 0x1)
    FText m_FilterText;                                                               // 0x0008 (size: 0x18)
    float m_fExposure;                                                                // 0x0020 (size: 0x4)
    float m_fVignette;                                                                // 0x0024 (size: 0x4)
    float m_fGrain;                                                                   // 0x0028 (size: 0x4)
    float m_fFilterWeight;                                                            // 0x002C (size: 0x4)
    float m_fFogDensity;                                                              // 0x0030 (size: 0x4)
    uint8 m_uiAspectRatioIndex;                                                       // 0x0034 (size: 0x1)
    uint8 m_uiLogoIndex;                                                              // 0x0035 (size: 0x1)
    EScreenLocation m_eLogoScreenLocation;                                            // 0x0036 (size: 0x1)

}; // Size: 0x38

struct FFloatStatBinding : public FBaseStatBindings
{
    float m_fValue;                                                                   // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FFocusPointsGainStruct
{
    FSCUserDefinedEnumHandler m_FocusGainEnum;                                        // 0x0000 (size: 0x50)
    float m_fGainValue;                                                               // 0x0050 (size: 0x4)

}; // Size: 0x58

struct FFrameRange
{
    FFloatRange m_Anim;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FGameOptionMappingRange
{
    FFloatRange m_Range;                                                              // 0x0000 (size: 0x10)
    float m_fDefaultValue;                                                            // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FGameOptionOverride
{
}; // Size: 0x10

struct FGameSaveData
{
    ECharacterGender m_eGender;                                                       // 0x0000 (size: 0x1)
    int32 m_iOutfitIndex;                                                             // 0x0004 (size: 0x4)
    TArray<class TSubclassOf<UGameplayEffect>> m_ShrineEffects;                       // 0x0008 (size: 0x10)
    TArray<class TSubclassOf<USkillGameplayEffect>> m_UnlockedSkills;                 // 0x0018 (size: 0x10)
    TMap<TSubclassOf<USkillGameplayEffect>, int32> m_SkillConsolidationLevel;         // 0x0028 (size: 0x50)
    TMap<ECharacterStat, float> m_DefaultStats;                                       // 0x0078 (size: 0x50)
    TMap<class FName, class FCheckPointStruct> m_CheckPointPerLevel;                  // 0x00C8 (size: 0x50)
    FGameplayTagContainer m_PlayerTags;                                               // 0x0118 (size: 0x20)
    FGameplayTagContainer m_GameplayTagContainer;                                     // 0x0138 (size: 0x20)
    float m_fMCDominationGauge;                                                       // 0x0158 (size: 0x4)
    int32 m_iLastManGauge;                                                            // 0x015C (size: 0x4)
    FName m_CurrentMapTagName;                                                        // 0x0160 (size: 0x8)
    FName m_LastStoryMapTagName;                                                      // 0x0168 (size: 0x8)
    float m_fMCHealth;                                                                // 0x0170 (size: 0x4)
    float m_fMCFocusGauge;                                                            // 0x0174 (size: 0x4)
    FGameplayTagContainer m_CurrentMapOptions;                                        // 0x0178 (size: 0x20)
    TMap<int32, FDuplicatedSaveData> m_duplicatedSaveData;                            // 0x0198 (size: 0x50)
    TMap<FName, float> m_iHighscorePerLevel;                                          // 0x01E8 (size: 0x50)
    TArray<float> m_EfficiencyQueue;                                                  // 0x0238 (size: 0x10)
    float m_fFloorScore;                                                              // 0x0248 (size: 0x4)
    bool m_bLevelScoringComplete;                                                     // 0x024C (size: 0x1)

}; // Size: 0x250

struct FGearUpdateStruct
{
    TArray<FEquipmentStruct> m_Outfits;                                               // 0x0000 (size: 0x10)
    class UBaseWeaponData* m_weaponData;                                              // 0x0010 (size: 0x8)
    ECharacterGender m_eGender;                                                       // 0x0018 (size: 0x1)
    uint8 m_uiSkinTone;                                                               // 0x0019 (size: 0x1)

}; // Size: 0x20

struct FGeneratedWallInfos
{
    class UCustomBoundingBoxComponent* m_Component;                                   // 0x0000 (size: 0x8)

}; // Size: 0x48

struct FGenericPushActorInfo
{
}; // Size: 0x7A0

struct FGuardUpdateStruct
{
    float m_fGuardGaugePercentageTargetValue;                                         // 0x0000 (size: 0x4)
    int64 m_iGuardGuageTargetTime;                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FHandPoseBlendStruct
{
    float m_fLength;                                                                  // 0x0000 (size: 0x4)
    ESCBlendType m_eBlendType;                                                        // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FHandledWeaponInfo
{
    TWeakObjectPtr<class UVisibleWeaponData> m_Data;                                  // 0x0000 (size: 0x8)
    TWeakObjectPtr<class AActor> m_WeaponOwner;                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FHardpointInfos
{
    FName m_HardpointAreaName;                                                        // 0x0000 (size: 0x8)
    TSoftObjectPtr<AArenaHardpointAreaActor> m_HardPointAreaActor;                    // 0x0008 (size: 0x28)
    TSoftObjectPtr<AAISituationActor> m_AISituationLinkedToHardpoint;                 // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FHitActionLauncherContext : public FGameplayEffectContext
{
    FHitDescription m_hitDescription;                                                 // 0x0070 (size: 0x568)

}; // Size: 0x5D8

struct FHitAnimsPerDataTable
{
    TMap<class FName, class FHitAnimsPerHitbox> m_HitAnimsPerHitboxMap;               // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FHitAnimsPerDataTableContainer
{
    TMap<class UDataTable*, class FHitAnimsPerDataTable> m_Data;                      // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FHitAnimsPerHitbox
{
    FDataTableRowHandle m_HitRow;                                                     // 0x0000 (size: 0x10)
    bool m_bUseCustomHit;                                                             // 0x0010 (size: 0x1)
    FHittedAnimContainer m_Hit;                                                       // 0x0018 (size: 0x68)
    bool m_bUseCustomGuard;                                                           // 0x0080 (size: 0x1)
    FHittedAnimContainer m_OnGuard;                                                   // 0x0088 (size: 0x68)
    bool m_bUseCustomDeath;                                                           // 0x00F0 (size: 0x1)
    FHittedAnimContainer m_OnDeath;                                                   // 0x00F8 (size: 0x68)

}; // Size: 0x160

struct FHitBox
{
    FBaseHitBoxConditionInstance m_activationCondition;                               // 0x0000 (size: 0x10)
    FHitBoxMetaDataClassInstance m_MetaData;                                          // 0x0010 (size: 0x10)
    FDataTableRowHandle m_HitRow;                                                     // 0x0020 (size: 0x10)
    FFrameRange m_FrameRange;                                                         // 0x0030 (size: 0x10)
    class UBaseHitDetectionDB* m_HitDetectionDB;                                      // 0x0040 (size: 0x8)
    EAttackTarget m_eHitTarget;                                                       // 0x0048 (size: 0x1)
    EAttackTarget m_eAltHitTarget;                                                    // 0x0049 (size: 0x1)
    EIKAnimTargetTypes m_eAimTarget;                                                  // 0x004A (size: 0x1)
    EAttackMovementType m_eMovementType;                                              // 0x004B (size: 0x1)
    EAttackOrigin m_eOrigin;                                                          // 0x004C (size: 0x1)
    EAttackOrigin m_eAvoidCustomOrigin;                                               // 0x004D (size: 0x1)
    EAttackTarget m_eAvoidCustomHitTarget;                                            // 0x004E (size: 0x1)
    EAttackMovementType m_eAvoidCustomMovementType;                                   // 0x004F (size: 0x1)
    FHitboxDataRow m_CachedRow;                                                       // 0x0050 (size: 0x240)

}; // Size: 0x298

struct FHitBoxMetaDataClassInstance
{
    TSubclassOf<class UHitBoxMetaData> m_DefaultClassObject;                          // 0x0000 (size: 0x8)
    class UHitBoxMetaData* m_Instance;                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FHitDefenseResult
{
    EOrderType m_eDefenseOrder;                                                       // 0x0000 (size: 0x1)
    uint8 m_uiOrderID;                                                                // 0x0001 (size: 0x1)
    uint8 m_uiDefenseType;                                                            // 0x0002 (size: 0x1)
    bool m_bHitDismissed;                                                             // 0x0003 (size: 0x1)
    bool m_bResultRemoved;                                                            // 0x0004 (size: 0x1)
    bool m_bIsPlayingOrder;                                                           // 0x0005 (size: 0x1)
    class USpecialAbilityPropertyDB* m_DB;                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FHitDescription
{
    FHitRequest m_Request;                                                            // 0x0000 (size: 0x418)
    FHitResult m_Result;                                                              // 0x0418 (size: 0x8C)
    FImpactResult m_ImpactResult;                                                     // 0x04A8 (size: 0xC0)

}; // Size: 0x568

struct FHitImpact
{
    bool m_bUseDamage;                                                                // 0x0009 (size: 0x1)
    float m_fDamage;                                                                  // 0x000C (size: 0x4)
    bool m_bUseStructureDamage;                                                       // 0x0010 (size: 0x1)
    float m_fStructureDamage;                                                         // 0x0014 (size: 0x4)
    bool m_bUseSuperDizzyDamage;                                                      // 0x0018 (size: 0x1)
    float m_fSuperDizzyDamage;                                                        // 0x001C (size: 0x4)
    bool m_bUseNbFrameStuned;                                                         // 0x0020 (size: 0x1)
    uint8 m_iNbFrameStuned;                                                           // 0x0021 (size: 0x1)
    bool m_bUseKnockBackDistance;                                                     // 0x0022 (size: 0x1)
    float m_fKnockBackDistance;                                                       // 0x0024 (size: 0x4)
    bool m_bUseFreezeFrames;                                                          // 0x0028 (size: 0x1)
    int32 m_iFreezeFrames;                                                            // 0x002C (size: 0x4)

}; // Size: 0x30

struct FHitRequest
{
    FAttackRequest m_AttackRequest;                                                   // 0x0010 (size: 0x48)
    FHitResult m_EnvironmentImpact;                                                   // 0x0058 (size: 0x8C)
    TWeakObjectPtr<class AActor> m_Instigator;                                        // 0x00E4 (size: 0x8)
    TWeakObjectPtr<class AActor> m_InstigatorItem;                                    // 0x00EC (size: 0x8)
    FVector m_InstigatorDirection;                                                    // 0x00F4 (size: 0xC)
    EInstigatorType m_eInstigatorType;                                                // 0x0100 (size: 0x1)
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0104 (size: 0x8)
    FHitBox m_HitBox;                                                                 // 0x0110 (size: 0x298)
    ELimbs m_eAttackerLimb;                                                           // 0x03A8 (size: 0x1)
    uint8 m_uiDamageID;                                                               // 0x03C8 (size: 0x1)
    uint8 m_uiAttackOrderID;                                                          // 0x03C9 (size: 0x1)
    FVector m_vDamageDir;                                                             // 0x03CC (size: 0xC)
    bool m_bCastBoundariesRelativeToInstigator;                                       // 0x03D8 (size: 0x1)
    TWeakObjectPtr<class AUsableItem> m_UsableItemIntermediate;                       // 0x03DC (size: 0x8)
    bool m_bMirror;                                                                   // 0x03E4 (size: 0x1)
    FGameplayTagContainer m_AttackProperties;                                         // 0x03E8 (size: 0x20)
    uint8 m_uiHitBoxID;                                                               // 0x0408 (size: 0x1)
    bool m_bCanBeDefended;                                                            // 0x0409 (size: 0x1)

}; // Size: 0x418

struct FHitRequestAdditionalInfo
{
}; // Size: 0x8

struct FHitboxDataRow : public FTableRowBase
{
    int32 m_iHitboxGroupID;                                                           // 0x0008 (size: 0x4)
    float m_fMaxImpactAngle;                                                          // 0x000C (size: 0x4)
    bool m_bIgnoreImpactAngleWhenPenetrating;                                         // 0x0010 (size: 0x1)
    int32 m_uiTargetFilters;                                                          // 0x0014 (size: 0x4)
    FGameplayTagContainer m_HitboxGameplayTags;                                       // 0x0018 (size: 0x20)
    bool m_bOnlyHitCharacterWithRequiredHitboxGameplayTags;                           // 0x0038 (size: 0x1)
    FGameplayTagContainer m_AdditionalHitboxGameplayTagsOnTarget;                     // 0x0040 (size: 0x20)
    FGameplayTagContainer m_RequiredGameplayTags;                                     // 0x0060 (size: 0x20)
    bool m_bHitTargetOnly;                                                            // 0x0080 (size: 0x1)
    bool m_bIgnoreTarget;                                                             // 0x0081 (size: 0x1)
    bool m_bHitAnyCharacterOnAvoid;                                                   // 0x0082 (size: 0x1)
    bool m_bCanTouchMultipleTargetAtOnce;                                             // 0x0083 (size: 0x1)
    bool m_bCanBeLethal;                                                              // 0x0084 (size: 0x1)
    bool m_bCanBreakStructure;                                                        // 0x0085 (size: 0x1)
    FHitImpact m_OnHitImpact;                                                         // 0x0088 (size: 0x30)
    class UCurveFloat* m_KnockBackDynamicOnHit;                                       // 0x00B8 (size: 0x8)
    FHitImpact m_OnGuardImpact;                                                       // 0x00C0 (size: 0x30)
    class UCurveFloat* m_KnockBackDynamicOnGuard;                                     // 0x00F0 (size: 0x8)
    FDeflectImpact m_OnDeflectImpact;                                                 // 0x00F8 (size: 0x48)
    EHittedReaction m_eHittedReaction;                                                // 0x0140 (size: 0x1)
    TSubclassOf<class UHitActionLauncher> m_hitAction;                                // 0x0148 (size: 0x8)
    bool m_bNotifyHittedOnHitAction;                                                  // 0x0150 (size: 0x1)
    bool m_bApplyFreezeFramesOnHitAction;                                             // 0x0151 (size: 0x1)
    bool m_bPlayRumbleOnHitAction;                                                    // 0x0152 (size: 0x1)
    bool m_bPlayRumbleOnNormalHit;                                                    // 0x0153 (size: 0x1)
    EHitType m_eHitType;                                                              // 0x0154 (size: 0x1)
    FSCUserDefinedEnumHandler m_HitContext;                                           // 0x0158 (size: 0x50)
    EAttackPowers m_eAttackPower;                                                     // 0x01A8 (size: 0x1)
    bool m_bOverrideResilience;                                                       // 0x01A9 (size: 0x1)
    int32 m_iOverrideResilienceValue;                                                 // 0x01AC (size: 0x4)
    bool m_bDizzyOnAvoid;                                                             // 0x01B0 (size: 0x1)
    bool m_bDizzyOnParry;                                                             // 0x01B1 (size: 0x1)
    bool m_bParriable;                                                                // 0x01B2 (size: 0x1)
    bool m_bPlayAvoidedOrder;                                                         // 0x01B3 (size: 0x1)
    FAttackPropertyLevel m_AttackPropertyLevel;                                       // 0x01B4 (size: 0x24)
    TMap<class EFightingState, class FAttackPropertyLevel> m_AttackPropertyLevelOverrides; // 0x01D8 (size: 0x50)
    float m_fMinKnockbackAngleFromHit;                                                // 0x0228 (size: 0x4)
    EKnockbackBehavior m_eKnockBackBehavior;                                          // 0x022C (size: 0x1)
    float m_fKnockbackEastWestAngle;                                                  // 0x0230 (size: 0x4)
    int32 m_iHitboxDefenseMatrix;                                                     // 0x0234 (size: 0x4)
    int32 m_iAvoidableDefenseMatrix;                                                  // 0x0238 (size: 0x4)

}; // Size: 0x240

struct FHittedAnimCardinalOnlyArray
{
    FAnimContainer m_Array;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FHittedAnimContainer : public FAnimContainer
{
    bool m_bLockAttacker;                                                             // 0x0018 (size: 0x1)
    EKnockbackReorientationBehaviour m_eReorientationBehaviour;                       // 0x0019 (size: 0x1)
    bool m_bInterruptible;                                                            // 0x001A (size: 0x1)
    bool m_bInterruptAnimationOnEnd;                                                  // 0x001B (size: 0x1)
    bool m_bScaleAnimationToHitDuration;                                              // 0x001C (size: 0x1)
    bool m_bInvertReorientationFromBehind;                                            // 0x001D (size: 0x1)
    ESCCardinalPoints m_eOrientationOffset;                                           // 0x001E (size: 0x1)
    bool m_bUseRootMotion;                                                            // 0x001F (size: 0x1)
    bool m_bIgnoreHitKnockbackDistance;                                               // 0x0020 (size: 0x1)
    FAnimContainer m_FightingStateLoopAnim;                                           // 0x0028 (size: 0x18)
    TArray<FHittedOrderServiceInfos> m_OrderServices;                                 // 0x0040 (size: 0x10)
    bool m_bOverrideHitDuration;                                                      // 0x005C (size: 0x1)
    float m_fOverrideHitDuration;                                                     // 0x0060 (size: 0x4)

}; // Size: 0x68

struct FHittedOrderServiceInfos
{
    float m_fStartDelayFrames;                                                        // 0x0000 (size: 0x4)
    bool m_bUseCustomEnabledDuration;                                                 // 0x0004 (size: 0x1)
    float m_fEnabledFrames;                                                           // 0x0008 (size: 0x4)
    TSubclassOf<class UOrderService> m_OrderService;                                  // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FHittedServiceInfos
{
    bool m_bDiscardHitOrderOnSurvive;                                                 // 0x0000 (size: 0x1)
    bool m_bDiscardHitOrderOnKill;                                                    // 0x0001 (size: 0x1)
    bool m_bDropWeaponOnKill;                                                         // 0x0002 (size: 0x1)
    bool m_bDiscardFightingStatesOrders;                                              // 0x0003 (size: 0x1)
    bool m_bEnqueueFightingStateOrder;                                                // 0x0004 (size: 0x1)
    class UAnimSequence* m_DeathAnimationOnStop;                                      // 0x0008 (size: 0x8)
    bool m_bMirrorDeathAnimation;                                                     // 0x0010 (size: 0x1)
    bool m_bGenerateImpactOnStop;                                                     // 0x0011 (size: 0x1)
    bool m_bUseCustomHitAnimOnKill;                                                   // 0x0012 (size: 0x1)
    FHittedAnimContainer m_CustomHitAnimOnKill;                                       // 0x0018 (size: 0x68)
    bool m_bUseCustomHitAnimOnSurvive;                                                // 0x0080 (size: 0x1)
    FHittedAnimContainer m_CustomHitAnimOnSurvive;                                    // 0x0088 (size: 0x68)
    bool m_bForceDamageToHitBox;                                                      // 0x00F0 (size: 0x1)
    bool m_bForceStructureDamageToHitBox;                                             // 0x00F1 (size: 0x1)
    bool m_bLaunchFightingStateOrderAfterCurrentAnim;                                 // 0x00F2 (size: 0x1)
    bool m_bStructureBrokenOrderWaitForEndOfAnim;                                     // 0x00F3 (size: 0x1)
    bool m_bDelayKillToNextHit;                                                       // 0x00F4 (size: 0x1)
    bool m_bUseCustomFightingStateLoopAnim;                                           // 0x00F5 (size: 0x1)
    FHittedAnimContainer m_CustomFightingStateLoopAnim;                               // 0x00F8 (size: 0x68)
    bool m_bUseCustomFightingStateRecoveryAnim;                                       // 0x0160 (size: 0x1)
    FHittedAnimContainer m_CustomFightingStateRecoveryAnim;                           // 0x0168 (size: 0x68)
    FBoneReference m_OptionalImpactBone;                                              // 0x01D0 (size: 0x10)
    bool m_bPlayHitSFX;                                                               // 0x01E0 (size: 0x1)
    bool m_bPlayDeathSFX;                                                             // 0x01E1 (size: 0x1)
    bool m_bPlayHitVFX;                                                               // 0x01E2 (size: 0x1)

}; // Size: 0x1E8

struct FIKProfileBlendInfos
{
    float m_fValueCoef;                                                               // 0x0000 (size: 0x4)
    float m_fBlendInDuration;                                                         // 0x0004 (size: 0x4)
    TEnumAsByte<EEasingFunc::Type> m_eBlendInFunction;                                // 0x0008 (size: 0x1)
    float m_fBlendOutDuration;                                                        // 0x000C (size: 0x4)
    TEnumAsByte<EEasingFunc::Type> m_eBlendOutFunction;                               // 0x0010 (size: 0x1)
    FName m_CurveName;                                                                // 0x0014 (size: 0x8)

}; // Size: 0x1C

struct FIKPropertyEvaluation
{
    FSCUserDefinedEnumHandler m_Mirror;                                               // 0x0000 (size: 0x50)
    FBoneReference m_RootLimbBone;                                                    // 0x0050 (size: 0x10)
    FBoneReference m_TipBone;                                                         // 0x0060 (size: 0x10)
    float m_fBoneLocationAlpha;                                                       // 0x0070 (size: 0x4)
    float m_fBoneRotationAlpha;                                                       // 0x0074 (size: 0x4)
    float m_fLimbRotationAlpha;                                                       // 0x0078 (size: 0x4)
    FVector m_vSelfReferenceBonePosition;                                             // 0x007C (size: 0xC)
    FVector m_vTargetBonePosition;                                                    // 0x0088 (size: 0xC)
    FRotator m_TargetBoneRotation;                                                    // 0x0094 (size: 0xC)
    FTransform m_TipBoneWantedTransform;                                              // 0x00A0 (size: 0x30)
    FRotator m_LimbLocalRotation;                                                     // 0x00D0 (size: 0xC)

}; // Size: 0xE0

struct FIconTextures
{
    class UTexture2D* m_Textures;                                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FIdleAnimAndTransition
{
    FAnimContainer m_IdleAnimation;                                                   // 0x0000 (size: 0x18)
    FAnimContainer m_IdleExitTransition;                                              // 0x0018 (size: 0x60)

}; // Size: 0x78

struct FIdleAnimPerSex
{
    FAnimContainer m_AnimsPerSex;                                                     // 0x0000 (size: 0x30)

}; // Size: 0x30

struct FImpactResult
{
    bool m_bIsValid;                                                                  // 0x0000 (size: 0x1)
    float m_fDamage;                                                                  // 0x0004 (size: 0x4)
    bool m_bGuardBreak;                                                               // 0x0008 (size: 0x1)
    bool m_bSuperDizzyAlreadyAvailable;                                               // 0x0009 (size: 0x1)
    bool m_bSuperDizzyAvailable;                                                      // 0x000A (size: 0x1)
    class AActor* m_Victim;                                                           // 0x0010 (size: 0x8)
    ESCCardinalPoints m_eImpactCardinalPoint;                                         // 0x0018 (size: 0x1)
    ESCCardinalPoints m_eImpactCardinalPointInVictimSpace;                            // 0x0019 (size: 0x1)
    bool m_bAlreadyGuardBroken;                                                       // 0x001A (size: 0x1)
    bool m_bCriticalHit;                                                              // 0x001B (size: 0x1)
    EHeight m_eHeight;                                                                // 0x001C (size: 0x1)
    EImpactType m_eImpactType;                                                        // 0x001D (size: 0x1)
    EGuardType m_eGuardType;                                                          // 0x001E (size: 0x1)
    FAppliedHitImpact m_HitImpact;                                                    // 0x0020 (size: 0x18)
    FAppliedDeflectImpact m_DeflectImpact;                                            // 0x0038 (size: 0x28)
    float m_fInstigatorStructureBeforeImpact;                                         // 0x0060 (size: 0x4)
    float m_fHitAnimationTimeElapsedDuringFreeze;                                     // 0x0064 (size: 0x4)
    bool m_bLethal;                                                                   // 0x0068 (size: 0x1)
    FVector m_vKnockbackPosition;                                                     // 0x006C (size: 0xC)
    EQuadrantTypes m_eTowardInstigatorQuadrant;                                       // 0x0078 (size: 0x1)
    EQuadrantTypes m_eDefenderQuadrant;                                               // 0x0079 (size: 0x1)
    bool bPushedBlockForce;                                                           // 0x007A (size: 0x1)
    FVector m_vImpactLocation;                                                        // 0x007C (size: 0xC)
    FVector m_vImpactDir;                                                             // 0x0088 (size: 0xC)
    float m_fInstigatorFreezeDuration;                                                // 0x0094 (size: 0x4)
    float m_fStunTime;                                                                // 0x0098 (size: 0x4)
    bool m_bResilienceImpact;                                                         // 0x00A8 (size: 0x1)
    FBoneReference m_OptionalImpactBone;                                              // 0x00AC (size: 0x10)
    bool m_bPlaySFX;                                                                  // 0x00BC (size: 0x1)
    bool m_bPlayDeathSFX;                                                             // 0x00BD (size: 0x1)
    bool m_bPlayVFX;                                                                  // 0x00BE (size: 0x1)
    bool m_bAvoidDizzy;                                                               // 0x00BF (size: 0x1)

}; // Size: 0xC0

struct FInFightPlayersInfo
{
    TWeakObjectPtr<class AActor> m_EnemyActor;                                        // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FInGameSequenceReplicationInfo
{
    class ULevelSequence* m_LevelSequenceToReplay;                                    // 0x0000 (size: 0x8)
    FMovieSceneSequencePlaybackParams m_playbackParams;                               // 0x0008 (size: 0x28)
    ESequenceState m_eSequenceState;                                                  // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FInheritedBoolStruct : public FInheritedStruct
{
    bool m_bParentBool;                                                               // 0x0010 (size: 0x1)
    bool m_bFinalBool;                                                                // 0x0011 (size: 0x1)
    EInheritanceChoice m_eInheritanceChoice;                                          // 0x0012 (size: 0x1)

}; // Size: 0x18

struct FInheritedCurveFloatStruct : public FInheritedStruct
{
    class UCurveFloat* m_parentCurveFloat;                                            // 0x0010 (size: 0x8)
    class UCurveFloat* m_finalCurveFloat;                                             // 0x0018 (size: 0x8)
    EInheritanceChoice m_eInheritanceChoice;                                          // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FInheritedFloatStruct : public FInheritedStruct
{
    float m_fParentValue;                                                             // 0x0010 (size: 0x4)
    float m_fFinalValue;                                                              // 0x0014 (size: 0x4)
    float m_fFactorValue;                                                             // 0x0018 (size: 0x4)
    float m_fOffsetValue;                                                             // 0x001C (size: 0x4)

}; // Size: 0x20

struct FInheritedStruct
{
    bool m_bOverrideParentValue;                                                      // 0x0008 (size: 0x1)
    bool m_bIsEditable;                                                               // 0x0009 (size: 0x1)

}; // Size: 0x10

struct FInheritedVec3Struct
{
    FInheritedFloatStruct m_X;                                                        // 0x0000 (size: 0x20)
    FInheritedFloatStruct m_Y;                                                        // 0x0020 (size: 0x20)
    FInheritedFloatStruct m_Z;                                                        // 0x0040 (size: 0x20)

}; // Size: 0x60

struct FInputActionData
{
    float m_fStackLifeSpan;                                                           // 0x0000 (size: 0x4)
    bool m_bUseScaledTime;                                                            // 0x0004 (size: 0x1)
    bool m_bBlockLowerContext;                                                        // 0x0005 (size: 0x1)

}; // Size: 0x8

struct FInputBehaviourStruct
{
    InputBehavior m_Behavior;                                                         // 0x0000 (size: 0x1)
    float m_fTimePressed;                                                             // 0x0004 (size: 0x4)
    bool m_bAutoReset;                                                                // 0x0008 (size: 0x1)
    bool m_bRegisterPressTimeOnStack;                                                 // 0x0009 (size: 0x1)
    bool m_bRemovePressedTimeFromTimeLeft;                                            // 0x000A (size: 0x1)

}; // Size: 0xC

struct FInputDataTutorialStruct
{
    FText m_PrefixText;                                                               // 0x0000 (size: 0x18)
    InputAction m_eInputAction;                                                       // 0x0018 (size: 0x1)
    class UGenericInputData* m_InputDataPad;                                          // 0x0020 (size: 0x8)
    class UGenericInputData* m_InputDataMouse;                                        // 0x0028 (size: 0x8)
    EControllerIconAxisTypes m_eAxisType;                                             // 0x0030 (size: 0x1)
    FText m_SuffixText;                                                               // 0x0038 (size: 0x18)
    EInputDataTutorialDisplayConstraints m_InputDataTutorialDisplayConstraint;        // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FInputDetection
{
    InputAction m_eInput;                                                             // 0x0000 (size: 0x1)
    bool m_bValidateOnEnterStack;                                                     // 0x0001 (size: 0x1)
    int32 m_iEnterStackValidation;                                                    // 0x0004 (size: 0x4)
    bool m_bValidateOnExitStack;                                                      // 0x0008 (size: 0x1)
    FBaseActorConditionInstance m_BaseCondition;                                      // 0x0010 (size: 0x10)
    class UTargetActionTypeRequest* m_TargetActionTypeRequest;                        // 0x0020 (size: 0x8)
    EActionType m_eTarget;                                                            // 0x0028 (size: 0x1)
    bool m_bIgnoreTargetOnPriorityResolution;                                         // 0x0029 (size: 0x1)
    int32 m_iNoTargetPriority;                                                        // 0x002C (size: 0x4)
    bool m_bRequiresTarget;                                                           // 0x0030 (size: 0x1)
    bool m_bRequiresTargetOnStack;                                                    // 0x0031 (size: 0x1)
    FBaseActorConditionInstance m_bRequiresTargetCondition;                           // 0x0038 (size: 0x10)
    bool m_bUpdateTargetOnExitStack;                                                  // 0x0048 (size: 0x1)
    EUpdateTargetCondition m_eUpdateTargetOnExitStackCondition;                       // 0x0049 (size: 0x1)
    bool m_bResetInputOnDismiss;                                                      // 0x004A (size: 0x1)
    bool m_bResetInputOnActivation;                                                   // 0x004B (size: 0x1)
    bool m_bResetHoldToggleInputOnAbilityEnd;                                         // 0x004C (size: 0x1)

}; // Size: 0x50

struct FInputHandleContainer
{
    FInputHandleContainer_Delegate m_Delegate;                                        // 0x0000 (size: 0x10)
    bool BPInputHandleSignature();
    InputAction m_eAction;                                                            // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FInputKeyMappingHandler
{
    FKey m_Key;                                                                       // 0x0000 (size: 0x18)
    FName m_ActionName;                                                               // 0x0018 (size: 0x8)
    FName m_AxisName;                                                                 // 0x0020 (size: 0x8)
    bool m_bShift;                                                                    // 0x0028 (size: 0x1)
    bool m_bAlt;                                                                      // 0x0029 (size: 0x1)
    bool m_bCmd;                                                                      // 0x002A (size: 0x1)
    bool m_bCtrl;                                                                     // 0x002B (size: 0x1)
    float m_fScale;                                                                   // 0x002C (size: 0x4)

}; // Size: 0x30

struct FInputMapping
{
    FInputMappingData m_MappingData;                                                  // 0x0000 (size: 0x68)

}; // Size: 0x68

struct FInputMappingCompatibilityRule
{
    EInputMappingCompatibilityRuleType m_eRule;                                       // 0x0000 (size: 0x4)
    TArray<TSoftObjectPtr<UGenericInputData>> m_Classes;                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FInputMappingData
{
    FInputPresetsEnumHandler m_PresetID;                                              // 0x0000 (size: 0x50)
    class UGenericInputData* m_InputData;                                             // 0x0050 (size: 0x8)
    TArray<FInputMappingKeySlotContainer> m_Slots;                                    // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FInputMappingGroup
{
    TMap<class InputAction, class FInputMapping> m_Mapping;                           // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FInputMappingKeySlot
{
    EVirtualAction m_eVirtualAction;                                                  // 0x0000 (size: 0x4)
    TArray<FInputActionKeyMapping> m_Actions;                                         // 0x0008 (size: 0x10)
    TArray<FInputAxisKeyMapping> m_Axis;                                              // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FInputMappingKeySlotContainer
{
    FInputPresetsEnumHandler m_PresetID;                                              // 0x0000 (size: 0x50)
    class UGenericInputData* m_SubInputData;                                          // 0x0050 (size: 0x8)
    FInputMappingKeySlot m_Key;                                                       // 0x0058 (size: 0x28)
    FSaveGameInputMappingKeySlot m_SaveGameKey;                                       // 0x0080 (size: 0x28)

}; // Size: 0xA8

struct FInputMappingNode
{
    class UGenericInputData* m_InputData;                                             // 0x0000 (size: 0x8)
    FInputPresetsEnumHandler m_Preset;                                                // 0x0008 (size: 0x50)
    FInputMappingKeySlot m_KeySlot;                                                   // 0x0058 (size: 0x28)

}; // Size: 0x90

struct FInputMappingProfileData
{
    bool m_IsSet;                                                                     // 0x0000 (size: 0x1)
    TMap<class FInputPresetsEnumHandler, class FInputMappingData> m_Presets;          // 0x0008 (size: 0x50)
    TMap<class InputContext, class FInputMappingGroup> m_MappingPerContext;           // 0x0058 (size: 0x50)

}; // Size: 0xA8

struct FInputMappingProfileEnumHandler : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FInputMappingTree
{
    TMap<class InputAction, class FInputMappingNode> m_NodePerAction;                 // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FInputPresetsEnumHandler : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FInputPriorityGroup
{
    TSet<TSoftObjectPtr<UGenericInputData>> m_Data;                                   // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FInputSequenceStep
{
    class UGenericInputData* m_Input;                                                 // 0x0000 (size: 0x8)
    FFloatRange m_DelayBeforeNextAction;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FInputTutorialStruct
{
    TArray<FInputDataTutorialStruct> m_InputSequence;                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FIntStatBinding : public FBaseStatBindings
{
    int32 m_iValue;                                                                   // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FInteractionHintInfo
{
    bool m_bIsVisible;                                                                // 0x0000 (size: 0x1)
    bool m_bIsUsable;                                                                 // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FInteractionTextStruct
{
    FText m_FirstText;                                                                // 0x0000 (size: 0x18)
    InputAction m_eInputAction;                                                       // 0x0018 (size: 0x1)
    FText m_SecondText;                                                               // 0x0020 (size: 0x18)

}; // Size: 0x38

struct FInterchangeableData
{
    FBaseActorConditionInstance m_condition;                                          // 0x0000 (size: 0x10)
    class UGenericInputData* m_Data;                                                  // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FIntroShopDataRow : public FTableRowBase
{
    FName m_RowName;                                                                  // 0x0008 (size: 0x8)
    int32 m_iGMLevelRequired;                                                         // 0x0010 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0014 (size: 0x4)
    int32 m_iFragmentPrice;                                                           // 0x0018 (size: 0x4)
    int32 m_iPrestigePointPrice;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FInventoryItem
{
    FEquipmentStruct m_Item;                                                          // 0x0000 (size: 0x78)
    int32 m_iItemCount;                                                               // 0x0078 (size: 0x4)
    bool m_bIsEquipped;                                                               // 0x007C (size: 0x1)
    int8 m_iEquippedItemSlot;                                                         // 0x007D (size: 0x1)
    float m_fDurability;                                                              // 0x0084 (size: 0x4)
    bool m_bBroken;                                                                   // 0x0089 (size: 0x1)
    bool m_bIsNew;                                                                    // 0x008A (size: 0x1)

}; // Size: 0x90

struct FInventoryItemArray
{
    TArray<FInventoryItem> m_ItemList;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FInventorySearchFilter
{
    EEquipmentSlot m_eSlot;                                                           // 0x0000 (size: 0x1)
    bool m_bOutfitsOnly;                                                              // 0x0001 (size: 0x1)
    bool m_bOnlyNewItems;                                                             // 0x0002 (size: 0x1)
    bool m_bIgnoreMentoringItems;                                                     // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FItemEffects
{
    EEffectTarget m_eEffectTarget;                                                    // 0x0000 (size: 0x1)
    class UEffectData* m_EffectData;                                                  // 0x0008 (size: 0x8)
    int32 m_iAOEWantedRelations;                                                      // 0x0010 (size: 0x4)

}; // Size: 0x28

struct FJiggleAnimContainer
{
    FCardinalAnimContainer m_JiggleAnimations;                                        // 0x0000 (size: 0x60)
    bool m_bAllowWeapons;                                                             // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FLockMoveAnimQuadrant
{
    FAnimContainer m_LockMoveAnimContainer;                                           // 0x0000 (size: 0x60)
    FBlendSpaceDirectionContainer m_LockMoveBlendSpace;                               // 0x0060 (size: 0x20)
    FBlendSpaceDirectionContainer m_LockMoveUpperBodyBlendSpace;                      // 0x0080 (size: 0x20)

}; // Size: 0xA0

struct FLocomotionPaceSelector
{
    FSpeedStateFromGoalDistSelector m_speedStateFromGoalDistSelectors;                // 0x0000 (size: 0x24)

}; // Size: 0x24

struct FLocomotionRotationParams
{
    ELocomotionRotationType m_eRotationType;                                          // 0x0000 (size: 0x1)
    float m_fSnapDuration;                                                            // 0x0004 (size: 0x4)
    float m_fLerpFactor;                                                              // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FLocomotionTransitionsAnimContainer
{
    FCombatSpeedTransitionsAnimContainer m_V1;                                        // 0x0000 (size: 0x8A0)
    FSpeedTransitionsAnimContainer m_V2;                                              // 0x08A0 (size: 0x2D0)
    FSpeedTransitionsAnimContainer m_V3;                                              // 0x0B70 (size: 0x2D0)
    FOrientedRotationAnimContainer m_TurnInPlace;                                     // 0x0E40 (size: 0x120)

}; // Size: 0xF60

struct FLocomotionTransitionsResultCache
{
    bool m_bToV0;                                                                     // 0x0000 (size: 0x1)
    bool m_bToV1;                                                                     // 0x0001 (size: 0x1)
    bool m_bToV2;                                                                     // 0x0002 (size: 0x1)
    bool m_bTransitionToV0;                                                           // 0x0003 (size: 0x1)
    bool m_bTransitionToV1;                                                           // 0x0004 (size: 0x1)
    bool m_bTransitionToV1_MoveStatusCombat;                                          // 0x0005 (size: 0x1)
    bool m_bTransitionToV1_AIHack;                                                    // 0x0006 (size: 0x1)
    bool m_bTransitionToV2;                                                           // 0x0007 (size: 0x1)
    bool m_bTransitionToV3;                                                           // 0x0008 (size: 0x1)
    bool m_bIsInTransition;                                                           // 0x0009 (size: 0x1)

}; // Size: 0xA

struct FLookAtAnimHandler
{
    FAimOffsetStruct m_aimOffset0;                                                    // 0x0000 (size: 0x18)
    FAimOffsetStruct m_aimOffset1;                                                    // 0x0018 (size: 0x18)
    int32 m_iAimOffsetIndex;                                                          // 0x0030 (size: 0x4)
    bool m_bLookAtEnabled;                                                            // 0x0034 (size: 0x1)
    FVector2D m_vRawBlendSpaceParams;                                                 // 0x0038 (size: 0x8)
    FVector2D m_vBlendSpaceParams;                                                    // 0x0040 (size: 0x8)
    FVector2D m_vEyeBlendSpaceParams;                                                 // 0x0048 (size: 0x8)
    FRotator m_BoneModifierRot;                                                       // 0x0050 (size: 0xC)
    FRotator m_CompensationRot;                                                       // 0x005C (size: 0xC)
    bool m_bIsTargetLocationValid;                                                    // 0x0068 (size: 0x1)
    FVector m_vTargetLocation;                                                        // 0x006C (size: 0xC)
    bool m_bEnableAnimationCompensation;                                              // 0x0078 (size: 0x1)
    float m_fMaxHeadDiffYaw;                                                          // 0x007C (size: 0x4)
    float m_fMaxHeadDiffPitch;                                                        // 0x0080 (size: 0x4)
    FName m_headInWorldSpaceSaveBoneName;                                             // 0x0084 (size: 0x8)
    FName m_headComparaisonInWorldSpaceSaveBoneName;                                  // 0x008C (size: 0x8)
    FName m_headInWorldSpacePostLookAtSaveBoneName;                                   // 0x0094 (size: 0x8)
    bool m_bEyesLookAtSpecificBone;                                                   // 0x009C (size: 0x1)
    FName m_EyesLookAtSpecificBoneName;                                               // 0x00A0 (size: 0x8)
    ELookAtApplyMode m_eApplyMode;                                                    // 0x00A8 (size: 0x1)
    ELookAtRefDirMode m_eRefDirMode;                                                  // 0x00A9 (size: 0x1)
    float m_fAngleThreshold;                                                          // 0x00C8 (size: 0x4)
    float m_fMaxFrontAngle;                                                           // 0x00CC (size: 0x4)
    bool m_bLookInCameraDir;                                                          // 0x00D0 (size: 0x1)
    TSubclassOf<class ULookAtAnimRequest2> m_animRequest;                             // 0x00D8 (size: 0x8)
    FLookAtConfig m_lookAtConfigs;                                                    // 0x00E0 (size: 0x78)
    TArray<ELookAtTargetType> m_targetPriorities;                                     // 0x0158 (size: 0x10)
    FLookAtModifierParams m_defaultModifierParams;                                    // 0x0168 (size: 0x14)
    FLookAtLimits m_boneModifierLimits;                                               // 0x0180 (size: 0x90)
    bool m_bInverseValuesOnBoneModifier;                                              // 0x0210 (size: 0x1)
    FVector2D m_vBoneModifierOffset;                                                  // 0x0214 (size: 0x8)
    FVector2D m_vBoneModifierMultiplier;                                              // 0x021C (size: 0x8)
    FLookAtLimits m_defaultLimits;                                                    // 0x0228 (size: 0x90)
    TArray<FLookAtLocomotionLimits> m_locomotionLimits;                               // 0x02B8 (size: 0x10)
    TMap<class ETransitionGlobalType, class FLookAtLimits> m_transitionLimits;        // 0x02C8 (size: 0x50)
    FLookAtModifierParams m_friendlyModifierParams;                                   // 0x0318 (size: 0x14)
    FLookAtModifierParams m_hostileInIdleModifierParams;                              // 0x032C (size: 0x14)
    uint32 m_uiFirstLocalPlayerAIBehavior;                                            // 0x0340 (size: 0x4)
    float m_fMaxDistFromFirstLocalPlayer;                                             // 0x0344 (size: 0x4)

}; // Size: 0x488

struct FLookAtConfig
{
    bool m_bCanHaveInteractionComponent;                                              // 0x0000 (size: 0x1)
    class ULookAtConfigData* m_configData;                                            // 0x0008 (size: 0x8)
    float m_fValidDuration;                                                           // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FLookAtLimits
{
    bool m_bEnabled;                                                                  // 0x0000 (size: 0x1)
    float m_fYawLimit;                                                                // 0x0004 (size: 0x4)
    FRuntimeFloatCurve m_pitchLimitByYaw;                                             // 0x0008 (size: 0x88)

}; // Size: 0x90

struct FLookAtLocomotionLimits
{
    ESpeedState m_eSpeedState;                                                        // 0x0000 (size: 0x1)
    EMoveStatus m_eMoveStatus;                                                        // 0x0001 (size: 0x1)
    FLookAtLimits m_limits;                                                           // 0x0008 (size: 0x90)

}; // Size: 0x98

struct FLookAtModifierParams
{
    bool m_bOverrideSpringSpeed;                                                      // 0x0000 (size: 0x1)
    float m_fOverridenSpringSpeed;                                                    // 0x0004 (size: 0x4)
    float m_fRotationMultiplier;                                                      // 0x0008 (size: 0x4)
    float m_fMaxClampedYaw;                                                           // 0x000C (size: 0x4)
    float m_fMaxClampedPitch;                                                         // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FLootBaseItemStruct
{
    class UBaseItemData* m_Item;                                                      // 0x0000 (size: 0x8)
    uint16 m_uiItemNumber;                                                            // 0x0008 (size: 0x2)
    uint8 m_uiMaterialIndex;                                                          // 0x000A (size: 0x1)

}; // Size: 0x10

struct FLootBoxDataRow : public FTableRowBase
{
    class UBaseItemData* m_Item;                                                      // 0x0008 (size: 0x8)
    TArray<int32> m_Materials;                                                        // 0x0010 (size: 0x10)
    int32 m_iGMLevelRequired;                                                         // 0x0020 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0024 (size: 0x4)
    int32 m_iWeight;                                                                  // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FLootBoxInstancedData
{
    int32 m_iGMLevel;                                                                 // 0x0000 (size: 0x4)
    ELootBoxType m_Type;                                                              // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FLootBoxRewardStruct
{
    TArray<FLootBoxTypeCountStruct> m_LootBoxes;                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FLootBoxStaticData
{
    FName m_Name;                                                                     // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FLootBoxTypeCountStruct
{
    ELootBoxType m_Type;                                                              // 0x0000 (size: 0x1)
    int32 m_iCount;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FMainAttackComboDB
{
    TArray<FName> m_ComboQuadrantsFrontLeftXls;                                       // 0x0000 (size: 0x10)
    TArray<FName> m_ComboQuadrantsFrontRightXls;                                      // 0x0010 (size: 0x10)
    TArray<FName> m_ComboQuadrantsBackRightXls;                                       // 0x0020 (size: 0x10)
    TArray<FName> m_ComboQuadrantsBackLeftXls;                                        // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FMainAttackComboRealNamesDB
{
    TArray<FText> m_ComboQuadrantsFrontLeftXls;                                       // 0x0000 (size: 0x10)
    TArray<FText> m_ComboQuadrantsFrontRightXls;                                      // 0x0010 (size: 0x10)
    TArray<FText> m_ComboQuadrantsBackRightXls;                                       // 0x0020 (size: 0x10)
    TArray<FText> m_ComboQuadrantsBackLeftXls;                                        // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FMainCharWeaponOverrideInfo : public FBaseWeaponOverrideInfo
{
    class UCombo* m_MainCharCombo;                                                    // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FMappableInputStruct
{
    FName m_UnrealMappingName;                                                        // 0x0000 (size: 0x8)
    ERemappingAllowedInputTypes m_eRemappingAllowedInputType;                         // 0x0008 (size: 0x1)
    FText m_DisplayedMappingNameText;                                                 // 0x0010 (size: 0x30)
    bool m_bIsAxisMappingAllowed;                                                     // 0x0040 (size: 0x1)
    bool m_bCheckDuplicateKey;                                                        // 0x0041 (size: 0x1)
    bool m_bForceDisplayAsSingleField;                                                // 0x0042 (size: 0x1)
    float m_fKeyToAxisMultScaleFactor;                                                // 0x0044 (size: 0x4)

}; // Size: 0x48

struct FMappingID
{
    FInputPresetsEnumHandler m_PresetID;                                              // 0x0000 (size: 0x50)
    InputAction m_eAction;                                                            // 0x0050 (size: 0x1)
    InputContext m_eContext;                                                          // 0x0051 (size: 0x1)
    bool m_bUsePreset;                                                                // 0x0052 (size: 0x1)

}; // Size: 0x58

struct FMappingProfileInfos
{
    EKeyboardLayout m_eKeyboardLayout;                                                // 0x0000 (size: 0x1)
    TSoftObjectPtr<UInputMappingProfileDB> m_Profile;                                 // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FMappingProfileList
{
    TArray<FMappingProfileInfos> m_MappingProfiles;                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FMappingValidationError
{
    EMappingValidationErrorType m_eResult;                                            // 0x0000 (size: 0x1)
    FMappingID m_ID;                                                                  // 0x0008 (size: 0x58)
    FMappingID m_CollideID;                                                           // 0x0060 (size: 0x58)
    class UGenericInputData* m_CollideWithData;                                       // 0x00B8 (size: 0x8)

}; // Size: 0xC0

struct FMatchmakingZoneStatus
{
    uint8 m_uiZoneID;                                                                 // 0x0000 (size: 0x1)
    uint8 m_uiSubZoneID;                                                              // 0x0001 (size: 0x1)
    uint8 m_uiOpenedGates;                                                            // 0x0002 (size: 0x1)
    uint8 m_uiOpenedGhostGates;                                                       // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FMenuOptionData
{
    float m_fMin;                                                                     // 0x0000 (size: 0x4)
    float m_fMax;                                                                     // 0x0004 (size: 0x4)
    float m_fDefaultValue;                                                            // 0x0008 (size: 0x4)
    bool m_bApplyOnSet;                                                               // 0x000C (size: 0x1)

}; // Size: 0x14

struct FMenuReferenceWithRequiredTags
{
    TSoftClassPtr<UMenuWidget> m_Menu;                                                // 0x0000 (size: 0x28)
    FGameplayTagContainer m_RequiredGameFlowTags;                                     // 0x0028 (size: 0x20)
    bool m_bLoadSyncAtInit;                                                           // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FMenuStackInfos
{
    EMenuEnum m_eMenu;                                                                // 0x0000 (size: 0x1)
    TWeakObjectPtr<class UPanelWidget> m_Container;                                   // 0x0004 (size: 0x8)
    TWeakObjectPtr<class UWidget> m_FocusedButton;                                    // 0x000C (size: 0x8)

}; // Size: 0x14

struct FMoveStatus
{
    bool m_bExploration;                                                              // 0x0000 (size: 0x1)
    bool m_bCombat;                                                                   // 0x0001 (size: 0x1)
    bool m_bNone;                                                                     // 0x0002 (size: 0x1)
    EMoveStatus m_eMoveStatus;                                                        // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FMovementMode
{
    bool m_bNone;                                                                     // 0x0000 (size: 0x1)
    bool m_bWalking;                                                                  // 0x0001 (size: 0x1)
    bool m_bNavWalking;                                                               // 0x0002 (size: 0x1)
    bool m_bFalling;                                                                  // 0x0003 (size: 0x1)
    bool m_bSwimming;                                                                 // 0x0004 (size: 0x1)
    bool m_bFlying;                                                                   // 0x0005 (size: 0x1)
    bool m_bCustom;                                                                   // 0x0006 (size: 0x1)
    uint8 m_replicatedMvtMode;                                                        // 0x0007 (size: 0x1)

}; // Size: 0xC

struct FMovieSceneRetargetingOverrideTemplate : public FMovieSceneEvalTemplate
{
    class UMovieSceneRetargetingOverrideSection* Section;                             // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FMovieSceneSubtitlesTemplate : public FMovieSceneAkAudioEventTemplate
{
    class UMovieSceneSubtitlesSection* SubtitleSection;                               // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FNameArray
{
    TArray<FName> m_Array;                                                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FNavAreaPerRange
{
    FFloatRange m_Range;                                                              // 0x0000 (size: 0x10)
    TSubclassOf<class UNavArea> m_associatedArea;                                     // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FNavMeshFreeRange
{
    ESCCardinalPoints m_eOrientation;                                                 // 0x0000 (size: 0x1)
    float m_fRange;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FNavMeshFreeSquare
{
    FVector m_OffsetToInstigator;                                                     // 0x0000 (size: 0xC)
    float m_fSquareSize;                                                              // 0x000C (size: 0x4)
    float m_fRaycastHeight;                                                           // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FNetOrderDropObject : public FNetOrderStructPlayAnimVariableWeight
{
    EDropReason m_eDropReason;                                                        // 0x00A0 (size: 0x1)

}; // Size: 0xA8

struct FNetOrderStruct
{
    TWeakObjectPtr<class AActor> m_TargetActor;                                       // 0x0008 (size: 0x8)
    TWeakObjectPtr<class UAbilityPayload> m_Payload;                                  // 0x0010 (size: 0x8)

}; // Size: 0x20

struct FNetOrderStructAttack : public FNetOrderStruct
{
    FAttackRequest m_AttackRequest;                                                   // 0x0020 (size: 0x48)
    FAttackDataRow m_AttackData;                                                      // 0x0068 (size: 0x78)
    bool m_bIsMirrorAnimToUse;                                                        // 0x00E1 (size: 0x1)

}; // Size: 0xF8

struct FNetOrderStructAttackEnv : public FNetOrderStructSnapAnim
{
    FTransform m_Snap;                                                                // 0x0170 (size: 0x30)
    TWeakObjectPtr<class UBaseEnvironmentalInteractionComponent> m_EnvironementalTakedownComponent; // 0x01A0 (size: 0x8)
    EOrderType m_eTargetOrder;                                                        // 0x01A8 (size: 0x1)
    FHitResult m_Impact;                                                              // 0x01AC (size: 0x8C)
    FHitBox m_Hit;                                                                    // 0x0238 (size: 0x298)
    FHitBox m_EnvHit;                                                                 // 0x04D0 (size: 0x298)

}; // Size: 0x770

struct FNetOrderStructAvoid : public FNetOrderStructPlayAnim
{
    uint8 m_uiAvoidType;                                                              // 0x0160 (size: 0x1)

}; // Size: 0x168

struct FNetOrderStructAvoided : public FNetOrderStruct
{
    FOrderOverAttackInfo m_AvoidInfo;                                                 // 0x0020 (size: 0x440)

}; // Size: 0x470

struct FNetOrderStructCancel : public FNetOrderStruct
{
}; // Size: 0x38

struct FNetOrderStructChargeBuildUp : public FNetOrderStructPlayAnim
{
    uint8 m_uiCapLevel;                                                               // 0x0160 (size: 0x1)
    EQuadrantTypes m_eAttackQuadrant;                                                 // 0x0161 (size: 0x1)

}; // Size: 0x168

struct FNetOrderStructDash : public FNetOrderStructPlayAnim
{
    FVector m_vDirection;                                                             // 0x0160 (size: 0xC)

}; // Size: 0x178

struct FNetOrderStructDefenseSuccess : public FNetOrderStructPlayAnim
{
    FHitResult m_Hit;                                                                 // 0x0160 (size: 0x8C)
    FImpactResult m_Impact;                                                           // 0x01F0 (size: 0xC0)
    FHitRequest m_Request;                                                            // 0x02B0 (size: 0x418)
    bool m_OpponentGoingStructureBroken;                                              // 0x06C8 (size: 0x1)
    bool m_bReorientToAttacker;                                                       // 0x06C9 (size: 0x1)

}; // Size: 0x6D0

struct FNetOrderStructDeflected : public FNetOrderStruct
{
}; // Size: 0x30

struct FNetOrderStructDodge : public FNetOrderStruct
{
    EDodgeType m_eDodgeType;                                                          // 0x0020 (size: 0x1)
    FVector m_vDirection;                                                             // 0x0024 (size: 0xC)
    FVector m_vOrientation;                                                           // 0x0030 (size: 0xC)
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0044 (size: 0x8)
    FVector2D m_vDirOnStick;                                                          // 0x0058 (size: 0x8)
    InputAction m_eInputAction;                                                       // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FNetOrderStructFallFromPush : public FNetOrderStructPlayAnim
{
    FVector m_vDirection;                                                             // 0x0160 (size: 0xC)
    bool m_bLethal;                                                                   // 0x016C (size: 0x1)
    bool m_bFromSlope;                                                                // 0x016D (size: 0x1)
    FVector m_vSlopeNormal;                                                           // 0x0170 (size: 0xC)

}; // Size: 0x180

struct FNetOrderStructFallOnSlope : public FNetOrderStruct
{
    FFallOnSlopeSetup m_Setup;                                                        // 0x0020 (size: 0x468)

}; // Size: 0x490

struct FNetOrderStructFallOnSlopeEntry : public FNetOrderStructPlayAnim
{
    FFallOnSlopeSetup m_Setup;                                                        // 0x0168 (size: 0x468)
    FVector m_vSlopeDir;                                                              // 0x05D0 (size: 0xC)
    FHitRequest m_HitRequest;                                                         // 0x05E0 (size: 0x418)

}; // Size: 0x9F8

struct FNetOrderStructFidget : public FNetOrderStructPlayAnimVariableWeight
{
    FBlendProfileBySpeedStateStruct m_BlendProfiles;                                  // 0x00A0 (size: 0x20)
    EFidgetMirroringTypes m_eMirrorHandling;                                          // 0x00C0 (size: 0x1)

}; // Size: 0xC8

struct FNetOrderStructFightingState : public FNetOrderStructPlayAnim
{
    TWeakObjectPtr<class AActor> m_Instigator;                                        // 0x0160 (size: 0x8)
    FHitRequest m_Hit;                                                                // 0x0168 (size: 0x418)

}; // Size: 0x588

struct FNetOrderStructFightingStateRecovery : public FNetOrderStructPlayAnim
{
    EFightingState m_eFightingState;                                                  // 0x0161 (size: 0x1)

}; // Size: 0x168

struct FNetOrderStructFreezeFrame : public FNetOrderStruct
{
}; // Size: 0x30

struct FNetOrderStructGrab : public FNetOrderStructSnapAnim
{
    bool m_bFromParry;                                                                // 0x0170 (size: 0x1)
    FHitResult m_Hit;                                                                 // 0x0174 (size: 0x8C)
    FImpactResult m_Impact;                                                           // 0x0200 (size: 0xC0)
    FHitRequest m_HitRequest;                                                         // 0x02C0 (size: 0x418)
    FDefenseAnimInfos m_GrabAnimInfos;                                                // 0x06D8 (size: 0x1A8)

}; // Size: 0x880

struct FNetOrderStructGuard : public FNetOrderStruct
{
}; // Size: 0x28

struct FNetOrderStructHitted : public FNetOrderStructPlayAnim
{
    FHitRequest m_Request;                                                            // 0x0168 (size: 0x418)
    FImpactResult m_ImpactResult;                                                     // 0x0580 (size: 0xC0)
    FHitResult m_HitResult;                                                           // 0x0640 (size: 0x8C)
    FHittedAnimContainer m_HittedAnimContainer;                                       // 0x06E0 (size: 0x68)

}; // Size: 0x748

struct FNetOrderStructParried : public FNetOrderStructAttackEnv
{
    FHitDescription m_AttackHitDescription;                                           // 0x0768 (size: 0x568)

}; // Size: 0xCD0

struct FNetOrderStructPlayAnim : public FNetOrderStruct
{
    FAnimContainer m_AnimContainerToPlay;                                             // 0x0020 (size: 0x18)
    FWeaponAnimInfo m_weaponAnimInfoAssociated;                                       // 0x0038 (size: 0x90)
    bool m_bUseRootMotion;                                                            // 0x00C8 (size: 0x1)
    bool m_bOverrideDynamic;                                                          // 0x00C9 (size: 0x1)
    class UCurveFloat* m_OverrideDynamicCurve;                                        // 0x00D0 (size: 0x8)
    bool m_bBlendPreviousSpeed;                                                       // 0x00D8 (size: 0x1)
    float m_fBlendPreviousSpeedDuration;                                              // 0x00DC (size: 0x4)
    bool m_bOverrideDuration;                                                         // 0x00E0 (size: 0x1)
    float m_fOverrideDuration;                                                        // 0x00E4 (size: 0x4)
    bool m_bInterruptAfterDelay;                                                      // 0x00E8 (size: 0x1)
    float m_fInterruptDelay;                                                          // 0x00EC (size: 0x4)
    bool m_bOverrideDistance;                                                         // 0x00F0 (size: 0x1)
    float m_fOverrideDistance;                                                        // 0x00F4 (size: 0x4)
    bool m_bIsOverrideDistanceAbsolute;                                               // 0x00F8 (size: 0x1)
    bool m_bOverrideDirection;                                                        // 0x00F9 (size: 0x1)
    FVector m_vOverrideDirection;                                                     // 0x00FC (size: 0xC)
    bool m_bOverrideOrientation;                                                      // 0x0108 (size: 0x1)
    FVector m_vOverrideOrientation;                                                   // 0x010C (size: 0xC)
    bool m_bOverridePlayRate;                                                         // 0x0148 (size: 0x1)
    float m_fOverridePlayRate;                                                        // 0x014C (size: 0x4)
    float m_fFrozenPlayRate;                                                          // 0x0150 (size: 0x4)
    bool m_bIsInfinite;                                                               // 0x0154 (size: 0x1)
    bool m_bIsMovingOrder;                                                            // 0x0155 (size: 0x1)
    bool m_bUseStartRatioOnNewLoop;                                                   // 0x0156 (size: 0x1)
    bool m_bAllowMirroringOnWeapon;                                                   // 0x0157 (size: 0x1)
    EQuadrantTypes m_eForcedQuadrant;                                                 // 0x0158 (size: 0x1)

}; // Size: 0x160

struct FNetOrderStructPlayAnimVariableWeight : public FNetOrderStruct
{
    FAnimContainer m_AnimContainerToPlay;                                             // 0x0020 (size: 0x18)
    FSCUserDefinedEnumHandler m_VariableWeightLayer;                                  // 0x0038 (size: 0x50)
    ELookAtApplyMode m_eLookAtApplyMode;                                              // 0x0088 (size: 0x1)

}; // Size: 0xA0

struct FNetOrderStructPlayBlendSpace : public FNetOrderStruct
{
    class UBlendSpaceBase* m_BlendSpace;                                              // 0x0020 (size: 0x8)
    FVector m_vDefaultCoordinates;                                                    // 0x0028 (size: 0xC)
    float m_fDuration;                                                                // 0x0034 (size: 0x4)
    float m_fPlayRate;                                                                // 0x0038 (size: 0x4)
    bool m_bIsInfinite;                                                               // 0x003C (size: 0x1)

}; // Size: 0x40

struct FNetOrderStructPushFromGrab : public FNetOrderStructSnapAnim
{
    TWeakObjectPtr<class AActor> m_ThrowTarget;                                       // 0x0170 (size: 0x8)
    FVector m_ThrowTargetDir;                                                         // 0x0178 (size: 0xC)

}; // Size: 0x188

struct FNetOrderStructRagingBull : public FNetOrderStructPlayAnim
{
    ERagingBullPhase m_ePhase;                                                        // 0x0160 (size: 0x1)
    FHitBox m_HitBox;                                                                 // 0x0168 (size: 0x298)
    float m_fMaxAngularSpeed;                                                         // 0x0400 (size: 0x4)
    FAnimContainer m_wallSplashFrontAnim;                                             // 0x0408 (size: 0x18)
    bool m_bHasMissedTarget;                                                          // 0x0420 (size: 0x1)

}; // Size: 0x428

struct FNetOrderStructSnapAnim : public FNetOrderStructPlayAnim
{
    bool m_bIsSnapper;                                                                // 0x0160 (size: 0x1)
    bool m_bSnapOnTarget;                                                             // 0x0161 (size: 0x1)
    int32 m_iSyncID;                                                                  // 0x0164 (size: 0x4)
    bool m_bIsInstigator;                                                             // 0x0168 (size: 0x1)

}; // Size: 0x170

struct FNetOrderStructSpawn : public FNetOrderStruct
{
}; // Size: 0x28

struct FNetOrderStructSynchronizedAttackVictim : public FNetOrderStructSnapAnim
{
    TArray<FOverridingHitBox> m_Hits;                                                 // 0x0170 (size: 0x10)
    bool m_bCanCounterGrab;                                                           // 0x0180 (size: 0x1)

}; // Size: 0x188

struct FNetOrderStructTakedown : public FNetOrderStructAttackEnv
{
    bool m_bFromParry;                                                                // 0x0768 (size: 0x1)
    bool m_bEnvironementalTakedown;                                                   // 0x0769 (size: 0x1)
    FHitResult m_ParryHit;                                                            // 0x076C (size: 0x8C)
    FImpactResult m_ParryImpact;                                                      // 0x07F8 (size: 0xC0)
    FHitRequest m_ParryHitRequest;                                                    // 0x08B8 (size: 0x418)
    FHitResult m_ImpactOnEnv;                                                         // 0x0CD0 (size: 0x8C)

}; // Size: 0xD60

struct FNetOrderStructTraversal : public FNetOrderStruct
{
    FTraversalInfo m_TraversalInfo;                                                   // 0x0020 (size: 0xC8)
    FHitBox m_FallHit;                                                                // 0x00E8 (size: 0x298)

}; // Size: 0x428

struct FNetOrderStructTraversalCine : public FNetOrderStructPlayAnim
{
    FTraversalInfo m_TraversalInfo;                                                   // 0x0160 (size: 0xC8)

}; // Size: 0x228

struct FNetOrderStructUseMovable : public FNetOrderStructAttack
{
}; // Size: 0x110

struct FNetOrderStructWallJumpAttack : public FNetOrderStructPlayAnim
{
    EWallJumpAttackPhase m_eCurrentWallJumpPhase;                                     // 0x0160 (size: 0x1)

}; // Size: 0x1C0

struct FNetStructMoveToWithPhysWalking : public FNetOrderStruct
{
    class UNavLinkCustomComponent* m_NavLinkComponent;                                // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FNetStructOpeningDoor : public FNetOrderStructPlayAnimVariableWeight
{
    class UAnimationAsset* m_OpeningDoorAnimAsset;                                    // 0x00A0 (size: 0x8)
    class UAnimationAsset* m_ClosingDoorAnimAsset;                                    // 0x00A8 (size: 0x8)
    bool m_bInteraction1;                                                             // 0x00B0 (size: 0x1)
    FAnimContainer m_AnimContainerToPlayWhenCarryingWeapon;                           // 0x00B8 (size: 0x18)
    FSCUserDefinedEnumHandler m_VariableWeightLayerWhenCarryingWeapon;                // 0x00D0 (size: 0x50)

}; // Size: 0x120

struct FNetStructPickUpObject : public FNetOrderStructPlayAnimVariableWeight
{
    TWeakObjectPtr<class AActor> m_PickUpObject;                                      // 0x00A0 (size: 0x8)

}; // Size: 0xA8

struct FOnHitDelayed
{
    FHitDescription m_Hit;                                                            // 0x0008 (size: 0x568)

}; // Size: 0x570

struct FOrderInfosInstance
{
    TArray<FOrderServiceInfos> m_Services;                                            // 0x0000 (size: 0x10)
    class UOrderDB* m_DB;                                                             // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FOrderInfosInstanceMap
{
    TMap<class EOrderType, class FOrderInfosInstance> m_OrderServiceInstances;        // 0x0000 (size: 0x50)
    TMap<class FName, class FOrderInfosInstance> m_BPOrderServiceInstances;           // 0x0050 (size: 0x50)

}; // Size: 0xA0

struct FOrderOverAttackInfo
{
    TWeakObjectPtr<class AActor> m_Instigator;                                        // 0x0000 (size: 0x8)
    FHitDefenseResult m_DefenseResult;                                                // 0x0008 (size: 0x10)
    FHitRequest m_HitRequest;                                                         // 0x0018 (size: 0x418)
    EOrderType m_eOrderType;                                                          // 0x0430 (size: 0x1)
    uint8 m_uiOrderID;                                                                // 0x0431 (size: 0x1)

}; // Size: 0x440

struct FOrderServiceClassInstance
{
    TSubclassOf<class UOrderService> m_DefaultClassObject;                            // 0x0000 (size: 0x8)
    class UOrderService* m_Instance;                                                  // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FOrderServiceFrameRange
{
    bool m_bBoundToAnim;                                                              // 0x0000 (size: 0x1)
    class UOrderServiceFrameRangeRequest* m_FrameRangeRequest;                        // 0x0008 (size: 0x8)
    FFloatRange m_FrameRange;                                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FOrderServiceInfos
{
    bool m_bDisabled;                                                                 // 0x0000 (size: 0x1)
    EOrderServiceFreezeFrameHandling m_eFreezeFrameHandling;                          // 0x0001 (size: 0x1)
    bool m_bActivateFromFrameRange;                                                   // 0x0008 (size: 0x1)
    bool m_bActivateWhenMissingFromAnim;                                              // 0x0009 (size: 0x1)
    TSubclassOf<class UOrderServiceActivationConditions> m_activationCondition;       // 0x0010 (size: 0x8)
    bool m_bInvertCondition;                                                          // 0x0018 (size: 0x1)
    FOrderServiceFrameRange m_FrameRangeInfos;                                        // 0x0020 (size: 0x20)
    FOrderServiceClassInstance m_OrderServiceInstance;                                // 0x0040 (size: 0x10)

}; // Size: 0x60

struct FOrderServiceInfosList
{
    TArray<class TSubclassOf<UOrderPresetDB>> m_Presets;                              // 0x0000 (size: 0x10)
    TArray<FOrderServiceInfos> m_Services;                                            // 0x0010 (size: 0x10)
    TArray<FOrderServiceInserted> m_InsertedServices;                                 // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FOrderServiceInserted
{
    int32 m_iInsertionIndex;                                                          // 0x0000 (size: 0x4)
    FOrderServiceInfos m_OrderService;                                                // 0x0008 (size: 0x60)

}; // Size: 0x68

struct FOrderTransformData
{
    float m_fPosX;                                                                    // 0x0000 (size: 0x4)
    float m_fPosY;                                                                    // 0x0004 (size: 0x4)
    float m_fOrientation;                                                             // 0x0008 (size: 0x4)
    float m_fOrderRatio;                                                              // 0x000C (size: 0x4)

}; // Size: 0x10

struct FOrderType
{
    EOrderType m_eOrderType;                                                          // 0x0000 (size: 0x1)
    FName m_BPOrderID;                                                                // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FOrientedRotationAnimContainer
{
    FRotationAnimContainer m_leftAnims;                                               // 0x0000 (size: 0x48)
    FRotationAnimContainer m_rightAnims;                                              // 0x0048 (size: 0x48)

}; // Size: 0x90

struct FOutfitData
{
    TSoftObjectPtr<USkeletalMesh> m_Mesh;                                             // 0x0000 (size: 0x28)
    TMap<int32, TSoftObjectPtr<UMaterialInstance>> m_OverrideMaterial;                // 0x0028 (size: 0x50)
    FDataTableRowHandle m_props;                                                      // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FOverridenVariableWeightInfo
{
    FName m_Name;                                                                     // 0x0000 (size: 0x8)
    float m_fOverridenAlpha;                                                          // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FOverridingHitBox
{
    FHitBox m_HitBox;                                                                 // 0x0000 (size: 0x298)
    class UAttackPropertiesResistanceDB* m_ResistanceDB;                              // 0x0298 (size: 0x8)
    FAnimContainer m_FightingStateLoopAnimToPlay;                                     // 0x02A0 (size: 0x18)
    FAnimContainer m_FightingStateRecoveryAnimToPlay;                                 // 0x02B8 (size: 0x18)
    FHittedAnimContainer m_LethalHittedAnimToPlay;                                    // 0x02D0 (size: 0x68)
    bool m_bIsLethalHittedAnimPlayerOnly;                                             // 0x0338 (size: 0x1)

}; // Size: 0x340

struct FParriedProfile
{
    float m_fParriedDuration;                                                         // 0x0000 (size: 0x4)
    ESCBlendType m_eParriedReorientationBlendType;                                    // 0x0004 (size: 0x1)
    class UCurveFloat* m_ParriedReorientationCurve;                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FParryAnimationCharacterQuadrantArray
{
    FParryAnimationParryQuadrantArray m_Array;                                        // 0x0000 (size: 0x180)

}; // Size: 0x180

struct FParryAnimationParryQuadrantArray
{
    FAnimContainer m_Array;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FParryRequestInfos
{
    EQuadrantTypes m_eQuadrant;                                                       // 0x0000 (size: 0x1)
    ESCCardinalPoints m_eCardinal;                                                    // 0x0001 (size: 0x1)
    bool m_bFromDown;                                                                 // 0x0002 (size: 0x1)
    bool m_bHasAWeapon;                                                               // 0x0003 (size: 0x1)
    bool m_bIsWeaponOnOppositeHand;                                                   // 0x0004 (size: 0x1)

}; // Size: 0x5

struct FParryType
{
    EParryDirection m_eParryDirection;                                                // 0x0000 (size: 0x1)
    EParrySide m_eParrySide;                                                          // 0x0001 (size: 0x1)
    EParryHeight m_eParryHeight;                                                      // 0x0002 (size: 0x1)

}; // Size: 0x3

struct FPatrolActivity
{
    FAnimContainer m_animContainer;                                                   // 0x0000 (size: 0x18)
    float m_fActivityDuration;                                                        // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FPatrolControlPoint
{
    FVector m_vLocalPosition;                                                         // 0x0000 (size: 0xC)
    bool m_bOverrideActivityAnimation;                                                // 0x000C (size: 0x1)
    FName m_ActivityName;                                                             // 0x0010 (size: 0x8)
    FAnimContainer m_ActivityAnimContainer;                                           // 0x0018 (size: 0x18)
    bool m_bOverrideActivityDuration;                                                 // 0x0030 (size: 0x1)
    float m_fOverridenActivityDuration;                                               // 0x0034 (size: 0x4)
    ESpeedState m_eSpeedStateToUse;                                                   // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FPelvisDirectionComputationParams
{
    bool m_bUseFeetLocation;                                                          // 0x0012 (size: 0x1)
    bool m_bInverseAxis;                                                              // 0x0013 (size: 0x1)
    FName m_boneName;                                                                 // 0x0014 (size: 0x8)
    TEnumAsByte<EAxis::Type> m_eAxis;                                                 // 0x001C (size: 0x1)

}; // Size: 0x38

struct FPendingAttackXP
{
}; // Size: 0x1

struct FPendingOrderStruct
{
    EOrderType OrderType;                                                             // 0x0000 (size: 0x1)
    class UOrderComponent* OrderComponent;                                            // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FPhaseNodeHandler
{
    FGuid m_Guid;                                                                     // 0x0000 (size: 0x10)
    FName m_Name;                                                                     // 0x0010 (size: 0x8)
    FAIPhaseNodeHardLink m_Link;                                                      // 0x0018 (size: 0x20)
    TSubclassOf<class UArchetypeAsset> m_PhaseArchetype;                              // 0x0038 (size: 0x8)
    TSubclassOf<class UArchetypeAsset> m_WeakerPhaseArchetype;                        // 0x0040 (size: 0x8)
    TSubclassOf<class UArchetypeAsset> m_StrongerPhaseArchetype;                      // 0x0048 (size: 0x8)
    class USkeletalMesh* m_OverrideSkeletalMesh;                                      // 0x0050 (size: 0x8)
    EAIPhaseNodeType m_eType;                                                         // 0x0058 (size: 0x4)
    FAICustomBehaviorTreeList m_CustomBehaviorTrees;                                  // 0x0060 (size: 0x10)
    FName m_DialogToLaunch;                                                           // 0x0070 (size: 0x8)
    TArray<FPhaseTransitionNodeHandler> m_PhaseTransitions;                           // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FPhaseTransitionNodeHandler
{
    class UAIPhaseTransition* m_TransitionObject;                                     // 0x0000 (size: 0x8)
    bool m_bNeedsLastManGaugeFull;                                                    // 0x0008 (size: 0x1)
    FAnimContainer m_PhaseTransitionAnimContainer;                                    // 0x0010 (size: 0x18)
    TSubclassOf<class USynchronizedAttackHitActionLauncher> m_SyncHitActionLauncher;  // 0x0028 (size: 0x8)
    class ULevelSequence* m_LevelSequence;                                            // 0x0030 (size: 0x8)
    EAIPhaseLevelSequenceTransform m_LevelSequenceTransform;                          // 0x0038 (size: 0x4)
    FAISituationNamedActor m_LevelSequenceTransformActor;                             // 0x003C (size: 0x8)
    int32 m_iChildNodeIndex;                                                          // 0x0044 (size: 0x4)
    bool m_bResetHealth;                                                              // 0x0048 (size: 0x1)
    bool m_bResetStructure;                                                           // 0x0049 (size: 0x1)
    bool m_bResetSuperDizzy;                                                          // 0x004A (size: 0x1)
    bool m_bResetCurrentAIActions;                                                    // 0x004B (size: 0x1)

}; // Size: 0x50

struct FPhasesTransitionObjectCache
{
    TArray<FPhasesTransitionObjectCacheEntry> m_Cache;                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPhasesTransitionObjectCacheEntry
{
    class UAIPhaseTransition* m_Object;                                               // 0x0000 (size: 0x8)

}; // Size: 0x18

struct FPictoData
{
    FLinearColor m_color;                                                             // 0x0000 (size: 0x10)
    float m_fGlow;                                                                    // 0x0010 (size: 0x4)
    float m_fIntensity;                                                               // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FPlayOrderInfos
{
    uint8 m_uiAfterOrder;                                                             // 0x0000 (size: 0x1)
    float m_fDelay;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x40

struct FPlayerGenderSpecificData
{
    TArray<FOutfitData> m_Outfits;                                                    // 0x0000 (size: 0x10)
    TSoftObjectPtr<UBaseMovementDB> m_BaseMovementDB;                                 // 0x0010 (size: 0x28)
    TSoftClassPtr<USCCharacterPoseData> m_PoseData;                                   // 0x0038 (size: 0x28)

}; // Size: 0x60

struct FPlayerKill
{
    class AFightingPlayerState* m_PlayerState;                                        // 0x0000 (size: 0x8)
    uint32 m_uiNbKills;                                                               // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FPlayerStatesStatus
{
    bool m_bWasActive;                                                                // 0x0000 (size: 0x1)
    bool m_bIsActive;                                                                 // 0x0001 (size: 0x1)
    float m_fActiveSince;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPowerShopDataRow : public FTableRowBase
{
    class UBaseItemData* m_Power;                                                     // 0x0008 (size: 0x8)
    int32 m_iGMLevelRequired;                                                         // 0x0010 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0014 (size: 0x4)
    int32 m_iFragmentPrice;                                                           // 0x0018 (size: 0x4)
    int32 m_iPrestigePointPrice;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FProfileData
{
    TArray<FFilterProperties> m_FilterPresets;                                        // 0x0000 (size: 0x10)
    float m_GameOptions;                                                              // 0x0010 (size: 0xA4)
    TMap<class FString, class FSaveAdditionalInfos> m_SaveAdditionalInfoMap;          // 0x00B8 (size: 0x50)
    FInputMappingProfileEnumHandler m_GamepadProfile;                                 // 0x0108 (size: 0x50)
    FInputMappingProfileEnumHandler m_KeyboardProfile;                                // 0x0158 (size: 0x50)
    FInputMappingProfileData m_GamepadCustomMapping;                                  // 0x01A8 (size: 0xA8)
    FInputMappingProfileData m_KeyboardCustomMapping;                                 // 0x0250 (size: 0xA8)
    bool m_bInputHoldToggleActivated;                                                 // 0x02F8 (size: 0x1)
    FGameplayTagContainer m_UnlockedCheats;                                           // 0x0300 (size: 0x20)
    TMap<TSubclassOf<USkillGameplayEffect>, int32> m_SkillConsolidationLevel;         // 0x0320 (size: 0x50)
    int32 m_iCheatUnlockPoints;                                                       // 0x0370 (size: 0x4)
    TMap<class FName, class FArenaChallengeSave> m_aArenaSavePerChallenge;            // 0x0378 (size: 0x50)
    ECharacterGender m_eChallengeGender;                                              // 0x03C8 (size: 0x1)

}; // Size: 0x3D0

struct FProgressionDoorStruct
{
    class UProgressionDoorData* m_ProgressionDoorData;                                // 0x0000 (size: 0x8)
    TArray<class UQuestItemData*> m_Conditions;                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FProgressionRewardArray
{
    TArray<ECharacterProgressionRewardTypes> m_WeaponRewards;                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPropertyFloorBoneRepartition
{
    FBoneReference m_Bone;                                                            // 0x0000 (size: 0x10)
    FFloatRange m_DegreeFloorAngleRange;                                              // 0x0010 (size: 0x10)
    float m_fRepartitionAlpha;                                                        // 0x0020 (size: 0x4)
    float m_fResultAlpha;                                                             // 0x0024 (size: 0x4)
    FTransform m_BoneResultTransform;                                                 // 0x0030 (size: 0x30)

}; // Size: 0x70

struct FPropertyReaction : public FBaseFightingStateBehavior
{
    FPropertyReactionMovement m_Movement;                                             // 0x0010 (size: 0x10)
    FAnimContainer m_RecoveryAnims;                                                   // 0x0020 (size: 0x60)
    bool m_bUseRootMotion;                                                            // 0x0080 (size: 0x1)
    FPropertyReactionHit m_HitReaction;                                               // 0x0088 (size: 0x18)
    bool m_bAlwayKeepCurrentStateDurationOnHit;                                       // 0x00A0 (size: 0x1)
    bool m_bPauseGuardBreak;                                                          // 0x00A1 (size: 0x1)
    bool m_bHoldDuringStructureBroken;                                                // 0x00A2 (size: 0x1)
    float m_fMaxAccumulatedDamage;                                                    // 0x00A4 (size: 0x4)
    int32 m_iMaxAccumatedHits;                                                        // 0x00A8 (size: 0x4)
    bool m_bGroupMaxAccumulatedHitsByAttack;                                          // 0x00AC (size: 0x1)
    FAIResistanceActions m_Actions;                                                   // 0x00B0 (size: 0x20)

}; // Size: 0xD0

struct FPropertyReactionHit
{
    float m_fHittedDuration;                                                          // 0x0000 (size: 0x4)
    class UCurveFloat* m_HittedDynamic;                                               // 0x0008 (size: 0x8)
    float m_fHittedKnockBackDistance;                                                 // 0x0010 (size: 0x4)
    float m_fHittedToStateBlendDuration;                                              // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FPropertyReactionMovement
{
    class UCurveFloat* m_StateMoveDynamic;                                            // 0x0000 (size: 0x8)
    float m_fStateDistance;                                                           // 0x0008 (size: 0x4)
    float m_fDuration;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FPushAnims
{
    TMap<class ESCCardinalPoints, class FAnimContainer> m_GrabberAnims;               // 0x0000 (size: 0x50)
    TMap<class ESCCardinalPoints, class FAnimContainer> m_GrabbedAnims;               // 0x0050 (size: 0x50)
    bool m_bSouthMirrorPositiveAngle;                                                 // 0x00A0 (size: 0x1)
    bool m_bNorthMirrorPositiveAngle;                                                 // 0x00A1 (size: 0x1)

}; // Size: 0xA8

struct FPushPropertyReaction
{
    FHitBox m_WallSplashHit;                                                          // 0x0000 (size: 0x298)
    FHitBox m_WallSplashCloseHit;                                                     // 0x0298 (size: 0x298)
    FHitBox m_WallSplashHitOnWall;                                                    // 0x0530 (size: 0x298)
    FHitBox m_HitBox;                                                                 // 0x07C8 (size: 0x298)
    FPropertyReaction m_BasePushReaction;                                             // 0x0A60 (size: 0xD0)
    FPushedFromGrabbedReaction m_PushedFromGrabbedReaction;                           // 0x0B30 (size: 0x28)
    float m_EnvAttackRanges;                                                          // 0x0B58 (size: 0x10)
    float m_fAttackEnvCapsuleExtent;                                                  // 0x0B68 (size: 0x4)
    float m_fEnvAttackMaxAngleDeg;                                                    // 0x0B6C (size: 0x4)
    float m_fEnvAttackMaxAngleWitoutSnapDeg;                                          // 0x0B70 (size: 0x4)
    float m_fNavigationCostHeuristicScale;                                            // 0x0B74 (size: 0x4)
    float m_fNavigationMaxPathCost;                                                   // 0x0B78 (size: 0x4)
    FName m_EnvAttackImpactBoneName;                                                  // 0x0B7C (size: 0x8)

}; // Size: 0xB90

struct FPushTraversalAnimContainer : public FTraversalAnimContainer
{
    FAnimContainer m_InstigatorAnim;                                                  // 0x0080 (size: 0x18)

}; // Size: 0x98

struct FPushedFromGrabbedReaction
{
    FAnimContainer m_Loop;                                                            // 0x0000 (size: 0x18)
    FPropertyReactionMovement m_Movement;                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FQuadrantAnimContainer
{
    FAnimContainer m_Anims;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FRagingBullAnimContainer
{
    class UAnimSequence* m_animation;                                                 // 0x0000 (size: 0x8)
    float m_fAnimSpeed;                                                               // 0x0008 (size: 0x4)
    bool m_bUseRootMotion;                                                            // 0x000C (size: 0x1)
    float m_fAnimPlayRate;                                                            // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FRarityData
{
    FText m_Name;                                                                     // 0x0000 (size: 0x18)
    FLinearColor m_color;                                                             // 0x0018 (size: 0x10)
    class UMaterial* m_Material;                                                      // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FRelationshipActionArray
{
    ELockActionCondition m_Array;                                                     // 0x0000 (size: 0xA)

}; // Size: 0xA

struct FRelationshipActionConditionArray
{
    FRelationshipActionArray m_Array;                                                 // 0x0000 (size: 0x3C)

}; // Size: 0x3C

struct FRemappingClasses
{
    TArray<TSoftObjectPtr<UGenericInputData>> m_Classes;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FRemappingIncompatibilityGroup
{
    bool m_bDetectChildCollisions;                                                    // 0x0000 (size: 0x1)
    TArray<TSoftObjectPtr<UGenericInputData>> m_Classes;                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FRemappingSectionStruct
{
    FText m_SectionDisplayText;                                                       // 0x0000 (size: 0x18)
    TArray<FMappableInputStruct> m_RemappableActions;                                 // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FReplayAnimGraphCachedContext
{
}; // Size: 0x60

struct FReplayAnimGraphPlayerAssetVersioning
{
    int32 m_iAnimInstanceIndex;                                                       // 0x0000 (size: 0x4)
    int32 m_iStateMachineIndex;                                                       // 0x0004 (size: 0x4)
    int32 m_iStateMachineStateIndex;                                                  // 0x0008 (size: 0x4)
    int32 m_iPlayerAssetIndex;                                                        // 0x000C (size: 0x4)
    FString m_UniqueID;                                                               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FReplayAnimGraphVersioning
{
    TArray<FName> m_StateMachineNames;                                                // 0x0000 (size: 0x10)
    TArray<FReplayAnimGraphPlayerAssetVersioning> m_AssetPlayers;                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FReplayAvailabilityLayerCache
{
    FAvailabilityLayerCaches m_TimeControl;                                           // 0x0000 (size: 0x18)
    FAvailabilityLayerCaches m_KeyEdition;                                            // 0x0018 (size: 0x18)
    FAvailabilityLayerCaches m_FreeFly;                                               // 0x0030 (size: 0x18)
    FAvailabilityLayerCaches m_KeySelected;                                           // 0x0048 (size: 0x18)
    FAvailabilityLayerCaches m_HoveringKey;                                           // 0x0060 (size: 0x18)
    FAvailabilityLayerCaches m_Scrubbing;                                             // 0x0078 (size: 0x18)
    FAvailabilityLayerCaches m_GoToTime;                                              // 0x0090 (size: 0x18)
    FAvailabilityLayerCaches m_MovingKey;                                             // 0x00A8 (size: 0x18)
    FAvailabilityLayerCaches m_MoveKey;                                               // 0x00C0 (size: 0x18)
    FAvailabilityLayerCaches m_ReplayPreview;                                         // 0x00D8 (size: 0x18)
    FAvailabilityLayerCaches m_ReplayEdit;                                            // 0x00F0 (size: 0x18)
    FAvailabilityLayerCaches m_KeyCopied;                                             // 0x0108 (size: 0x18)

}; // Size: 0x120

struct FReplayCachedAnimInstanceAssetPlayers
{
    int32 m_iAnimInstanceIndex;                                                       // 0x0000 (size: 0x4)

}; // Size: 0x18

struct FReplayCachedStateMachine
{
}; // Size: 0x28

struct FReplayCameraMeshFadingData
{
    bool m_bEnabledByDefault;                                                         // 0x0000 (size: 0x1)
    class UMaterialParameterCollection* m_Collection;                                 // 0x0008 (size: 0x8)
    FName m_ParameterName;                                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FReplayCameraSettings
{
    FCameraLensSettings m_Lens;                                                       // 0x0000 (size: 0x18)
    FCameraFilmbackSettings m_Filmback;                                               // 0x0018 (size: 0xC)

}; // Size: 0x28

struct FReplayCameraTransform
{
    FVector m_vLocation;                                                              // 0x0000 (size: 0xC)
    FQuat m_qRotation;                                                                // 0x0010 (size: 0x10)
    FVector m_vSensorSettings;                                                        // 0x0020 (size: 0xC)
    bool m_bInterpolate;                                                              // 0x002C (size: 0x1)
    bool m_bCanEdit;                                                                  // 0x002D (size: 0x1)

}; // Size: 0x50

struct FReplayCurrentRecordingData
{
    int64 m_iRecordingArchiveSize;                                                    // 0x0000 (size: 0x8)
    int32 m_iRecordingDuration;                                                       // 0x0008 (size: 0x4)
    FReplaySizeManagement m_SizeManagementData;                                       // 0x0010 (size: 0x28)
    float m_fBytesPerSeconds;                                                         // 0x0038 (size: 0x4)
    float m_fTimeleftInSecondsAvg;                                                    // 0x003C (size: 0x4)

}; // Size: 0x40

struct FReplayCutInfo
{
    class UReplayKey* m_FirstKey;                                                     // 0x0000 (size: 0x8)
    class UReplayKey* m_SecondKey;                                                    // 0x0008 (size: 0x8)
    class UReplayKey* m_CurrentKey;                                                   // 0x0010 (size: 0x8)

}; // Size: 0x20

struct FReplayGameplayCameraRecordEvent : public FReplaySerializedEvent
{
    FReplayCameraTransform m_FirstFrameCameraTransform;                               // 0x0010 (size: 0x50)
    FReplayCameraTransform m_LastFrameCameraTransform;                                // 0x0060 (size: 0x50)

}; // Size: 0xB0

struct FReplayInfo
{
    FString m_ReplayName;                                                             // 0x0000 (size: 0x10)
    FString m_ReplayFriendlyNameLocalized;                                            // 0x0010 (size: 0x10)
    FString m_ReplayFriendlyName;                                                     // 0x0020 (size: 0x10)
    FDateTime m_Date;                                                                 // 0x0030 (size: 0x8)
    FReplayInfoUpdateTime m_LastReplayEditorUpdateTime;                               // 0x0038 (size: 0x10)
    int32 m_iChangeList;                                                              // 0x0048 (size: 0x4)
    int32 m_iReplayVersion;                                                           // 0x004C (size: 0x4)
    int32 m_iLength;                                                                  // 0x0050 (size: 0x4)
    int64 m_iSizeInBytes;                                                             // 0x0058 (size: 0x8)
    bool m_bIsCorrupted;                                                              // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FReplayInfoUpdateTime
{
    FDateTime m_LastReplayEditorUpdateTime;                                           // 0x0000 (size: 0x8)
    bool m_bHasLastReplayEditorUpdateTime;                                            // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FReplayInitialStateToggleEvent
{
    FReplayInitialStateToggleEvent_Event m_Event;                                     // 0x0000 (size: 0x10)
    void ReplayInitialStateToggleEventDelegate(bool _bToggle);
    FReplayInitialStateToggleEvent_GetValueDelegate m_GetValueDelegate;               // 0x0010 (size: 0x10)
    bool ReplayInitialStateToggleGetValueEventDelegate();
    class AActor* m_Actor;                                                            // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FReplayKeyCameraTransitionContextCameraTarget
{
}; // Size: 0xC

struct FReplayKeyCutData
{
    EReplayKeyCutType m_eCutType;                                                     // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FReplayKeyData
{
    int32 m_iKeyIndex;                                                                // 0x0000 (size: 0x4)
    int32 m_iKeyFrameIndex;                                                           // 0x0004 (size: 0x4)
    float m_fTime;                                                                    // 0x0008 (size: 0x4)
    float m_fDilatedTime;                                                             // 0x000C (size: 0x4)
    float m_fTimeDilation;                                                            // 0x0010 (size: 0x4)
    int32 m_eTypeFlags;                                                               // 0x0014 (size: 0x4)
    EReplayKeyTransition m_eTransition;                                               // 0x0018 (size: 0x1)
    EReplayKeyCameraMode m_eCameraMode;                                               // 0x0019 (size: 0x1)
    EReplayKeyCameraMeshFading m_eCameraMeshFading;                                   // 0x001A (size: 0x1)
    FVector m_vCameraLocation;                                                        // 0x001C (size: 0xC)
    FQuat m_qCameraRotation;                                                          // 0x0030 (size: 0x10)
    FReplayKeyDataCameraTransitionOverrideSettings m_CameraTransformSettings;         // 0x0040 (size: 0x40)
    FReplayKeyDataCameraSettings m_CameraSettings;                                    // 0x0080 (size: 0x28)
    FReplayKeyCutData m_CutData;                                                      // 0x00A8 (size: 0x1)
    FReplayKeyScreenFading m_ScreenFading;                                            // 0x00AC (size: 0x8)

}; // Size: 0xC0

struct FReplayKeyDataCameraSettings
{
    FReplayKeyDataFocusSettings m_FocusSettings;                                      // 0x0000 (size: 0x20)
    FReplayKeyDataLensSettings m_LensSettings;                                        // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FReplayKeyDataCameraTarget
{
    FReplayKeyDataWorldTarget m_Target;                                               // 0x0000 (size: 0x10)
    FVector m_vInitialTargetLocation;                                                 // 0x0010 (size: 0xC)

}; // Size: 0x20

struct FReplayKeyDataCameraTransitionOverrideSettings
{
    FReplayKeyDataCameraTarget m_FollowSettings;                                      // 0x0000 (size: 0x20)
    FReplayKeyDataCameraTarget m_LookAtSettings;                                      // 0x0020 (size: 0x20)

}; // Size: 0x40

struct FReplayKeyDataFocusSettings
{
    EReplayKeyCameraFocus m_eFocusMode;                                               // 0x0000 (size: 0x1)
    float m_fAperture;                                                                // 0x0004 (size: 0x4)
    float m_fFocusDistance;                                                           // 0x0008 (size: 0x4)
    FReplayKeyDataWorldTarget m_Target;                                               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FReplayKeyDataLensSettings
{
    float m_fFocalLength;                                                             // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FReplayKeyDataWorldTarget
{
    FString m_ID;                                                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FReplayKeyScreenFading
{
    EReplayKeyFadeType m_bFadingType;                                                 // 0x0000 (size: 0x1)
    float m_fFadingTime;                                                              // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FReplayKeyTransitionContext
{
}; // Size: 0x70

struct FReplayKeyWidgetVisualData
{
    class UTexture2D* m_Texture;                                                      // 0x0000 (size: 0x8)
    float m_fAngle;                                                                   // 0x0008 (size: 0x4)
    FVector2D m_vSize;                                                                // 0x000C (size: 0x8)

}; // Size: 0x18

struct FReplayKeyWidgetVisualKey
{
    EReplayKeyCameraMode m_eCameraMode;                                               // 0x0000 (size: 0x1)
    EReplayKeyCutType m_eCutType;                                                     // 0x0001 (size: 0x1)
    int32 m_iKeyTypeFlag;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FReplayListInfo
{
    FReplaySizeManagement m_ReplaySizeManagement;                                     // 0x0000 (size: 0x28)
    TArray<FReplayInfo> m_ReplayInfos;                                                // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FReplayOverrideMPCParameter
{
    class UMaterialParameterCollection* m_MPC;                                        // 0x0000 (size: 0x8)
    FName m_ParameterName;                                                            // 0x0008 (size: 0x8)
    float m_fValue;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FReplayPlayerAssetAccumulatedTime
{
    float m_fAccumulatedTime;                                                         // 0x0000 (size: 0x4)
    int32 m_iCachedContainerIndex;                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FReplayReplicatedAnimInstanceAssetPlayers
{
    int32 m_iAnimInstanceIndex;                                                       // 0x0000 (size: 0x4)
    TArray<FReplayPlayerAssetAccumulatedTime> m_AssetPlayers;                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FReplayReplicatedStateMachine
{
    int32 m_iStateIndex;                                                              // 0x0000 (size: 0x4)
    int32 m_iAnimInstanceIndex;                                                       // 0x0004 (size: 0x4)
    int32 m_iStateMachineIndex;                                                       // 0x0008 (size: 0x4)
    TArray<FReplayPlayerAssetAccumulatedTime> m_ReplicatedPlayerAssets;               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FReplaySerializedEvent
{
}; // Size: 0x8

struct FReplaySizeManagement
{
    int64 m_iTotalSpaceOccupied;                                                      // 0x0000 (size: 0x8)
    int64 m_iTotalSpaceAvailable;                                                     // 0x0008 (size: 0x8)
    int64 m_iTotalMaxSpace;                                                           // 0x0010 (size: 0x8)
    int64 m_iMaxReplaySize;                                                           // 0x0018 (size: 0x8)
    int32 m_iCurrentReplaySlotCount;                                                  // 0x0020 (size: 0x4)
    int32 m_iMaxReplaySlotCount;                                                      // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FReplaySoundEvent : public FReplaySerializedEvent
{
}; // Size: 0x10

struct FReplayStreamingEvent : public FReplaySerializedEvent
{
}; // Size: 0x10

struct FReplayTimelineControl
{
    float m_fMinInputTimeS;                                                           // 0x0018 (size: 0x4)
    float m_fCursorMaxSpeed;                                                          // 0x001C (size: 0x4)
    float m_fCursorBaseSpeed;                                                         // 0x0020 (size: 0x4)
    class UCurveFloat* m_Curve;                                                       // 0x0028 (size: 0x8)
    float m_fCursorMaxSpeedReachedTimeS;                                              // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FReplayTimelineControllerData
{
    FReplayCameraMeshFadingData m_CameraMeshFadingData;                               // 0x0000 (size: 0x18)
    float m_fCameraFollowDampingValue;                                                // 0x0018 (size: 0x4)
    float m_fCameraFollowMaxDistanceLerp;                                             // 0x001C (size: 0x4)
    float m_fSavekeyModelFrequency;                                                   // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FReplayTimelineCurrentTransitionContext
{
    FVector2D m_vStartPosition;                                                       // 0x0000 (size: 0x8)
    FVector2D m_vEndPosition;                                                         // 0x0008 (size: 0x8)
    bool m_bHighlighted;                                                              // 0x0010 (size: 0x1)

}; // Size: 0x1C

struct FReplayTimelineIndicatorDisplayProperties
{
    class UCurveFloat* m_TimeDilationIndicatorWidthPerDilationValueCurve;             // 0x0000 (size: 0x8)
    float m_fIndicatorsAlignment;                                                     // 0x0008 (size: 0x4)
    float m_fIndicatorsHeight;                                                        // 0x000C (size: 0x4)
    bool m_bAntiAlias;                                                                // 0x0010 (size: 0x1)
    float m_fIndicatorsThickness;                                                     // 0x0014 (size: 0x4)
    float m_fTransitionThickness;                                                     // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FReplayTimelineTimeDilationContext
{
    TArray<FReplayTimelineTimeDilationData> m_Transitions;                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FReplayTimelineTimeDilationData
{
    FVector2D m_vStartPosition;                                                       // 0x0010 (size: 0x8)
    FVector2D m_vEndPosition;                                                         // 0x0018 (size: 0x8)
    bool m_bTransitionVisible;                                                        // 0x0020 (size: 0x1)
    TArray<float> m_IndicatorDilatedTimes;                                            // 0x0028 (size: 0x10)
    float m_fTimeDilation;                                                            // 0x0058 (size: 0x4)

}; // Size: 0x60

struct FReplayVoiceReplication
{
    ECharacterGender m_eGender;                                                       // 0x0000 (size: 0x1)
    FName m_VoiceArchetypeSwitchName;                                                 // 0x0004 (size: 0x8)
    FName m_VoiceVariationSwitchName;                                                 // 0x000C (size: 0x8)

}; // Size: 0x14

struct FReplicatedBoxSphereBounds
{
    bool m_bIsValid;                                                                  // 0x0000 (size: 0x1)
    FBoxSphereBounds m_Bounds;                                                        // 0x0004 (size: 0x1C)

}; // Size: 0x20

struct FReplicatedDamageEvent
{
    FVector m_vHurtOrigin;                                                            // 0x0000 (size: 0xC)
    float m_fDemoTimeS;                                                               // 0x000C (size: 0x4)
    float m_fBaseDamage;                                                              // 0x0010 (size: 0x4)
    float m_fDamageRadius;                                                            // 0x0014 (size: 0x4)
    float m_fImpulseStrength;                                                         // 0x0018 (size: 0x4)
    bool m_bFullDamage;                                                               // 0x001C (size: 0x1)

}; // Size: 0x20

struct FReplicatedDestructibleChunks
{
    TArray<FTransform> m_ChunkTransforms;                                             // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FReplicatedSequencerAnimMontage
{
    int32 m_iMontageId;                                                               // 0x0000 (size: 0x4)
    class UAnimSequenceBase* m_AnimSequence;                                          // 0x0008 (size: 0x8)
    uint8 m_uiCinematicSlot;                                                          // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FReplicatedSequencerAnimMontagePosition
{
    int32 m_iMontageId;                                                               // 0x0000 (size: 0x4)
    float m_fPosition;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FRetrieveLostItemStruct
{
    class UBaseItemData* m_ItemOwned;                                                 // 0x0000 (size: 0x8)
    class UBaseItemData* m_ItemToGetIfOwned;                                          // 0x0008 (size: 0x8)
    bool m_bCheckReciprocity;                                                         // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FRotationAnimContainer
{
    FAnimContainer m_Anims;                                                           // 0x0000 (size: 0x48)

}; // Size: 0x48

struct FSCAITicketEnum : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FSCAITriggerableActionsArray
{
    TArray<class USCAITriggerableActions*> m_Actions;                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSCAnimNode_AimIK : public FAnimNode_SkeletalControlBase
{
    TArray<FBoneIK> mIKBoneChain;                                                     // 0x00C8 (size: 0x10)
    FName mSocketNameToTransform;                                                     // 0x00D8 (size: 0x8)
    FVector mvTargetPosition;                                                         // 0x00E0 (size: 0xC)
    float mfMinDistanceRatio;                                                         // 0x00EC (size: 0x4)
    float mfMaxDistanceRatio;                                                         // 0x00F0 (size: 0x4)
    FBoneReference mBoneAnimTargetted;                                                // 0x00F4 (size: 0x10)
    bool mbUseDirectWorldPositionForHitTarget;                                        // 0x0104 (size: 0x1)
    FVector mvHitTargetPosition;                                                      // 0x0108 (size: 0xC)
    uint8 muiNbIterations;                                                            // 0x0114 (size: 0x1)
    float mfAbsoluteAngleTolerance;                                                   // 0x0118 (size: 0x4)
    bool mbDebugActivated;                                                            // 0x011C (size: 0x1)
    EAimIKSolverType meIKSolverType;                                                  // 0x011D (size: 0x1)

}; // Size: 0x230

struct FSCAnimNode_CCDIK : public FAnimNode_CCDIK
{
    FName mSaveBone;                                                                  // 0x0180 (size: 0x8)
    FVector mvEffectorComponentSpaceOffset;                                           // 0x0188 (size: 0xC)
    bool mbMirror;                                                                    // 0x0194 (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x0198 (size: 0x8)

}; // Size: 0x220

struct FSCAnimNode_ComputeVariableWeight : public FAnimNode_Base
{
    FPoseLink mBasePose;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSCAnimNode_MirrorPose : public FAnimNode_Base
{
    FPoseLink mBasePose;                                                              // 0x0010 (size: 0x10)
    bool mbMirrorAnimation;                                                           // 0x0020 (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSCAnimNode_MultiVariableWeightBlender : public FAnimNode_Base
{
    TArray<FPoseLink> VariableWeightPoses;                                            // 0x0010 (size: 0x10)
    TArray<FVariableWeightEnumHandler> Layers;                                        // 0x0020 (size: 0x10)
    bool bFullOverrideAlpha;                                                          // 0x0030 (size: 0x1)
    bool bFullOverrideMirrorAlpha;                                                    // 0x0031 (size: 0x1)
    float fMirrorOverrideAlpha;                                                       // 0x0034 (size: 0x4)
    bool bMute;                                                                       // 0x0038 (size: 0x1)

}; // Size: 0xC8

struct FSCAnimNode_PlayAnim : public FAnimNode_SequencePlayer
{
    bool mbMirrorAnimation;                                                           // 0x0090 (size: 0x1)
    int32 miAnimSubStateID;                                                           // 0x0094 (size: 0x4)
    uint8 muiTransitionGlobalType;                                                    // 0x0098 (size: 0x1)
    uint8 muiOrderID;                                                                 // 0x0099 (size: 0x1)
    bool mbIgnoreOrderID;                                                             // 0x009A (size: 0x1)
    bool mbUseStartCursor;                                                            // 0x009B (size: 0x1)
    float mfStartCursor;                                                              // 0x009C (size: 0x4)
    bool mbIgnoreTimeAccumulator;                                                     // 0x00A0 (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x00A8 (size: 0x8)
    bool mbRecordedForReplay;                                                         // 0x00B0 (size: 0x1)

}; // Size: 0xB8

struct FSCAnimNode_PlayBlendSpace : public FAnimNode_BlendSpacePlayer
{
    bool mbMirrorAnimation;                                                           // 0x00F8 (size: 0x1)
    int32 miAnimSubStateID;                                                           // 0x00FC (size: 0x4)
    uint8 muiTransitionGlobalType;                                                    // 0x0100 (size: 0x1)
    uint8 muiOrderID;                                                                 // 0x0101 (size: 0x1)
    bool mbIgnoreOrderID;                                                             // 0x0102 (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x0108 (size: 0x8)

}; // Size: 0x110

struct FSCAnimNode_RotationOffsetBlendSpace : public FAnimNode_BlendSpacePlayer
{
    FPoseLink BasePose;                                                               // 0x00F8 (size: 0x10)
    int32 LODThreshold;                                                               // 0x0108 (size: 0x4)
    float Alpha;                                                                      // 0x010C (size: 0x4)
    FInputScaleBias AlphaScaleBias;                                                   // 0x0110 (size: 0x8)
    FInputAlphaBoolBlend AlphaBoolBlend;                                              // 0x0118 (size: 0x48)
    FName AlphaCurveName;                                                             // 0x0160 (size: 0x8)
    FInputScaleBiasClamp AlphaScaleBiasClamp;                                         // 0x0168 (size: 0x30)
    EAnimAlphaInputType AlphaInputType;                                               // 0x019C (size: 0x1)
    bool bAlphaBoolEnabled;                                                           // 0x019D (size: 0x1)
    bool mbMirrorAnimation;                                                           // 0x019F (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x01A0 (size: 0x8)

}; // Size: 0x1A8

struct FSCAnimNode_SaveBoneTransform : public FAnimNode_Base
{
    FPoseLink mBasePose;                                                              // 0x0010 (size: 0x10)
    FBoneReference mBone;                                                             // 0x0020 (size: 0x10)
    ECoordinateSystem meTransformSpace;                                               // 0x0040 (size: 0x1)
    bool mbMirror;                                                                    // 0x0041 (size: 0x1)
    class UMirrorAnimDB* mMirrorAnimDB;                                               // 0x0048 (size: 0x8)

}; // Size: 0x50

struct FSCAnimNode_SaveBoneTransformByEnum : public FSCAnimNode_SaveBoneTransform
{
    ESaveBone meSaveBone;                                                             // 0x0050 (size: 0x1)

}; // Size: 0x60

struct FSCAnimNode_SaveBoneTransformByName : public FSCAnimNode_SaveBoneTransform
{
    FName mSaveBone;                                                                  // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FSCAnimNode_SetVariableWeightLayers : public FAnimNode_Base
{
    FPoseLink mBasePose;                                                              // 0x0010 (size: 0x10)
    TArray<FVariableWeightLayerToBoneMask> mVariableWeightLayerToBoneMaskRuntime;     // 0x0020 (size: 0x10)
    FVariableWeightInfo mVariableWeightLayerToBoneMaskFromOrderDB;                    // 0x0030 (size: 0x20)
    TArray<FVariableWeightLayerToBoneMask> mFillerLayers;                             // 0x0050 (size: 0x10)
    TArray<FVariableWeightLayerToBoneMask> mVariableWeightLayerToBoneMask;            // 0x0060 (size: 0x10)
    float mBlendTimeWhenSwitchingProfile;                                             // 0x0070 (size: 0x4)
    ESCBlendType mBlendModeWhenSwitchingProfile;                                      // 0x0074 (size: 0x1)
    TArray<FVariableWeightLayerToBoneMask> m_PrevVariableWeightLayerToBoneMaskRuntime; // 0x00B0 (size: 0x10)

}; // Size: 0xD0

struct FSCAnimNode_VariableWeightBlender : public FAnimNode_Base
{
    FPoseLink mMasterPose;                                                            // 0x0010 (size: 0x10)
    FPoseLink mVariableWeightPose;                                                    // 0x0020 (size: 0x10)
    FSCUserDefinedEnumHandler mLayer;                                                 // 0x0030 (size: 0x50)
    bool mbMeshSpaceBlend;                                                            // 0x0080 (size: 0x1)
    bool mbFullOverrideAlpha;                                                         // 0x0081 (size: 0x1)
    float mfLayerOverrideAlpha;                                                       // 0x0084 (size: 0x4)
    bool mbFullOverrideMirrorAlpha;                                                   // 0x0088 (size: 0x1)
    float mfMirrorOverrideAlpha;                                                      // 0x008C (size: 0x4)
    bool mbMute;                                                                      // 0x0090 (size: 0x1)

}; // Size: 0x98

struct FSCAnimNotifyExtraInfo
{
    bool m_bMirrorAnim;                                                               // 0x0000 (size: 0x1)
    int32 m_iSubAnimState;                                                            // 0x0004 (size: 0x4)
    uint8 m_uiTransitionGlobalType;                                                   // 0x0008 (size: 0x1)
    uint8 m_uiOrderID;                                                                // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FSCAnimOrderServiceSettings
{
    TSubclassOf<class UOrderService> m_OrderService;                                  // 0x0000 (size: 0x8)
    bool m_bDisable;                                                                  // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FSCBoneMask
{
}; // Size: 0x68

struct FSCConditionnalAnimContainer
{
    FAnimContainer m_animContainer;                                                   // 0x0000 (size: 0x18)
    TArray<FBaseActorConditionInstance> m_Conditions;                                 // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSCConditionnalGestureAndBlendProfile
{
    EFidgetMirroringTypes m_eMirrorWithQuadrantHandling;                              // 0x0000 (size: 0x1)
    FSCGestureAndBlendProfile m_animContainer;                                        // 0x0008 (size: 0x38)
    EQuadrantTypes m_eQuadrant;                                                       // 0x0040 (size: 0x1)
    TArray<FBaseActorConditionInstance> m_Conditions;                                 // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FSCDeathAnimTypeEnum : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FSCFloatRange
{
    float m_fMin;                                                                     // 0x0000 (size: 0x4)
    float m_fMax;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSCGameplayAbilityActivationInfo
{
    FGameplayAbilitySpecHandle m_Handle;                                              // 0x0000 (size: 0x4)
    FSCGameplayAbilityActorInfo m_ActorInfos;                                         // 0x0008 (size: 0x48)
    FGameplayAbilityActivationInfo m_ActivationInfo;                                  // 0x0050 (size: 0x18)
    FGameplayEventData m_EventData;                                                   // 0x0068 (size: 0xB0)
    class UAbilityPayload* m_Payload;                                                 // 0x0118 (size: 0x8)
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0120 (size: 0x8)

}; // Size: 0x128

struct FSCGameplayAbilityActorInfo : public FGameplayAbilityActorInfo
{
}; // Size: 0x48

struct FSCGameplayAbilityTargetData : public FGameplayAbilityTargetData
{
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSCImpostorForSave
{
    FName m_PoolName;                                                                 // 0x0000 (size: 0x8)
    TSoftObjectPtr<USkeletalMesh> m_ImpostorSkeletalMesh;                             // 0x0008 (size: 0x28)
    FTransform m_Transform;                                                           // 0x0030 (size: 0x30)
    FName m_StreamLevelName;                                                          // 0x0060 (size: 0x8)
    FName m_VoiceArchetypeSwitchName;                                                 // 0x0068 (size: 0x8)
    ECharacterGender m_eGender;                                                       // 0x0070 (size: 0x1)
    FName m_VoiceVariationSwitchValue;                                                // 0x0074 (size: 0x8)

}; // Size: 0x80

struct FSCInt32Range
{
    int32 m_iMin;                                                                     // 0x0000 (size: 0x4)
    int32 m_iMax;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSCRangeFloatCurve
{
    FFloatRange m_Range;                                                              // 0x0000 (size: 0x10)
    bool m_bUseCurve;                                                                 // 0x0010 (size: 0x1)
    class UCurveFloat* m_CurveMax;                                                    // 0x0018 (size: 0x8)
    class UCurveFloat* m_CurveMin;                                                    // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSCWuguanUserEnumSetting
{
    FSoftObjectPath m_Enum;                                                           // 0x0000 (size: 0x18)
    TSoftClassPtr<USCUserDefinedEnumBinding> m_Bindings;                              // 0x0018 (size: 0x28)

}; // Size: 0x40

struct FSafeZoneBonePair
{
    FName m_bone1;                                                                    // 0x0000 (size: 0x8)
    FName m_bone2;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSaveAdditionalInfos
{
    int32 m_iAge;                                                                     // 0x0000 (size: 0x4)
    ECharacterGender m_eGender;                                                       // 0x0004 (size: 0x1)
    FName m_MapTag;                                                                   // 0x0008 (size: 0x8)
    EGameDifficulty m_eDifficulty;                                                    // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSaveGameInputMappingKeySlot
{
    EVirtualAction m_eVirtualAction;                                                  // 0x0000 (size: 0x4)
    TArray<FName> m_Actions;                                                          // 0x0008 (size: 0x10)
    TArray<FSaveInputAxisKeyMapping> m_Axis;                                          // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSaveInputAxisKeyMapping
{
    FName m_Key;                                                                      // 0x0000 (size: 0x8)
    float m_fScale;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FScreenTextureData
{
    TSoftObjectPtr<UTexture2D> m_Texture;                                             // 0x0000 (size: 0x28)
    FText m_DisplayText;                                                              // 0x0028 (size: 0x18)
    FVector2D m_vSize;                                                                // 0x0040 (size: 0x8)
    FVector2D m_vMargin;                                                              // 0x0048 (size: 0x8)
    FVector2D m_vUV;                                                                  // 0x0050 (size: 0x8)
    FVector2D m_vUVSize;                                                              // 0x0058 (size: 0x8)
    FLinearColor m_TintColor;                                                         // 0x0060 (size: 0x10)
    TEnumAsByte<EBlendMode> m_eBlendMode;                                             // 0x0070 (size: 0x1)
    float m_fScale;                                                                   // 0x0074 (size: 0x4)
    bool m_bScalePosition;                                                            // 0x0078 (size: 0x1)
    float m_fRotation;                                                                // 0x007C (size: 0x4)
    FVector2D m_vRotationPivot;                                                       // 0x0080 (size: 0x8)

}; // Size: 0x88

struct FSequenceBinding
{
    FName m_RoleName;                                                                 // 0x0000 (size: 0x8)
    TSoftObjectPtr<AActor> m_Actor;                                                   // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSequenceCheckPointData
{
    float m_fPlayBackPosition;                                                        // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSetVariableWeightInfo
{
    FName m_Name;                                                                     // 0x0000 (size: 0x8)
    bool m_bBlendOut;                                                                 // 0x0008 (size: 0x1)
    bool m_bOverride;                                                                 // 0x0009 (size: 0x1)
    float m_fOverrideDuration;                                                        // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSkillFilter
{
    ENullableCondition m_eAcquired;                                                   // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FSkillTreeNode
{
    FName m_Socket;                                                                   // 0x0000 (size: 0x8)
    TSubclassOf<class USkillGameplayEffect> m_Skill;                                  // 0x0008 (size: 0x8)
    class USkillsChilds* m_Childs;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSkinToneGender
{
    class UMaterialInterface* m_SkinTones;                                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSlotEquipmentValues
{
    TMap<class EGearRarity, class FEquipmentValues> m_EquipmentsValues;               // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSocialRequestInfo
{
}; // Size: 0x14

struct FSocketIK : public FBoneIK
{
}; // Size: 0xE0

struct FSortMethodData
{
    FText m_Name;                                                                     // 0x0000 (size: 0x18)

}; // Size: 0x18

struct FSoundMoodMeleeState
{
    int32 m_iMeleeDifficultyLevel;                                                    // 0x0010 (size: 0x4)
    bool m_bIsFightActive;                                                            // 0x0014 (size: 0x1)
    TWeakObjectPtr<class AAISituationActor> m_AiSituation;                            // 0x0018 (size: 0x8)
    TWeakObjectPtr<class AAISituationActor> m_LastEncounteredSituation;               // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSoundMoodState
{
    ESoundMoodGameplayState m_eGameplayState;                                         // 0x0000 (size: 0x1)
    int32 m_iLevel;                                                                   // 0x0004 (size: 0x4)
    FSoundMoodMeleeState m_meleeState;                                                // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSoundReplicationData
{
}; // Size: 0xA0

struct FSoundStateInfo
{
    uint32 m_uiStateValue;                                                            // 0x0000 (size: 0x4)
    bool m_bReplicates;                                                               // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSoundTensionThreat
{
    TArray<class AAISituationActor*> m_AiSituations;                                  // 0x0000 (size: 0x10)
    int32 m_iBehaviorsMask;                                                           // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSpawnerGroupLayer
{
    int32 m_iLevelMin;                                                                // 0x0000 (size: 0x4)
    int32 m_iLevelMax;                                                                // 0x0004 (size: 0x4)
    bool m_bFixedSituation;                                                           // 0x0008 (size: 0x1)
    TArray<class AAISpawner*> m_Spawners;                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSpawnerGroupSoundData
{
    float m_FightStateOffDelay;                                                       // 0x0000 (size: 0x4)
    TArray<int32> m_MeleeStateLvlSplits;                                              // 0x0008 (size: 0x10)
    TArray<int32> m_MeleeDangerLvlSplits;                                             // 0x0018 (size: 0x10)
    float m_MeleeFightStateOffDelay;                                                  // 0x0028 (size: 0x4)
    int32 m_iMeleeThreshold;                                                          // 0x002C (size: 0x4)
    bool m_bIsThreatEnabled;                                                          // 0x0030 (size: 0x1)
    TArray<class ASpawnerGroup*> m_DependantGroups;                                   // 0x0038 (size: 0x10)
    TArray<class AAISituationActor*> m_DependantSituations;                           // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FSpawnerPerZone
{
    TWeakObjectPtr<class AAISpawner> m_Spawner;                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSpawningClassContainer
{
    TSubclassOf<class ABaseCharacter> m_SpawningClass;                                // 0x0000 (size: 0x8)
    FName m_ImpostorCustomName;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSpecialAbilityDelayedLayer
{
    class UAvailabilityLayerData* m_PushLayerOnSuccess;                               // 0x0000 (size: 0x8)
    float m_fPushLayerDelay;                                                          // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSpeedDescriptionStruct
{
    float m_fBaseSpeed;                                                               // 0x0040 (size: 0x4)
    float m_fOverrAll;                                                                // 0x0044 (size: 0x4)
    float m_fPlayRate;                                                                // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FSpeedState
{
    bool m_bV0;                                                                       // 0x0000 (size: 0x1)
    bool m_bV1;                                                                       // 0x0001 (size: 0x1)
    bool m_bV2;                                                                       // 0x0002 (size: 0x1)
    bool m_bV3;                                                                       // 0x0003 (size: 0x1)
    ESpeedState m_eSpeedState;                                                        // 0x0004 (size: 0x1)

}; // Size: 0x5

struct FSpeedStateAnimContainer
{
    FAnimContainer m_Anims;                                                           // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FSpeedStateBlendDescription
{
    float m_BlendTime;                                                                // 0x0000 (size: 0x4)
    class UCurveFloat* m_BlendCurve;                                                  // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSpeedStateBlendTo
{
    FSpeedStateBlendDescription m_BlendDescription;                                   // 0x0000 (size: 0x40)

}; // Size: 0x40

struct FSpeedStateFromGoalDistSelector
{
    ESpeedState m_eNearFromGoalSpeedState;                                            // 0x0000 (size: 0x1)
    float m_fDistToGoalThresold;                                                      // 0x0004 (size: 0x4)
    ESpeedState m_eFarFromGoalSpeedState;                                             // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSpeedTransitionsAnimContainer
{
    FCardinalChangementAnimContainer m_Start_FL;                                      // 0x0000 (size: 0x180)
    FCardinalAnimContainer m_Stop_FL;                                                 // 0x0180 (size: 0x60)
    FOrientedRotationAnimContainer m_UTurn;                                           // 0x01E0 (size: 0x90)
    FCardinalAnimContainer m_Strafe;                                                  // 0x0270 (size: 0x60)

}; // Size: 0x2D0

struct FStarUnlockConditionClassInstance
{
    TSubclassOf<class UStarUnlockCondition> m_DefaultClassObject;                     // 0x0000 (size: 0x8)
    class UStarUnlockCondition* m_Instance;                                           // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FStateWeight
{
    float m_fTargetWeight;                                                            // 0x0000 (size: 0x4)
    float m_fInDuration;                                                              // 0x0004 (size: 0x4)
    float m_fOutDuration;                                                             // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FStructureBrokenReaction : public FBaseFightingStateBehavior
{
    float m_fDuration;                                                                // 0x0010 (size: 0x4)
    FAnimContainer m_Loop;                                                            // 0x0018 (size: 0x18)
    bool m_bMirrorableLoop;                                                           // 0x0030 (size: 0x1)
    float m_fGuardCoefRecoveredAtEnd;                                                 // 0x0034 (size: 0x4)
    float m_fGuardRecoveredAtEnd;                                                     // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FSubZoneShortcutStruct
{
    bool m_bIsAShortCut;                                                              // 0x0000 (size: 0x1)
    int32 m_iZone;                                                                    // 0x0004 (size: 0x4)
    int32 m_iSubZone;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSuperDizzyReaction
{
    float m_fMandatoryDuration;                                                       // 0x0000 (size: 0x4)
    float m_fMaxAccumulatedDamage;                                                    // 0x0004 (size: 0x4)
    int32 m_iMaxAccumatedHits;                                                        // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSwapperStructBase
{
    bool m_bInProgress1Or2;                                                           // 0x0050 (size: 0x1)
    bool m_bInProgress1;                                                              // 0x0051 (size: 0x1)
    bool m_bInProgress2;                                                              // 0x0052 (size: 0x1)

}; // Size: 0x60

struct FTargetEvaluationDBInstance
{
    TSubclassOf<class UBaseTargetEvaluation> m_DefaultClassObject;                    // 0x0000 (size: 0x8)
    class UBaseTargetEvaluation* m_Instance;                                          // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FTargetEvaluationSettings
{
    FTargetEvaluationDBInstance m_TargetEvaluationInstance;                           // 0x0000 (size: 0x10)
    float m_fRange;                                                                   // 0x0010 (size: 0x4)
    bool m_bMute;                                                                     // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FTargetForSlotsEnumHandler : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FTargetResult
{
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x0000 (size: 0x8)
    uint8 m_uiPriority;                                                               // 0x0008 (size: 0x1)
    EActionType m_eActionType;                                                        // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FTargetSettings
{
    float m_fUpdateFrequency;                                                         // 0x0000 (size: 0x4)
    TArray<class UEvaluateTargetCondition*> m_Conditions;                             // 0x0008 (size: 0x10)
    TArray<FTargetEvaluationSettings> m_Evaluations;                                  // 0x0018 (size: 0x10)
    FString m_DebugConsoleVariable;                                                   // 0x0028 (size: 0x10)
    ETargetingPrio m_eDebugConsoleVariableMinTargettingPrio;                          // 0x0038 (size: 0x1)
    FColor m_DebugActionColor;                                                        // 0x003C (size: 0x4)

}; // Size: 0x40

struct FTargetableConditions
{
    TMap<class ETargetingPrio, class FFloatRange> m_Ranges;                           // 0x0000 (size: 0x50)
    TArray<class UEvaluateTargetCondition*> m_Conditions;                             // 0x0050 (size: 0x10)
    TArray<class TSubclassOf<UEvaluateTargetCondition>> m_ClassConditions;            // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FTargetableFactions
{
    uint8 m_TargetableFactions;                                                       // 0x0000 (size: 0x6)

}; // Size: 0x6

struct FTensionVolumesContainer
{
    TArray<TWeakObjectPtr<ASoundTensionVolume>> m_overlappedTensionVolumes;           // 0x0000 (size: 0x10)
    TMap<class TWeakObjectPtr<ASoundTensionPortal>, class bool> m_TensionPortalsCrossed; // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FTimelineChangeState
{
    int32 m_iKeyCountChange;                                                          // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FTimerAndOffset
{
    float m_fTime;                                                                    // 0x0000 (size: 0x4)
    float m_fOffset;                                                                  // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTintData
{
    FText m_Name;                                                                     // 0x0000 (size: 0x18)
    FLinearColor m_inventoryIconColor;                                                // 0x0018 (size: 0x10)
    FLinearColor m_dyeIconColor;                                                      // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FTrackingPayloadActivateTimedMetric
{
    int64 offsetPlaytime;                                                             // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FTrackingPayloadChallenges
{
    FString m_sChallengeName;                                                         // 0x0000 (size: 0x10)
    int32 m_iHighScore;                                                               // 0x0010 (size: 0x4)
    uint8 m_uiNumberStars;                                                            // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FTrackingPayloadEmpty
{
}; // Size: 0x1

struct FTrackingPayloadOptions
{
    FString Theme;                                                                    // 0x0000 (size: 0x10)
    int32 HighCont;                                                                   // 0x0010 (size: 0x4)
    FString HUDDisplay;                                                               // 0x0018 (size: 0x10)
    int32 HUDSize;                                                                    // 0x0028 (size: 0x4)
    int32 sub;                                                                        // 0x002C (size: 0x4)
    int32 subOpacity;                                                                 // 0x0030 (size: 0x4)
    FString GameInput;                                                                // 0x0038 (size: 0x10)
    FString remapProfile;                                                             // 0x0048 (size: 0x10)
    FString InputPress;                                                               // 0x0058 (size: 0x10)
    int32 HideVFX;                                                                    // 0x0068 (size: 0x4)
    int32 CameraShake;                                                                // 0x006C (size: 0x4)
    int32 HudFraming;                                                                 // 0x0070 (size: 0x4)
    int32 BlinkingEffect;                                                             // 0x0074 (size: 0x4)
    FString AudioOut;                                                                 // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FTrackingPayloadStartPlaying
{
    FString m_AudioLanguage;                                                          // 0x0000 (size: 0x10)
    FString m_TextLanguage;                                                           // 0x0010 (size: 0x10)
    FString m_Platform;                                                               // 0x0020 (size: 0x10)
    FString ver;                                                                      // 0x0030 (size: 0x10)
    FString difficulty;                                                               // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FTrackingPayloadStopTimedMetric
{
    int64 offsetPlaytime;                                                             // 0x0000 (size: 0x8)
    FString Type;                                                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FTrackingPayloadWithInt
{
    int64 m_Int;                                                                      // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FTrackingPayloadWithText
{
    FString m_Text;                                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FTransitionRequest
{
    ESpeedState m_eInSpeedState;                                                      // 0x0000 (size: 0x1)
    ESCCardinalPoints m_eInCardinalPoint;                                             // 0x0001 (size: 0x1)
    ESpeedState m_eOutSpeedState;                                                     // 0x0002 (size: 0x1)
    ESCCardinalPoints m_eOutCardinalPoint;                                            // 0x0003 (size: 0x1)
    ETransitionRotation m_eVelocityRotation;                                          // 0x0004 (size: 0x1)
    float m_fAbsVelocityAngle;                                                        // 0x0008 (size: 0x4)
    bool m_bIsRotationLeft;                                                           // 0x000C (size: 0x1)

}; // Size: 0x10

struct FTraversalAnimContainer
{
    FAnimContainer m_AnimEntry;                                                       // 0x0000 (size: 0x18)
    FAnimContainer m_AnimLoop;                                                        // 0x0018 (size: 0x18)
    FAnimContainer m_AnimPreExit;                                                     // 0x0030 (size: 0x18)
    FAnimContainer m_AnimExitLoop;                                                    // 0x0048 (size: 0x18)
    FAnimContainer m_AnimLanding;                                                     // 0x0060 (size: 0x18)
    bool m_bHandleDamageOnAnimLanding;                                                // 0x0078 (size: 0x1)

}; // Size: 0x80

struct FTraversalAxisConstraint
{
    ESimpleAxis m_eAxis;                                                              // 0x0000 (size: 0x1)
    ESimpleAxisSide m_eForbiddenAxisSide;                                             // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FTraversalComponentMargin
{
    float m_fNegAxisMargin;                                                           // 0x0000 (size: 0x4)
    float m_fPosAxisMargin;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTraversalInfo
{
    TWeakObjectPtr<class UTraversalComponent> m_traversalComponent;                   // 0x0000 (size: 0x8)
    FVector m_vTraversalStartPos;                                                     // 0x0008 (size: 0xC)
    FVector m_vTraversalEndPos;                                                       // 0x0014 (size: 0xC)
    float m_fTraversalLength;                                                         // 0x0020 (size: 0x4)
    float m_fTraversalHeight;                                                         // 0x0024 (size: 0x4)
    ETraversalEntryType m_eEntryType;                                                 // 0x0028 (size: 0x1)
    ECharacterTraversalType m_eType;                                                  // 0x0029 (size: 0x1)
    bool m_bClimbWithFence;                                                           // 0x002A (size: 0x1)
    TWeakObjectPtr<class UTraversalComponent> m_TraversalFenceOnTop;                  // 0x002C (size: 0x8)
    bool m_bTraversalOnStaticMesh;                                                    // 0x0034 (size: 0x1)
    FHitResult m_FirstImpactOnTraversal;                                              // 0x0038 (size: 0x8C)
    bool m_bValidStartPos;                                                            // 0x00C4 (size: 0x1)

}; // Size: 0xC8

struct FTraversalInputBehavior
{
    bool m_bUseCharacterVelocityInsteadOfDirOnStick;                                  // 0x0000 (size: 0x1)
    float m_fMaxAngleBetweenVelocityAndStickDir;                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTraversalTypeSettings
{
    float m_fEntryAngleAllowance;                                                     // 0x0000 (size: 0x4)
    float m_fExitAngleClampValue;                                                     // 0x0004 (size: 0x4)
    float m_fMinTraversalDist;                                                        // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FTurnAnimation
{
    FAnimContainer m_animContainer;                                                   // 0x0000 (size: 0x18)
    ESCRotationWay m_eRotationWay;                                                    // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FTurnAnimationArray
{
    TArray<FTurnAnimation> m_TurnAnimations;                                          // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FTutorialDataRow : public FTableRowBase
{
    FName m_Name;                                                                     // 0x0008 (size: 0x8)
    FText m_Title;                                                                    // 0x0010 (size: 0x18)
    FText m_Subtitle;                                                                 // 0x0028 (size: 0x18)
    TArray<FInputTutorialStruct> m_Inputs;                                            // 0x0040 (size: 0x10)
    FText m_Description;                                                              // 0x0050 (size: 0x18)
    FText m_Details;                                                                  // 0x0068 (size: 0x18)
    bool m_bIsUnlockedByDefault;                                                      // 0x0080 (size: 0x1)
    bool m_bIsUnlockable;                                                             // 0x0081 (size: 0x1)

}; // Size: 0x88

struct FTutorialUnlockStruct
{
    ETutorialUnlockState m_eUnlockState;                                              // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FUOrderParamsClassInstance
{
    TSubclassOf<class UOrderParams> m_DefaultClassObject;                             // 0x0000 (size: 0x8)
    class UOrderParams* m_Instance;                                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FUOrderParamsInstanceStruct
{
    class UOrderParams* m_Instance;                                                   // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FUsableWeaponInfo
{
    TSubclassOf<class UWeaponGameplayData> m_weaponGameplayData;                      // 0x0000 (size: 0x8)
    TMap<class TSubclassOf<ABaseWeapon>, class TSubclassOf<UBaseWeaponData>> m_WeaponAnimInfos; // 0x0008 (size: 0x50)

}; // Size: 0x58

struct FVariableWeightActivation
{
}; // Size: 0x38

struct FVariableWeightEnumHandler : public FSCUserDefinedEnumHandler
{
}; // Size: 0x50

struct FVariableWeightInfo
{
    TArray<FVariableWeightLayerToBoneMask> m_layers;                                  // 0x0000 (size: 0x10)
    TArray<FVariableWeightLayerToBoneMask> m_pendingDelete;                           // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FVariableWeightLayerToBoneMask
{
    FSCUserDefinedEnumHandler m_LayerEnum;                                            // 0x0000 (size: 0x50)
    class UBlendProfile* m_BoneMask;                                                  // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FVitalPointDataDefinition
{
    FName m_BoneToAttachBillboard;                                                    // 0x0000 (size: 0x8)
    bool m_bOnWeapon;                                                                 // 0x0008 (size: 0x1)
    class UVitalPointData* m_VitalPointData;                                          // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FVoiceOver
{
    TSoftObjectPtr<ULevelSequence> m_AudioSequence;                                   // 0x0000 (size: 0x28)
    TArray<FText> m_Lines;                                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FVoiceVariationsAkSwitchContainer
{
    TArray<FName> m_VoiceVariationsSwitchValues;                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FVolumesArray
{
    TArray<class ASCVolume*> m_Volumes;                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FWeaponAnimInfo : public FAssociatedPropsAnimInfo
{
    EWeaponAnimType m_eWeaponAnimType;                                                // 0x0008 (size: 0x1)
    class UAnimationAsset* m_weaponAnimAssociated;                                    // 0x0010 (size: 0x8)
    class UBlendSpaceBase* m_weaponBlendSpaceAssociated;                              // 0x0018 (size: 0x8)
    TMap<class FString, class FWeaponBlendSpaceParam> m_weaponBlendSpaceParam;        // 0x0020 (size: 0x50)
    class UCurveFloat* m_playRateCurve;                                               // 0x0070 (size: 0x8)
    EWeaponBlendSpaceComputeTime m_eBlendSpaceComputeTime;                            // 0x0078 (size: 0x1)
    EWeaponOrientationConstraint m_eOrientationConstraint;                            // 0x0079 (size: 0x1)

}; // Size: 0x90

struct FWeaponBlendSpaceParam
{
    EBlendSpaceParamComputeType m_eBlendSpaceParamComputeType;                        // 0x0000 (size: 0x1)
    FFloatRange m_customRange;                                                        // 0x0004 (size: 0x10)
    FName m_DistanceRefBone;                                                          // 0x0014 (size: 0x8)
    FName m_DistanceTargetBone;                                                       // 0x001C (size: 0x8)
    FVector m_vDistanceOffset;                                                        // 0x0024 (size: 0xC)

}; // Size: 0x30

struct FWeaponOverrideInfo : public FBaseWeaponOverrideInfo
{
    class UAIContextualDefense* m_ContextualDefenseOverride;                          // 0x0018 (size: 0x8)
    TArray<FComboOverride> m_ComboOverrides;                                          // 0x0020 (size: 0x10)
    TSubclassOf<class UAvoidAbility> m_AvoidAbility;                                  // 0x0030 (size: 0x8)
    class UBaseMovementDB* m_MovementDB;                                              // 0x0038 (size: 0x8)
    bool m_bActivateAttackTicketFactorsOverride;                                      // 0x0040 (size: 0x1)
    TMap<EAIWuguanTicketEvaluation, float> m_AttackTicketEvaluationFactorsOverride;   // 0x0048 (size: 0x50)
    bool m_bActivateCirclePerCombatRoleOverride;                                      // 0x0098 (size: 0x1)
    TMap<ESCAICombatRoles, int32> m_CirclePerCombatRolesOverride;                     // 0x00A0 (size: 0x50)
    bool m_bOverrideLocomotionPaceSelector;                                           // 0x00F0 (size: 0x1)
    FLocomotionPaceSelector m_OverridingLocomotionPaceSelector;                       // 0x00F4 (size: 0x24)

}; // Size: 0x118

struct FWeaponShopDataRow : public FTableRowBase
{
    class UBaseItemData* m_Weapon;                                                    // 0x0008 (size: 0x8)
    int32 m_iGMLevelRequired;                                                         // 0x0010 (size: 0x4)
    int32 m_iGleamLevelRequired;                                                      // 0x0014 (size: 0x4)
    int32 m_iFragmentPrice;                                                           // 0x0018 (size: 0x4)
    int32 m_iPrestigePointPrice;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FWeaponSituationDescription
{
    int32 m_iLevelMin;                                                                // 0x0000 (size: 0x4)
    int32 m_iLevelMax;                                                                // 0x0004 (size: 0x4)
    TArray<class UVisibleWeaponData*> m_WeaponsData;                                  // 0x0008 (size: 0x10)
    uint32 m_uiAppearanceProbabilities;                                               // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FWeaponVisuals
{
    TSoftObjectPtr<USkeletalMesh> m_SkeletalMesh;                                     // 0x0000 (size: 0x28)
    TArray<TSoftObjectPtr<UMaterialInterface>> m_Materials;                           // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FWidgetPoolElement
{
    class USCUserWidget* m_Widget;                                                    // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FWidgetPoolElementArray
{
    TArray<FWidgetPoolElement> m_Array;                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FWidgetPoolEntryTemplate
{
    FSCUserDefinedEnumHandler m_LayerEnum;                                            // 0x0000 (size: 0x50)
    TSubclassOf<class USCUserWidget> m_WidgetClass;                                   // 0x0050 (size: 0x8)
    int32 m_iNumberOfInstances;                                                       // 0x0058 (size: 0x4)

}; // Size: 0x60

struct FreeMoveAnimQuadrant
{
    FBlendSpaceDirectionContainer m_FreeMoveBlendSpace;                               // 0x0000 (size: 0x20)

}; // Size: 0x20

class AAIDirectorActor : public AActor
{
    FAIDirectorActorOnGlobalBehaviorsChanged OnGlobalBehaviorsChanged;                // 0x02B0 (size: 0x10)
    void GlobalBehaviorChanged(EGlobalBehaviors EGlobalBehaviors);
    FAIDirectorActorOnAIDeathDetected OnAIDeathDetected;                              // 0x02C0 (size: 0x10)
    void OnAIDeathDetected(const class AFightingCharacter* _AICharacter, const FDamageInfos& _damageInfos);
    FAIDirectorActorOnDifficultyLevelChanged OnDifficultyLevelChanged;                // 0x02D0 (size: 0x10)
    void DynamicMulticast();

    void OnAIDeathDetected__DelegateSignature(const class AFightingCharacter* _AICharacter, const FDamageInfos& _damageInfos);
    void GlobalBehaviorChanged__DelegateSignature(EGlobalBehaviors EGlobalBehaviors);
    void BPF_UnbindFromAlertLevelChanged(FBPF_UnbindFromAlertLevelChangedDelegate Delegate);
    void BPF_RemoveGlobalAlertLevelThreshold(FName _name);
    EAlertLevel BPF_GlobalAlertLevel();
    EAlertLevel BPF_GetAlertLevel();
    void BPF_GetAIsForEnemy(const class AActor* _enemyActor, ESCAICombatRoles _eCombatRole, TArray<class AActor*>& _AICharactersOutArray);
    void BPF_BindToAlertLevelChanged(FBPF_BindToAlertLevelChangedDelegate Delegate);
    void BPF_AddGlobalAlertLevelThreshold(EAlertLevel _eLevel, EAlertLevelThreshold _eType, FName _name);
    void BPE_OnSituationDeactivated(const class AAISituationActor* _situationActor);
    void BPE_OnSituationActivated(const class AAISituationActor* _situationActor);
    void BPE_OnSafeSanctuaryBarkTrigger(const class AFightingCharacter* _Enemy);
    void BPE_OnMCDominationChanged(EMcDominationGaugeSteps _NewStep);
    void BPE_OnLastManPhaseStarted(const class UAIFightingComponent* _aiComponent);
    void BPE_OnGlobalBehaviorChanged(const class UAIFightingComponent* _aiComponent, EGlobalBehaviors _NewBehavior, EAlertedReason _AlertedReason, bool _SkipBark);
    void BPE_OnEnemyRevival(class ABaseCharacter* _Enemy);
    void BPE_OnEnemyPickedWeapon(const class AFightingCharacter* _Enemy);
    void BPE_OnEnemyOrderStateChanged(const class AFightingCharacter* _Enemy, EOrderType _OrderType, EOrderState _OrderState);
    void BPE_OnEnemyFightingStateChanged(EFightingState _eFightingState, bool _bPushed);
    void BPE_OnEnemyDeathDetected(const class AFightingCharacter* _Enemy, const FDamageInfos& _damageInfos);
    void BPE_OnCombatRolesChanged(ESCAICombatRolesChangeReason _eReason);
    void BPE_OnAIDeathDetected(const class AFightingCharacter* _AICharacter, const FDamageInfos& _damageInfos);
    void BPE_OnAIActionExecute(const class UAIFightingComponent* _aiComponent, const class USCAiAction* _AIAction);
    bool BPE_CanAICharacterSpeak(const class AFightingCharacter* Character);
    void AlertLevelChangedMulticastDynamic__DelegateSignature(EAlertLevel EAlertLevel);
    void AlertLevelChanged__DelegateSignature(EAlertLevel EAlertLevel);
}; // Size: 0x490

class AAISanctuaryVolume : public ASCVolume
{
    class UAISanctuaryComponent* m_SanctuaryComponent;                                // 0x0368 (size: 0x8)

    void OnSanctuaryAssignmentUpdated();
    void OnAlertLevelChanged(EAlertLevel _eNewLevel);
}; // Size: 0x390

class AAISituationActor : public AActor
{
    FAISituationActorOnSituationActivated OnSituationActivated;                       // 0x02B0 (size: 0x10)
    void AISituationDynamicMulticastDelegate(class AAISituationActor* SituationChanged);
    FAISituationActorOnSituationResolved OnSituationResolved;                         // 0x02C0 (size: 0x10)
    void AISituationDynamicMulticastDelegate(class AAISituationActor* SituationChanged);
    FAISituationActorOnAnyAiBehaviorChanged OnAnyAiBehaviorChanged;                   // 0x02D0 (size: 0x10)
    void AISituationGlobalBehaviorChangedDynamic(class AAISituationActor* SituationChanged, const class UAIFightingComponent* AI, EGlobalBehaviors NewBehavior);
    FAISituationActorOnSituationSpawnedDynamic OnSituationSpawnedDynamic;             // 0x02E0 (size: 0x10)
    void AISituationDynamicMulticastDelegate(class AAISituationActor* SituationChanged);
    FAISituationActorOnAISpawned OnAISpawned;                                         // 0x0320 (size: 0x10)
    void EventWithCharacterDynamic(class ABaseCharacter* _character);
    FAISituationActorOnAIDeath OnAIDeath;                                             // 0x0330 (size: 0x10)
    void EventWithCharacterDynamic(class ABaseCharacter* _character);
    bool m_bHasActiveLDVisibilityOverride;                                            // 0x0340 (size: 0x1)
    class USCSaveGameComponent* m_SaveComponent;                                      // 0x0360 (size: 0x8)
    TArray<class ASpawnerGroup*> m_AssociatedSpawnerGroups;                           // 0x0368 (size: 0x10)
    TArray<class ALockableDoor*> m_AssociatedLockableDoors;                           // 0x0378 (size: 0x10)
    TArray<class AActor*> m_PositioningPOIs;                                          // 0x0388 (size: 0x10)
    bool m_bIsLastManAllowed;                                                         // 0x0398 (size: 0x1)
    bool m_bForceLastMan;                                                             // 0x0399 (size: 0x1)
    int32 m_iMinKillBeforeLastMan;                                                    // 0x039C (size: 0x4)
    int32 m_iLastManGaugeIncrementValue;                                              // 0x03A0 (size: 0x4)
    int32 m_iLastManMaxOccuranceCount;                                                // 0x03A4 (size: 0x4)
    FSpawnerGroupSoundData m_SoundData;                                               // 0x03A8 (size: 0x58)
    bool m_bRepeatBarksWhenExhausted;                                                 // 0x0400 (size: 0x1)
    bool m_bEnableMaxImpostorsLimit;                                                  // 0x0401 (size: 0x1)
    TArray<FName> m_SpawnerGroupClearedPathName;                                      // 0x0408 (size: 0x10)
    TArray<FSCImpostorForSave> m_ImpostorToSpawnOnSaveLoaded;                         // 0x0418 (size: 0x10)
    bool m_bSpawnRequestedOnSaveLoaded;                                               // 0x0428 (size: 0x1)
    int32 m_iCurrentLastManOccuranceCount;                                            // 0x042C (size: 0x4)
    bool m_bAutoSpawnedOnSaveLoaded;                                                  // 0x0430 (size: 0x1)
    EGlobalBehaviors m_eBehaviorToSetOnSpawn;                                         // 0x0431 (size: 0x1)
    TWeakObjectPtr<class AActor> m_targetForHostileBehaviorsOnSpawn;                  // 0x0434 (size: 0x8)

    void OnUpdatedFromSaveCallback();
    void EventWithCharacterDynamic__DelegateSignature(class ABaseCharacter* _character);
    FAISituationNamedActor Conv_NameToAISituationNamedActor(FName _name);
    void BPF_UnSpawnSituation();
    void BPF_SwitchToFriendly(bool _bFriendly);
    void BPF_SwitchToAbandoning();
    void BPF_SpawnSituation(EGlobalBehaviors _eBehaviorToSetOnSpawn, class AActor* _targetForHostileBehaviors, bool _bForce, bool _bSkipBark);
    int32 BPF_GetSpawnersUsedCount(bool _bIncludeAlerted, bool _bOnlyCurrentlyUsed);
    void BPF_GetSpawnersUsed(TArray<class AAISpawner*>& _outSpawners, bool _bIncludeAlerted, bool _bOnlyCurrentlyUsed);
    void BPF_GetSpawnerGroupsUsed(TArray<class ASpawnerGroup*>& _outSpawnerGroups);
    class AActor* BPF_GetNamedActor(const FAISituationNamedActor& _namedActor);
    EGlobalBehaviors BPF_GetBehaviorOverride();
    int32 BPF_GetAis(TArray<class UAIFightingComponent*>& _outAiComponents, bool _bIncludeAlertedSpawners, bool _bAppendToArray, bool _bIncludeAbandonningAIs);
    void BPF_EnableHitOnAI(bool _bEnable);
    void BPF_ChangeAiPerception(bool _bActivate);
    bool BPF_AreAllSpawnerGroupsCleared();
    void BPF_AddNamedActor(class AActor* _actor, FName _name);
    void BPE_UpdateLDVisibilityOverride(bool _bVisibility);
    void BPE_OnStartAIPhaseChanged(class AFightingCharacter* _fightingChar, const FAIPhaseTransitionData& _phaseTransition);
    void BPE_OnInteractiveDialogInterrupted();
    void BPE_OnEndAIPhaseChanged(class AFightingCharacter* _fightingChar, int32 _iPreviousPhaseIndex, int32 _iCurrentPhaseIndex, FName _currentPhaseName);
    void BPE_OnAIPhaseChangeSequenceFinished(class AFightingCharacter* _fightingChar, const FAIPhaseTransitionData& _phaseTransition);
    void BPE_OnAIFightingStateChanged(class AFightingCharacter* _fightingChar, EFightingState _ePreviousFightingState, EFightingState _eNewFightingState);
    void AlertLevelChangedCallback(EAlertLevel _eNewLevel);
    void AISituationGlobalBehaviorChangedDynamic__DelegateSignature(class AAISituationActor* SituationChanged, const class UAIFightingComponent* AI, EGlobalBehaviors NewBehavior);
    void AISituationDynamicMulticastDelegate__DelegateSignature(class AAISituationActor* SituationChanged);
}; // Size: 0x490

class AAISpawner : public AActor
{
    FAISpawnerAIDownDelegateMulticast AIDownDelegateMulticast;                        // 0x02C8 (size: 0x10)
    void AIDownDynamic(class AAISpawner* Spawner);
    FAISpawnerAISpawnedDynamicDelegate AISpawnedDynamicDelegate;                      // 0x02D8 (size: 0x10)
    void AISpawnedDynamic(class ABaseCharacter* SpawnedCharacter);
    FAISpawnerOnPatrolCompleted OnPatrolCompleted;                                    // 0x0300 (size: 0x10)
    void AIPatrolCompleted(class UAIFightingComponent* AI, class APathPatrol* Patrol);
    FAISpawnerOnGenericDialogEvent OnGenericDialogEvent;                              // 0x0310 (size: 0x10)
    void GenericDialogEventDelegate(FName EventTriggered);
    FAISpawnerOnDialogCompleted OnDialogCompleted;                                    // 0x0320 (size: 0x10)
    void DynamicMulticast();
    FAISpawnerOnDialogCut OnDialogCut;                                                // 0x0330 (size: 0x10)
    void DynamicMulticast();
    FAISpawnerOnLineEnded OnLineEnded;                                                // 0x0340 (size: 0x10)
    void DialogLineEvent(int32 DialogNodeId);
    FAISpawnerOnGlobalBehaviorChanged OnGlobalBehaviorChanged;                        // 0x0350 (size: 0x10)
    void AICharacterGlobalBehaviorChanged(class ABaseCharacter* Character, EGlobalBehaviors NewBehavior);
    FAICharacterSpawnParams m_SpawnParams;                                            // 0x0360 (size: 0x58)
    FSCAiActionClassInstance m_SpawnAction;                                           // 0x03B8 (size: 0x10)
    TSubclassOf<class ABaseCharacter> m_SpawningClass;                                // 0x03C8 (size: 0x8)
    bool m_bForcedPreFightLookAtTarget;                                               // 0x03D0 (size: 0x1)
    class AActor* m_ForcedPreFightLookAtTarget;                                       // 0x03D8 (size: 0x8)
    class APathPatrol* m_pathPatrol;                                                  // 0x03E0 (size: 0x8)
    EPatrolLaunchMethod m_ePatrolLaunchMethod;                                        // 0x03E8 (size: 0x1)
    class UAIPhaseScenario* m_PhaseScenarios;                                         // 0x03F0 (size: 0x18)
    class UAIPhaseScenario* m_PhaseScenario;                                          // 0x0408 (size: 0x8)
    EFactionsEnums m_eFaction;                                                        // 0x0414 (size: 0x1)
    float m_fRespawnTime;                                                             // 0x0418 (size: 0x4)
    float m_fSpawnDelay;                                                              // 0x041C (size: 0x4)
    bool m_bCanRespawn;                                                               // 0x0420 (size: 0x1)
    bool m_bLowStructureOnSpawn;                                                      // 0x0421 (size: 0x1)
    bool m_bIsLoneWolf;                                                               // 0x0422 (size: 0x1)
    int32 m_iSoundTensionLevelOverride;                                               // 0x0424 (size: 0x4)
    FName m_VoiceVariationSwitchOverride;                                             // 0x0428 (size: 0x8)
    int32 m_iChargesToAddWhenKilled;                                                  // 0x0430 (size: 0x4)
    int32 m_iDeathCounterDecreaseWhenKilled;                                          // 0x0434 (size: 0x4)
    bool m_bDeathCounterResetWhenKilled;                                              // 0x0438 (size: 0x1)
    EFirstSpawnMethod m_eFirstSpawnMethod;                                            // 0x0448 (size: 0x1)
    bool m_bAllowPerceptionInstantOnSpawn;                                            // 0x0449 (size: 0x1)
    class USceneComponent* m_RootComp;                                                // 0x0450 (size: 0x8)
    TArray<FCarriedProps> m_carriedProps;                                             // 0x0458 (size: 0x10)
    TSubclassOf<class ABaseWeapon> m_carriedWeapon;                                   // 0x0468 (size: 0x8)
    FName m_CarriedWeaponPoolName;                                                    // 0x0470 (size: 0x8)
    bool m_bKeepIdleAnimDuringAlertedDialogs;                                         // 0x0478 (size: 0x1)
    TArray<FIdleAnimAndTransition> m_IdleAndExitAnimation;                            // 0x04D8 (size: 0x10)
    class UAIIdleDB* m_AIIdleDB;                                                      // 0x04E8 (size: 0x8)
    FAnimContainer m_AlertedAnimation;                                                // 0x04F0 (size: 0x18)
    TSubclassOf<class ABaseCharacter> m_EditorClass;                                  // 0x0508 (size: 0x8)
    class UAIPhaseScenario* m_PhaseScenarioOverride;                                  // 0x0510 (size: 0x8)
    TArray<float> m_rawCustomPrimitiveData;                                           // 0x0518 (size: 0x10)

    void OnAiBehaviorChanged(EGlobalBehaviors _eNewBehavior, const bool _bFromDialog);
    bool IsSpawnerBusy();
    TSubclassOf<class ABaseWeapon> GetCarriedWeapon();
    void BPF_WantsSpawn();
    void BPF_UnSpawnAIDelayed();
    void BPF_StartAssociatedPatrolOnSpawnedAI();
    void BPF_SetSpawningClass(TSubclassOf<class ABaseCharacter> _class);
    void BPF_SetPhaseScenario(class UAIPhaseScenario* _scenario);
    void BPF_SetForceSpawnerBusy(bool _bSpawnerBusy);
    void BPF_SetCanRespawn(bool _canRespawn);
    bool BPF_HasSpawnedAI();
    TSubclassOf<class ABaseCharacter> BPF_GetSpawningClass();
    class ABaseCharacter* BPF_GetSpawnedAI();
    FName BPF_GetCarriedWeaponPoolName();
    TArray<FCarriedProps> BPF_GetCarriedProps();
    void BPF_AskForRespawn();
    void BPE_OnRespawnFinished(class AActor* _ActorAIRespawned);
    void BPE_OnIADown(class AActor* _ActorAI);
    void AISpawnedDynamic__DelegateSignature(class ABaseCharacter* SpawnedCharacter);
    void AIPatrolCompleted__DelegateSignature(class UAIFightingComponent* AI, class APathPatrol* Patrol);
    void AIDownDynamic__DelegateSignature(class AAISpawner* Spawner);
    void AICharacterGlobalBehaviorChanged__DelegateSignature(class ABaseCharacter* Character, EGlobalBehaviors NewBehavior);
}; // Size: 0x530

class AAIWaveRefillDirector : public ASCActor
{
    TArray<TSoftObjectPtr<AAIWaveSpawner>> m_WaveSpawners;                            // 0x02D8 (size: 0x10)
    FAIWaveRefillDirectorOnWaveCompleteDelegate OnWaveCompleteDelegate;               // 0x02E8 (size: 0x10)
    void OnWaveRelatedEvent(int32 _iWaveIndex);
    FAIWaveRefillDirectorOnWaveStartedDelegate OnWaveStartedDelegate;                 // 0x02F8 (size: 0x10)
    void OnWaveRelatedEvent(int32 _iWaveIndex);
    FAIWaveRefillDirectorOnWaveRelatedSituationComplete OnWaveRelatedSituationComplete; // 0x0308 (size: 0x10)
    void OnWaveRelatedSituationComplete(int32 _iWaveIndex, class AAISituationActor* _relatedSituationActor);
    FAIWaveRefillDirectorOnWaveAndSituationComplete OnWaveAndSituationComplete;       // 0x0318 (size: 0x10)
    void OnWaveAndSituationComplete(int32 _iWaveIndex);
    FAIWaveRefillDirectorOnWaveAIDeath OnWaveAIDeath;                                 // 0x0328 (size: 0x10)
    void OnWaveAIDeath(const class AFightingCharacter* _FightingCharacter, EAIArchetype _eArchetype);

    void OnWaveRelatedSituationComplete__DelegateSignature(int32 _iWaveIndex, class AAISituationActor* _relatedSituationActor);
    void OnWaveRelatedEvent__DelegateSignature(int32 _iWaveIndex);
    void OnWaveAndSituationComplete__DelegateSignature(int32 _iWaveIndex);
    void OnWaveAIDeath__DelegateSignature(const class AFightingCharacter* _FightingCharacter, EAIArchetype _eArchetype);
    void OnSituationAIDeathDetected(class ABaseCharacter* _character);
    void OnRelatedSituationActivated(class AAISituationActor* _aiSituationActor);
    void OnAIDownDetected(class AAISpawner* _spawner);
    void OnAIAbandonDetected(class AActor* _actor);
    void BPF_StartWaveByName(FName _WaveName);
    void BPF_StartWave(int32 _iWaveIndex);
    void BPF_StartNextWave();
    void BPF_SetRefillEnabled(bool _bRequestImmediateRefill);
    void BPF_SetRefillDisabled();
    bool BPF_IsWaveInProgress();
    int32 BPF_GetAIRemainingInCurrentWave();
    void BPF_CancelCurrentWave();
    void BPE_OnWaveStarted(int32 _iWaveIndex);
    void BPE_OnWavesSequenceComplete();
    void BPE_OnWaveComplete(int32 _iWaveIndex);
    void BPE_OnRelatedAISituationComplete(int32 _iWaveIndex, class AAISituationActor* _situationActor);
    void BPE_OnRefillSequenceStarted(int32 _iCurrentWaveIndex, const TArray<EAIArchetype>& _spawnRequests);
    void BPE_OnRefillSequenceEnded(int32 _iCurrentWaveIndex);
}; // Size: 0x4F0

class AAIWaveSpawner : public AAISpawner
{
    int32 m_iArchetypesMask;                                                          // 0x0530 (size: 0x4)
    FGameplayTag m_WaveTag;                                                           // 0x0534 (size: 0x8)
    EGlobalBehaviors m_eGlobalBehaviorAtSpawn;                                        // 0x053C (size: 0x1)
    bool m_bAllowSpawnWhileVisible;                                                   // 0x053D (size: 0x1)
    bool m_bHasPriorityIfVisible;                                                     // 0x053E (size: 0x1)

    void BPF_SetArchetypeToSpawn(EAIArchetype _eArchetype);
}; // Size: 0x540

class AAimingBillboardActor : public ASCActor
{
    FAimingBillboardActorOnSelectionChangedDyn OnSelectionChangedDyn;                 // 0x02D8 (size: 0x10)
    void OnSelectionChangedDyn(bool _bSelected, class AAimingBillboardActor* aimingBillboard);
    class UBoxComponent* m_BoxComponent;                                              // 0x0300 (size: 0x8)
    bool m_bDebug;                                                                    // 0x0308 (size: 0x1)

    void OnSelectionChangedDyn__DelegateSignature(bool _bSelected, class AAimingBillboardActor* aimingBillboard);
    float BPF_GetScore();
    class AActor* BPF_GetActorOwner();
    FVector2D BPE_ComputeSize();
    float BPE_ComputeScore(FVector _v3DPointToTest);
}; // Size: 0x320

class AArenaGameMode : public AThePlainesGameMode
{
    FArenaGameModeOnPlayerPressStart OnPlayerPressStart;                              // 0x0450 (size: 0x10)
    void OnPlayerPressStart();
    float m_fEndArenaDelay;                                                           // 0x0460 (size: 0x4)

    void OnPlayerPressStart__DelegateSignature();
    void BPF_TriggerEndArena();
    void BPF_PlayerPressStart();
    void BPF_FlagArenaForRestart();
}; // Size: 0x490

class AArenaGameState : public AThePlainesGameState
{
}; // Size: 0x3B0

class AArenaHardpointAreaActor : public AActor
{
    FArenaHardpointAreaActorOnScoreMultiplierChanged OnScoreMultiplierChanged;        // 0x02B0 (size: 0x10)
    void DynamicMulticast();
    FArenaHardpointAreaActorOnEnemyPresenceInsideHardpointChanged OnEnemyPresenceInsideHardpointChanged; // 0x02C0 (size: 0x10)
    void DynamicMulticast();
    FArenaHardpointAreaActorOnScoreDecreaseStarted OnScoreDecreaseStarted;            // 0x02D0 (size: 0x10)
    void DynamicMulticast();
    FArenaHardpointAreaActorOnScoreDecreaseEnded OnScoreDecreaseEnded;                // 0x02E0 (size: 0x10)
    void DynamicMulticast();
    FText m_HardpointAreaName;                                                        // 0x0308 (size: 0x18)
    TArray<class ASCVolume*> m_ChildrenVolumes;                                       // 0x0320 (size: 0x10)
    bool m_bIsActive;                                                                 // 0x0330 (size: 0x1)
    float m_fCurrentScoreMultiplier;                                                  // 0x0334 (size: 0x4)
    bool m_bIsAnyEnemyInsideHardpoint;                                                // 0x0338 (size: 0x1)
    class USceneComponent* m_RootComponent;                                           // 0x0340 (size: 0x8)
    TMap<class AFightingCharacter*, class FVolumesArray> m_overlappedVolumesPerEnemy; // 0x0388 (size: 0x50)

    void UpdateVolumeBounds();
    void OnOverlappingEnemyDown(class UCharacterHealthComponent* _healthComponent, EDownState _eState);
    void OnHardpointSituationResolved(class AAISituationActor* _situationChanged);
    void OnChildComponentStartOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    void OnChildComponentEndOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex);
    TArray<class ASCVolume*> GetAreaVolumes();
    bool BPF_IsScoreDecreasing();
    bool BPF_IsPlayerCapturing();
    bool BPF_HasBeenCaptured();
    bool BPF_GetIsActive();
    FText BPF_GetHardpointAreaName();
    float BPF_GetCurrentCaptureRatio();
    float BPF_GetCaptureValue();
    FName BPF_GetAreaName();
    void BPF_ForceCapture();
    void BPE_OnStopCapturing();
    void BPE_OnStartCapturing(float _CurrentScore);
    void BPE_OnScoreCaptureValueChanged(float _fCurrentValue, float _fMaxValue);
    void BPE_OnReactivate();
    void BPE_OnHardpointCaptured();
    void BPE_OnDeactivate();
    void BPE_OnActivate();
    float BFF_GetCurrentCaptureScore();
}; // Size: 0x410

class ABaseBreakable : public AActor
{
    class UBoxComponent* m_ProximityBoxCreatePhysics;                                 // 0x02B0 (size: 0x8)
    class UReplayableDestructibleComponent* m_ReplayableDestructibleComponent;        // 0x02B8 (size: 0x8)
    class UReplayablePhysObjectComponent* m_ReplayablePhysObjectComponent;            // 0x02C0 (size: 0x8)
    class UPhysicalActorDependencyComponent* m_PhysicalActorDependencyComponent;      // 0x02C8 (size: 0x8)
    class USCStreamingActorComponent* m_StreamingComponent;                           // 0x02D0 (size: 0x8)
    FSCCollisionResponsePreset m_editorBoxCollisionPreset;                            // 0x02D8 (size: 0x30)
    uint64 m_uiActionStateDestroyableByMask;                                          // 0x0308 (size: 0x8)
    uint64 m_uiAIActionStateDestroyableByMask;                                        // 0x0310 (size: 0x8)
    bool m_bFilterByActionStateOnOverlap;                                             // 0x0318 (size: 0x1)
    bool m_bFilterByActionStateOnHit;                                                 // 0x0319 (size: 0x1)
    bool m_bFilterByResistanceIfMatchActionStateOnHit;                                // 0x031A (size: 0x1)
    bool m_bFilterByResistanceIfDontMatchActionStateOnHit;                            // 0x031B (size: 0x1)
    bool m_bDestroyableByThrowable;                                                   // 0x031C (size: 0x1)
    uint32 m_uiThrowableStateDestroyableByMask;                                       // 0x0320 (size: 0x4)
    float m_fDestructionVelocityRef;                                                  // 0x0324 (size: 0x4)
    bool m_bExecuteFractureOnce;                                                      // 0x0328 (size: 0x1)
    bool m_bHasBeenFracturedOnce;                                                     // 0x0329 (size: 0x1)
    float m_fMinDamageRadius;                                                         // 0x032C (size: 0x4)
    float m_fActionStateImpulseStrength;                                              // 0x0330 (size: 0x4)
    float m_fPhysicImpulseStrength;                                                   // 0x0334 (size: 0x4)
    float m_fPhysicRightCursor;                                                       // 0x0338 (size: 0x4)
    float m_fThrowableImpulseStrength;                                                // 0x033C (size: 0x4)
    bool m_bPlayBounceSfx;                                                            // 0x0340 (size: 0x1)
    FName m_BounceRTPC;                                                               // 0x0344 (size: 0x8)
    TMap<float, UAkAudioEvent*> m_PerImpulseBounceSfxs;                               // 0x0350 (size: 0x50)
    class AActor* m_DestructionCauser;                                                // 0x03A0 (size: 0x8)
    float m_fProximityCreatePhysicsOffset;                                            // 0x03A8 (size: 0x4)

    void OnWakeStateChanged(bool _bIsAwake);
    void OnPendingDamageReceived(const FVector& _vHitPoint, const FVector& _vHitDirection);
    void OnOverlapEndProximityBoxCreatePhysics(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex);
    void OnOverlapBeginProximityBoxCreatePhysics(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    void OnComponentStartOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    void OnComponentEndOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex);
    void BPF_UnbindOverlap();
    void BPF_SetDamageable(bool _bInDamageable);
    void BPF_EngageDestructionCausedByActor(class AActor* _inCauser, float _fInImpulseStrength);
    void BPF_EngageDestruction(const FVector& _vInHurtOrigin, float _fRadius, float _fInImpulseStrength);
    float BPE_GetRTPCValue();
    float BPE_GetMassOverride();
    float BPE_GetHitResistance();
}; // Size: 0x450

class ABaseCharacter : public ASCCharacter
{
    class USocialComponent* m_SocialComponent;                                        // 0x0850 (size: 0x8)
    class UOrderComponent* m_OrderComponent;                                          // 0x0858 (size: 0x8)
    class UCharacterTextLipSync* m_LipSyncComp;                                       // 0x0860 (size: 0x8)
    int32 m_iBuildUpMaxShrinkingFrames;                                               // 0x0868 (size: 0x4)
    class USkinTonesDB* m_SkinTones;                                                  // 0x0910 (size: 0x8)
    TArray<FDynamicMaterialsPerType> m_DynamicMaterialsPerFxType;                     // 0x0960 (size: 0x10)
    class USCDialogComponent* m_DialogComponent;                                      // 0x0970 (size: 0x8)

    void OnLandedRaw(const FHitResult& _Impact);
    void OnCapsuleBeginOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    bool IsDead();
    void BPF_UpdateDynamicMaterials(TArray<FDynamicMaterialInput> _ParametersInputs);
    void BPF_SetVectorValueOnMaterials(FName _parameterName, FLinearColor _value);
    void BPF_SetScalarValueOnMaterials(FName _parameterName, float _fValue);
    void BPF_SetGenderInSave(ECharacterGender _eNewGender, bool _bSendTrackingData);
    void BPF_SetGenderInProfile(ECharacterGender _eNewGender);
    bool BPF_PopAvailabilityLayer(int32 _iId, InputContext _eInputContext);
    bool BPF_IsCurrentGameModeCoopAlly(class AActor* _otherActor);
    bool BPF_IsAvailable(InputAction _eAction);
    class USocialComponent* BPF_GetSocialComponent();
    ERelationshipTypes BPF_GetRelationship(class AActor* _actor);
    class UOrderComponent* BPF_GetOrderComponent();
    ECharacterGender BPF_GetGenderInSave();
    TArray<class UMaterialInstanceDynamic*> BPF_GetCurrentMaterialInstances();
    EControllerNature BPF_GetControllerNature();
    void BPF_CreateDynamicMaterials(EFXMaterials _eFxType, bool _bFromItemLoading);
    void BPE_PlayerStateInitialized(class APlayerState* _playerState);
    void BPE_ControllerReplicated(class APlayerController* _controller);
    void BPE_BodyPartsUpdated();
}; // Size: 0x9A0

class ABaseCharacterImpostor : public ASCCharacterImpostor
{
    ESCSignificanceBuckets m_eMoanMinBucket;                                          // 0x0378 (size: 0x1)
    class UAkAudioEvent* m_MoanEvent;                                                 // 0x0380 (size: 0x8)
    TArray<FAkExternalSourceInfo> m_MoanExternalSourceInfos;                          // 0x0388 (size: 0x10)
    class UAkRtpc* m_MoanIntensityRTPC;                                               // 0x0398 (size: 0x8)
    FName m_MoanIntensityRTPCName;                                                    // 0x03A0 (size: 0x8)
    float m_fMoanInterpolationInMs;                                                   // 0x03A8 (size: 0x4)
    class UCurveFloat* m_AngleFromCameraForwardRemappingCurve;                        // 0x03B0 (size: 0x8)
    FName m_MoanRefBoneName;                                                          // 0x03B8 (size: 0x8)
    float m_MoanIntensityThresold;                                                    // 0x03C0 (size: 0x4)

}; // Size: 0x3D0

class ABaseReplayController : public ASCPlayerController
{
    bool m_bFixedSpectatorMode;                                                       // 0x0818 (size: 0x1)
    InputContext m_eMainInputContext;                                                 // 0x0819 (size: 0x1)
    TSubclassOf<class ASpectatorPawn> m_SpectatorClass;                               // 0x0820 (size: 0x8)
    TSubclassOf<class AReplayHUD> m_HUDClass;                                         // 0x0828 (size: 0x8)
    TSubclassOf<class UReplayMenuWidget> m_MenuClass;                                 // 0x0830 (size: 0x8)
    class UReplayMenuWidget* m_Menu;                                                  // 0x0838 (size: 0x8)
    TMap<class FString, class FString> m_OverrideSoundStates;                         // 0x0840 (size: 0x50)
    class UAvailabilityLayerData* m_AvailabilityDefaultLayerDB;                       // 0x08E0 (size: 0x8)
    TArray<class UAvailabilityLayerData*> m_DefaultAvailabilityLayerContextOverrides; // 0x08E8 (size: 0x10)
    FAvailabilityLayerCache m_SpectatorAvailabilityLayer;                             // 0x08F8 (size: 0x28)
    FAvailabilityLayerCache m_FixedSpectatorAvailabilityLayer;                        // 0x0920 (size: 0x28)
    FAvailabilityLayerCaches m_ConsoleAvailabilityLayers;                             // 0x0948 (size: 0x18)
    TSubclassOf<class UAngleFeedbackUserWidget> m_RollFeedbackClass;                  // 0x0960 (size: 0x8)
    TSubclassOf<class URangeFeedbackUserWidget> m_ZoomFeedbackClass;                  // 0x0968 (size: 0x8)
    TSubclassOf<class UHUDUserWidget> m_SaveGameWidgetClass;                          // 0x0970 (size: 0x8)
    TArray<class TSubclassOf<UMessageFeedbackUserWidget>> m_MessageFeedbackClasses;   // 0x0978 (size: 0x10)
    class UAngleFeedbackUserWidget* m_RollFeedbackInstance;                           // 0x0988 (size: 0x8)
    class URangeFeedbackUserWidget* m_ZoomFeedbackInstance;                           // 0x0990 (size: 0x8)
    class UHUDUserWidget* m_SaveGameWidgetInstance;                                   // 0x0998 (size: 0x8)
    TArray<class UMessageFeedbackUserWidget*> m_MessageFeedbackInstances;             // 0x09A0 (size: 0x10)

    void OnSaveGameStatusChanged(bool _bSaveInProgress, ESaveResult _eSaveResult);
    class AReplayHUD* GetReplayHUD();
    void BPF_ShowMessageFeedback(EMessageReason _eReason);
    void BPF_SetSingleActiveMenu(TScriptInterface<class IHandleInput> _menu);
    bool BPF_PushSpectatorAvailabilityLayer(bool _bUpdateUIMode, bool _bCheckAlreadyPushed);
    void BPF_PushAvailabilityLayers(FAvailabilityLayerCaches& _inOutCacheALs, bool _bCheckIfAlreadyPushed);
    void BPF_PushAvailabilityLayer(FAvailabilityLayerCache& _inOutCacheAL, bool _bCheckIfAlreadyPushed, int32 _iPriority);
    bool BPF_PopSpectatorAvailabilityLayer(bool _bUpdateUIMode, bool _bCheckAlreadyPopped);
    void BPF_PopAvailabilityLayers(FAvailabilityLayerCaches& _inOutCacheALs, bool _bCheckIfAlreadyPopped);
    void BPF_PopAvailabilityLayer(FAvailabilityLayerCache& _inOutCacheAL, bool _bCheckIfAlreadyPopped);
    bool BPF_IsInputActionAvailable(InputAction _eInputAction);
    class UReplayCineCameraComponent* BPF_GetCineCameraComponent();
    void BPF_ForceInputAvailabilityUpdate();
}; // Size: 0xB30

class ABaseWeapon : public AThrowableActor
{
    FBaseWeapon_OnDrop m_OnDrop;                                                      // 0x0790 (size: 0x10)
    void OnDrop(EDropReason _eDropReason);
    TSubclassOf<class UTargetSettingsDB> m_throwFromPickUpTargetSettingsDB;           // 0x07A0 (size: 0x8)
    TSubclassOf<class UBaseWeaponData> m_weaponData;                                  // 0x07A8 (size: 0x8)
    TSubclassOf<class UWeaponGameplayData> m_weaponGameplayData;                      // 0x07B0 (size: 0x8)
    class USkeletalMeshComponent* m_SkeletalMeshComponent;                            // 0x07D8 (size: 0x8)
    class UAnimInstanceReplicationComponent* m_AnimInstanceReplicationComponent;      // 0x07E0 (size: 0x8)
    FName m_EquipmentSocketName;                                                      // 0x07E8 (size: 0x8)
    TWeakObjectPtr<class AFightingCharacter> m_weaponBearer;                          // 0x07F0 (size: 0x8)
    class UAvailabilityLayerData* m_ThrowingFromPickupAvaibilityLayer;                // 0x07F8 (size: 0x8)
    bool m_bAttachedFakie;                                                            // 0x0800 (size: 0x1)
    FFloatRange m_ResourceCooldownRangeValue;                                         // 0x0804 (size: 0x10)
    float m_fWeaponTicketMaxDistance;                                                 // 0x0814 (size: 0x4)
    bool m_bAvailableForIA;                                                           // 0x0818 (size: 0x1)

    void OnDrop__DelegateSignature(EDropReason _eDropReason);
    void BPF_ResetWeaponGameplayData();
    void BPF_ResetWeaponData();
    void BPF_OverrideWeaponGameplayData(TSubclassOf<class UWeaponGameplayData> _newWeaponGameplayData);
    void BPF_OverrideWeaponData(TSubclassOf<class UBaseWeaponData> _newWeaponData);
    class UWeaponGameplayData* BPF_GetWeaponGameplayData();
    class UBaseWeaponData* BPF_GetWeaponData();
    void BPF_DropWeapon(EDropReason _eDropReason);
    void BPF_AttachWeapon(class USkeletalMeshComponent* _charMesh, FName _socketName, bool _bEquipOnOppositeHand, bool _bChangeFakie);
    void BPF_ApplyDamage(EOnDestructibleDamageType _eDamageType, const FVector& _vImpactLocation, float _fCustomDamage, bool _bPlayDropOrderOnDestroy);
    bool BPE_CanUseDamagedWeapon(int32 _iDamagedWeaponIndex);
}; // Size: 0x830

class ACheckPoint : public ASCPlayerStart
{
    class UBoxComponent* m_TriggerCheckpointEnter;                                    // 0x03D8 (size: 0x8)

    void OnBeginOverlap(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    void BPF_SetNewCheckPointInSave();
}; // Size: 0x3E0

class AClusterActor : public ASCActor
{
    TArray<FClusterStruct> m_MeshToThrowable;                                         // 0x02E0 (size: 0x10)
    float m_fTimeBeforeSpawningThrowable;                                             // 0x02F0 (size: 0x4)
    FVector m_vImpulseWhenDestroyed;                                                  // 0x02F4 (size: 0xC)
    bool m_bCanBeTargeted;                                                            // 0x0300 (size: 0x1)
    float m_fSoundNoiseRadius;                                                        // 0x0304 (size: 0x4)

    void BPF_SpawnActorFromMesh();
    void BPF_MakeNoise(class AActor* _noiseSource, FVector _vLocationOverride);
    FVector BPF_GetImpulseVector();
}; // Size: 0x310

class ACustomLightingVolume : public ASCPlayerVolumeNoPhysics
{
    FWuguanCustomLightingUserParameters m_Parameters;                                 // 0x0380 (size: 0x34)

}; // Size: 0x3C0

class AEnvironmentalInteractionZone : public AActor
{
    bool m_bFallEnabled;                                                              // 0x02B0 (size: 0x1)
    bool m_bEnvironmentalTakedownEnabled;                                             // 0x02B1 (size: 0x1)

}; // Size: 0x2C0

class AFightingAIController : public AAIController
{

    void OnPerceptionUpdate(const TArray<class AActor*>& _updatedActors);
    void AiSpawned(class AAISpawner* _spawner);
}; // Size: 0x450

class AFightingCharacter : public ABaseCharacter
{
    FFightingCharacterOnEquipWeapon OnEquipWeapon;                                    // 0x09F0 (size: 0x10)
    void OnEquip(bool _bEquipmentSuccessful);
    FFightingCharacterOnUnequipWeapon OnUnequipWeapon;                                // 0x0A00 (size: 0x10)
    void OnEquip(bool _bEquipmentSuccessful);
    FFightingCharacterOnActorHiddenChanged OnActorHiddenChanged;                      // 0x0A10 (size: 0x10)
    void OnActorHiddenChanged(bool _bActorHidden);
    FFightingCharacterOnAvoidCapsuleHitDynamic OnAvoidCapsuleHitDynamic;              // 0x0A20 (size: 0x10)
    void AvoidCapsuleHitDelegate(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FHitDefenseResult& _defenseResult);
    class UAvailabilityLayerDB* m_availabilityLayerDB;                                // 0x0A30 (size: 0x8)
    FName m_AnimSyncBoneViewPoint;                                                    // 0x0A80 (size: 0x8)
    FFightingCharacterOnKilledSomething OnKilledSomething;                            // 0x0B08 (size: 0x10)
    void KilldDelegate(class AActor* Victim, bool _bIsOnlyAssist, bool _bKillingBlow, class AActor* _Instigator, const FDamageInfos& _damageInfos);
    FFightingCharacterOnAvoidSuccessDynamic OnAvoidSuccessDynamic;                    // 0x0C20 (size: 0x10)
    void OnAvoidSuccessDelegate(FHitRequest _hitRequest, FHitDefenseResult _hitDefenseResult);
    FFightingCharacterOnEffectAddedOrRemoved OnEffectAddedOrRemoved;                  // 0x0C60 (size: 0x10)
    void OnEffectAddedOrRemoved(bool _bAdded, class UEffectData* _effectData);
    FFightingCharacterOnRecoveryFromDamageDealt OnRecoveryFromDamageDealt;            // 0x0C70 (size: 0x10)
    void OnRecoveryFromDamageDealt(float _fHealAmount);
    FFightingCharacterOnResilienceChanged OnResilienceChanged;                        // 0x0C80 (size: 0x10)
    void OnResilienceChanged(int32 _iNewResilience);
    FFightingCharacterOnLanding OnLanding;                                            // 0x0C90 (size: 0x10)
    void DynamicMulticast();
    FFightingCharacterOnFalling OnFalling;                                            // 0x0CA0 (size: 0x10)
    void DynamicMulticast();
    class UCharacterHitBoxComponent* m_PushHitBox;                                    // 0x0CB0 (size: 0x8)
    bool m_bHasJustBeenHitted;                                                        // 0x0CC8 (size: 0x1)
    FHitDescription m_HittedDescription;                                              // 0x0CD0 (size: 0x568)
    bool m_bAllowAutonomousAnimPoseTick;                                              // 0x1238 (size: 0x1)
    class UDefenseComponent* m_DefenseComponent;                                      // 0x1240 (size: 0x8)
    class USCAbilitySystemComponent* m_AbilityComponent;                              // 0x1248 (size: 0x8)
    class UTargetableActorComponent* m_TargetLocation;                                // 0x1250 (size: 0x8)
    class UPhysicalAnimationComponent* m_PhysicalAnimationComponent;                  // 0x1258 (size: 0x8)
    FName m_currentlyAttachedSocket;                                                  // 0x1260 (size: 0x8)
    class UAttackComponent* m_AttackComponent;                                        // 0x12A0 (size: 0x8)
    class UCameraComponentThird* m_Camera;                                            // 0x12A8 (size: 0x8)
    class UBaseWeaponData* m_DefaultHandWeapons;                                      // 0x12B0 (size: 0x8)
    class UBaseWeaponData* m_DefaultLegWeapons;                                       // 0x12B8 (size: 0x8)
    class UHitComponent* m_HitComponent;                                              // 0x12C0 (size: 0x8)
    class UPlayerFightingComponent* m_PlayerComponent;                                // 0x12C8 (size: 0x8)
    class UAIFightingComponent* m_AIComponent;                                        // 0x12D0 (size: 0x8)
    class UCapsuleComponent* m_AvoidCapsule;                                          // 0x12D8 (size: 0x8)
    class UCapsuleComponent* m_HitCapsule;                                            // 0x12E0 (size: 0x8)
    class UCharacterHealthComponent* m_HealthComponent;                               // 0x12E8 (size: 0x8)
    class UMessengerComponent* m_MessengerComponent;                                  // 0x12F0 (size: 0x8)
    class UReplayablePhysicsComponent* m_ReplayablePhysicsComponent;                  // 0x12F8 (size: 0x8)
    class UFightingCharAnimRepComponent* m_FightingCharAnimRepComponent;              // 0x1300 (size: 0x8)
    class UReplayFightingCharacterComponent* m_ReplayFightingCharacterComponent;      // 0x1308 (size: 0x8)
    class UASMComponent* m_ASMComponent;                                              // 0x1310 (size: 0x8)
    class UDeathDB* m_DeathDB;                                                        // 0x1318 (size: 0x8)
    uint8 m_uiTransitionZoneId;                                                       // 0x1320 (size: 0x1)
    float m_fMinHeightForVisbilityTrace;                                              // 0x1328 (size: 0x4)
    float m_fMaxHeightForVisbilityTrace;                                              // 0x132C (size: 0x4)
    float m_PickUpAngle;                                                              // 0x1360 (size: 0x4)
    bool m_bSpawnOccured;                                                             // 0x1380 (size: 0x1)
    bool m_bReceivedSaveFailedCompensation;                                           // 0x1410 (size: 0x1)
    bool m_bCheckInventoryBug1_25;                                                    // 0x1411 (size: 0x1)
    uint8 m_uiPawnCounter;                                                            // 0x1412 (size: 0x1)
    EFactionsEnums m_eFaction;                                                        // 0x14C0 (size: 0x1)
    bool m_bUpdateCollisionProfileOnBeginPlay;                                        // 0x14C1 (size: 0x1)
    class UMaterialParameterCollection* m_MaterialParameterCollectionGameplay;        // 0x14C8 (size: 0x8)
    FName m_asTargetBones;                                                            // 0x14EC (size: 0x18)
    float m_fCapsuleRadiusRatioForThrowableTargetLocation;                            // 0x1504 (size: 0x4)
    FPelvisDirectionComputationParams m_defaultPelvisComputationParams;               // 0x1508 (size: 0x38)
    FFightingCharacterOnRemoveSlapstick OnRemoveSlapstick;                            // 0x1588 (size: 0x10)
    void DynamicMulticast();

    void SetTarget(class AActor* _target);
    void ServerUpdateMovementAnimation();
    void ServerSuicide(bool _bForceUnrevivable);
    void ServerSetFlyMode(bool _bFlyModeActivated);
    void ServerSetFaction(uint8 _uiFaction);
    void ServerPullOutWeapon(const FHandledWeaponInfo& HandledWeaponInfo);
    void RemoveGameplayTag(FString _tag);
    void PushCamera(FString _inCameraName);
    void PopCamera();
    void OnTakingOutWeaponOrderEnded(uint8 _uiOrderId, class UOrderComponent* _orderComp);
    void OnResilienceChanged__DelegateSignature(int32 _iNewResilience);
    void OnRep_TransitionZoneId();
    void OnRecoveryFromDamageDealt__DelegateSignature(float _fHealAmount);
    void OnOrderParryInstigatorStarted(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
    void OnEquip__DelegateSignature(bool _bEquipmentSuccessful);
    void OnEffectAddedOrRemovedInternalCallback(bool _bAdded, class UEffectData* _effectDataAsset);
    void OnEffectAddedOrRemoved__DelegateSignature(bool _bAdded, class UEffectData* _effectData);
    void OnAvoidSuccessDelegate__DelegateSignature(FHitRequest _hitRequest, FHitDefenseResult _hitDefenseResult);
    void OnActorHiddenChanged__DelegateSignature(bool _bActorHidden);
    void MulticastSetFaction(uint8 _uiFaction);
    void MulticastRemoveEffect(class UEffectData* _effectData, int64 _iRemovalTimeTick);
    void MulticastLoadWeaponMesh(const FHandledWeaponInfo& HandledWeaponInfo);
    void MulticastAddEffect(class UEffectData* _effectData, int64 _iStartTimeTick);
    void MulticastActivateRagdoll(bool _bActivate, float _fBlendWeight);
    void KilldDelegate__DelegateSignature(class AActor* Victim, bool _bIsOnlyAssist, bool _bKillingBlow, class AActor* _Instigator, const FDamageInfos& _damageInfos);
    void Hitted(const FHitDescription& _hit);
    void HandleSwapHand(EOrderType _ePreviousOrderType);
    void HandleEndComboForWeapon();
    class AActor* GetTarget();
    class UPlayerFightingComponent* GetPlayerComponent();
    class UPhysicalAnimationComponent* GetPhysicalAnimationComponent();
    class UDefenseComponent* GetDefenseComponent();
    class UAttackComponent* GetAttackComponent();
    class UAIFightingComponent* GetAiComponent();
    void ComboStarted();
    void ClearCameras();
    void BPF_TeleportForce(const FVector& _destLocation, const FRotator& _destRotation, bool bForce, bool _bOnTeleportLocation, ECameraTeleportationRotationBehavior _eCameraRotationBehavior);
    void BPF_TakeOutWeapon();
    void BPF_SwapWeaponHandWithAnim(class AActor* _actorToPickup, uint8 _uiPreviousOrderID);
    void BPF_SpawnFootStepDecal(class UMaterialInterface* _decalMaterial, FVector _vSize, FVector _vLocation, float _fRadius, float _fDuration, FRotator _rotation);
    void BPF_SetIsValidTarget(bool _bIsValidTarget);
    void BPF_SetInvincibility(bool _bIsInvincible);
    void BPF_SetGuardGaugeInfinite(bool _bIsInfinite, bool _bRestoreGauge);
    void BPF_SetFaction(EFactionsEnums _eFaction);
    void BPF_SaveAnimInstanceReference();
    void BPF_RestoreSavedAnimInstance();
    void BPF_ResetOverrideTargetting(FString _targettingToRemove);
    void BPF_ResetInputStack(FString _context);
    int32 BPF_PushAvailabilityLayerContext(InputContext _eInputContext, EALPriority _eALPriority);
    int32 BPF_PushAvailabilityLayer(const class UAvailabilityLayerData* _layer, EALBinaryOperation _eBinaryOperation, InputContext _eContext, EPredictionBehavior _ePredictionBehavior, int32 _iLinkedLayerId, int32 _iPriority, int32 _iALContext);
    void BPF_PopAvailabilityLayerContext(InputContext _eInputContext, int32 _iContextID);
    uint8 BPF_PlayGestureOnCharacter(const FSCGestureContainer& _gestureContainer, bool _bLoop);
    uint8 BPF_PlayGesture(FSCGestureAndBlendProfile _gesture, FSCUserDefinedEnumHandler _variableWeightLayer, bool _bLoop, EFidgetMirroringTypes _eMirrorHandling);
    void BPF_PickUpObject(class AInteractiveMovable* _object, bool _bMirrorPickup);
    void BPF_OverrideTargetting(FString _targettingToOverride);
    void BPF_NotifyTeleport(bool _bOnTeleportLocation, ECameraTeleportationRotationBehavior _eCameraRotationBehavior);
    void BPF_MulticastRemoveEffect(class UEffectData* _effectData, float _fPredictionTime);
    void BPF_MulticastAddEffect(class UEffectData* _effectData, float _fPredictionTime);
    void BPF_LaunchImpact(float _fDamage, bool _bLethal, float _fStunTime);
    bool BPF_IsInvicible();
    bool BPF_IsGuardGaugeInfinite();
    bool BPF_IsGetUpDone();
    bool BPF_IsDown();
    bool BPF_IsBestActionAvailable(InputAction _eAction);
    bool BPF_IsActorInAttackRange(const class AActor* _actor);
    bool BPF_HasWeaponEquipped(class ABaseWeapon*& _outWeaponEquipped, bool _bIgnoreUnusableWeapon);
    bool BPF_HasValidTarget();
    class UStatsComponent* BPF_GetStatsComponent();
    class USkeletalMeshComponent* BPF_GetSkeletalMeshEquipment(EEquipmentSlot _eEquipmentSlot);
    class ABaseWeapon* BPF_GetPickedUpWeapon();
    class AInteractiveMovable* BPF_GetPickedUpObject();
    FVector BPF_GetLeftStickDirection(bool _bFallbackToCameraDir);
    class UHitComponent* BPF_GetHitComponent();
    float BPF_GetHeightFromFeet(const FVector& _vLocToCheck);
    class UCharacterHealthComponent* BPF_GetHealthComponent();
    FVector BPF_GetDirToTarget(bool _bCanUseCamera, const class AActor* _specifiedTarget, bool _bFallbackToDefaultTarget);
    class UDeathDB* BPF_GetDeathDB();
    EDangerStates BPF_GetDangerState();
    int32 BPF_GetCurrentTotalResilience();
    class UCameraComponentThird* BPF_GetCameraThird();
    class UActorComponent* BPF_GetBPComponent(EFightingCharacterBPComponents _eComponent);
    class UASMComponent* BPF_GetASMComponent();
    class UPlayerAnim* BPF_GetAnimGraph();
    TArray<class UEffectData*> BPF_GetAllActiveEffects();
    class USCAbilitySystemComponent* BPF_GetAbilitySystemComponent();
    void BPF_DrawDecalToRenderTarget(class UMaterialInterface* _decalMaterial, float _fSize, FVector _vLocation, float _fRadius, float _fDuration, FRotator _rotation);
    EQuadrantTypes BPF_ComputeQuadrant(class AActor* _towardSpecificTarget);
    void BPF_CharacterFullySpawned();
    void BPF_ActivateCollision(FString _contextString, bool _bActivate, bool _bLetStaticMeshOn, bool _bBlockTargettedAttacks);
    void BPE_UpdateTargettedByThrowable(bool _bIsTargetted, EHeight _eTargettingHeight);
    void BPE_UpdateTargettedByPushable(bool _bIsTargetted);
    void BPE_UpdateTargettedByGrab(bool _bIsTargetted);
    void BPE_ThrowableHit(const FHitDescription& _hit);
    void BPE_TargetChanged(class AActor* _old);
    void BPE_StartPowerFX(EItemPowers _eFxType);
    void BPE_Spawn(bool m_bRespawn);
    void BPE_SetCharacterHidden(bool _bHidden);
    void BPE_ReviveStart();
    void BPE_ReviveInProgressPercent(float _fPercent);
    void BPE_ReviveCancelPercent(float _fPercent);
    void BPE_PickUpWeaponStart(class UVisibleWeaponData* _handledWeaponData);
    void BPE_PerfectLinkWoOMissed();
    void BPE_OnRelationshipChanged(class AActor* _shifter, class AActor* _shiftTarget, ERelationshipTypes _ePreviousRelation, ERelationshipTypes _eNewRelation);
    void BPE_OnRecoveryFromDamageDealt(float _fHealthRecovered);
    void BPE_OnLanding(bool _bProceduralLanding, EFallLevel _eFallLevel, TEnumAsByte<EPhysicalSurface> _eSurface, const FVector& _vImpactpoint);
    void BPE_OnEffectStart(class UEffectData* _effectData);
    void BPE_OnEffectEnd(class UEffectData* _effectData, bool _bInterrupted);
    void BPE_OnDeath();
    void BPE_OnAvoidSuccessful_PredictionServer(const FHitRequest& _inHitRequest, const FHitDefenseResult& _defenseInfos);
    void BPE_OnAvoidSuccessful(const FHitRequest& _inDamageData, const FHitDefenseResult& _defenseResult);
    void BPE_OnAvoidCapsuleHit(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FHitDefenseResult& _defenseResult);
    void BPE_MoveStatusChanged(EMoveStatus _MoveStatus);
    void BPE_JustBeenHitted(const FHitDescription& _HittedDescription);
    void BPE_Hit(const FHitDescription& _hit);
    void BPE_EndRevive(bool _bSuccess);
    void BPE_EndPowerFX(EItemPowers _eFxType);
    void BPE_EndBeingRevived(bool _bSuccess);
    void BPE_DropWeaponStart(class UVisibleWeaponData* _handledWeaponData);
    void BPE_DoParry(EQuadrantTypes _eParryQuadrantRegardingTarget, EQuadrantTypes _eParryQuadrant);
    void BPE_DoDodge(FVector _vDodgeDirection);
    void BPE_DodgeSuccess(class AFightingCharacter* _attacker);
    void BPE_DoAvoid(EAvoidType _eAvoidType);
    void BPE_DoAbsorb();
    void BPE_BeingRevivedStart();
    void BPE_Avoided(EAvoidType _eAvoid, const class UAvoidPropertyDB* _AvoidPropertyDB);
    void BPE_AttackStarted();
    void BPE_AttackEnded();
    void BPE_Absorb_PredictionServer(const FHitResult& _hitResult, const FHitRequest& _inHitRequest, const FImpactResult& _result, const FHitDefenseResult& _defenseInfos);
    void BPE_Absorb(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FHitDefenseResult& _defenseResult);
    void BlueprintEventParrySuccessful(const FHitResult& _hitResult, const FHitRequest& _inDamageData, const FHitDefenseResult& _defenseResult);
    void BlueprintEventParried(FVector _vImpactPosition, class AFightingCharacter* _ParryInstigator);
    void AvoidCapsuleHitDelegate__DelegateSignature(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FHitDefenseResult& _defenseResult);
    void AddGameplayTag(FString _tag);
}; // Size: 0x15A0

class AFightingPlayerController : public ASCPlayerController
{
    FFightingPlayerControllerOnOptionChanged OnOptionChanged;                         // 0x0820 (size: 0x10)
    void OnOptionChangedDynamicDelegate(EGameOptionTypes eGameOptionType);
    FFightingPlayerControllerOnCurrentMenuChanged OnCurrentMenuChanged;               // 0x0830 (size: 0x10)
    void CurrentMenuChanged(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    FFightingPlayerControllerOnNotifyProgressionRewardUnlocked OnNotifyProgressionRewardUnlocked; // 0x0840 (size: 0x10)
    void ProgressionRewardUnlocked(ECharacterProgressionRewardTypes _eRewardType, const FCharacterProgressionReward& _reward, class UCharacterProgressionUnlockDB* _unlock);
    FInteractionTextStruct m_InteractionText;                                         // 0x0860 (size: 0x38)
    FText m_InteractionLockText;                                                      // 0x0898 (size: 0x18)
    bool m_InteractionUseLockText;                                                    // 0x08B0 (size: 0x1)
    class ASkillTree* m_MenuSkillTree;                                                // 0x08B8 (size: 0x8)
    bool m_bShowAltAttackStartQuadrant;                                               // 0x0918 (size: 0x1)
    FFightingPlayerControllerDropItemDelegate DropItemDelegate;                       // 0x0920 (size: 0x10)
    void DropItem(class AController* _discarder);
    FFightingPlayerControllerOnChangeMenuPage OnChangeMenuPage;                       // 0x0930 (size: 0x10)
    void ChangeMenuPage(ECycleDirection _eDirection);
    FFightingPlayerControllerOnPawnInitializedDynamic OnPawnInitializedDynamic;       // 0x09D0 (size: 0x10)
    void PawnInitializedDynamic(class AFightingCharacter* _pawn);
    FFightingPlayerControllerOnPawnWasKilled OnPawnWasKilled;                         // 0x09E0 (size: 0x10)
    void OnWasKilled(class AFightingCharacter* _victim, class AFightingCharacter* _deathInstigator);
    FFightingPlayerControllerOnMenuClosed OnMenuClosed;                               // 0x0A08 (size: 0x10)
    void CloseIngameMenu();
    FFightingPlayerControllerOnGiveInitialControlToPlayer OnGiveInitialControlToPlayer; // 0x0A48 (size: 0x10)
    void DynamicMulticast();
    FFightingPlayerControllerOnSwitchToFromPhotomode OnSwitchToFromPhotomode;         // 0x0A58 (size: 0x10)
    void OnSwitchToFromPhotomode(bool _bInPhotomode);
    bool m_bAppIsBackgrounded;                                                        // 0x0A68 (size: 0x1)
    bool m_bEnvDeathRespawn;                                                          // 0x0A6C (size: 0x1)
    TArray<class UTexture2D*> m_MenuIconCache;                                        // 0x0A70 (size: 0x10)
    bool m_bDebugDisplayAttackLearning;                                               // 0x0A80 (size: 0x1)
    TArray<EMenuEnum> m_DisabledMenus;                                                // 0x0A88 (size: 0x10)
    bool m_bHideNonInteractableObjectComponent;                                       // 0x0A98 (size: 0x1)
    TMap<class EMenuEnum, class FMenuReferenceWithRequiredTags> m_MapMenuClassesSoft; // 0x0AA8 (size: 0x50)
    TSubclassOf<class UUserWidget> m_MenuAnimationsClass;                             // 0x0AF8 (size: 0x8)
    TArray<EMenuEnum> m_eMenuListPreventingInGameMenu;                                // 0x0B00 (size: 0x10)
    class UMenuWidget* m_MenuInstances;                                               // 0x0B10 (size: 0x1A0)
    TArray<FMenuStackInfos> m_MenuStack;                                              // 0x0CB0 (size: 0x10)
    class UMaterialInterface* m_OutlineMaterial;                                      // 0x0CC0 (size: 0x8)
    class UPopupWidget* m_PopupYesNo;                                                 // 0x0CC8 (size: 0x8)
    FFightingPlayerControllerOnAFKWarningActivated OnAFKWarningActivated;             // 0x0CD0 (size: 0x10)
    void OnAFKWarningActivated(bool _bActivated);
    float m_fTimeSinceLastNonRedundantUserInput;                                      // 0x0CE0 (size: 0x4)
    class UUserWidget* m_MenuAnimationsInstance;                                      // 0x0CF8 (size: 0x8)
    class UEquipmentSelectionData* m_EquipmentSelection;                              // 0x1308 (size: 0x8)
    class UTargetableWidgetUpdaterComponent* m_TagetableWigetUpdaterComponent;        // 0x1310 (size: 0x8)
    class UASMDetectionComponent* m_ASMDetectionComponent;                            // 0x1318 (size: 0x8)
    class UWidgetPoolComponent* m_WidgetPoolComponent;                                // 0x1320 (size: 0x8)
    TSubclassOf<class UPickUpMenu> m_PickUpMenuClass;                                 // 0x1328 (size: 0x8)
    float m_fPreviewTimerHighlight;                                                   // 0x1340 (size: 0x4)
    float m_fPreviewTimerScrollBox;                                                   // 0x1344 (size: 0x4)
    float m_fFadeTime;                                                                // 0x1348 (size: 0x4)
    TSubclassOf<class UUserWidget> m_WaterMarkBP;                                     // 0x1350 (size: 0x8)
    class UUserWidget* m_WaterMarkScreen;                                             // 0x1358 (size: 0x8)
    int32 m_iCharacterLevel;                                                          // 0x1360 (size: 0x4)
    TSubclassOf<class AInteractiveObject> m_CairnClass;                               // 0x1388 (size: 0x8)
    class UMaterialParameterCollection* m_MaterialParameterCollectionFXVisualParam;   // 0x13A0 (size: 0x8)
    FName m_EmissiveMultiplierMPCParameterName;                                       // 0x13A8 (size: 0x8)

    void ToggleWaterMark();
    void ToggleInteractionDetectionDebug();
    void SuicideAll();
    void Suicide(float _fDelay);
    void SimulateError(FString _error);
    void SimulateClientReturnToMainMenu(FString _reason);
    void ShowQuadrant(uint8 _uiParam);
    void SetOptionValue(FName _optionType, float _fOptionValue);
    void SetHealth(float _fHP);
    void SessionTimeManagerActivateDebug(bool _bActivate);
    void ServerUseInterractiveObject(bool _bSuccess, class UInteractionObjectComponent* _componentUsed);
    void ServerSuicideAll();
    void ServerSetEnvDeathRespawn(bool _bValue);
    void ServerSendLocalCoopGroup(const TArray<FCoopGroup>& _coopGroup);
    void ServerRequestTimeSync(uint8 _uiClientRequestID);
    void ServerFirstRequestTimeSync(uint8 _uiClientRequestID);
    void ServerDropItem();
    void RemovePlayer();
    void RelationshipChanged__DelegateSignature(class AActor* _shifter, class AActor* _shiftTarget, ERelationshipTypes previousRelation, ERelationshipTypes _eNewRelation);
    void ProgressUpdated__DelegateSignature();
    void ProgressionRewardUnlocked__DelegateSignature(ECharacterProgressionRewardTypes _eRewardType, const FCharacterProgressionReward& _reward, class UCharacterProgressionUnlockDB* _unlock);
    void PawnInitializedDynamic__DelegateSignature(class AFightingCharacter* _pawn);
    void PawnDestructionOver(class AActor* _destroyedActor);
    void OnWasKilled__DelegateSignature(class AFightingCharacter* _victim, class AFightingCharacter* _deathInstigator);
    void OnSwitchToFromPhotomode__DelegateSignature(bool _bInPhotomode);
    void OnRegularAttack(EQuadrantTypes _eStartQuadrant, EQuadrantTypes _eEndQuadrant, uint8 uiNewIndex);
    void OnPlayerProgressionUpdated();
    void OnPlayerNotifyProgressionRewardUnlocked(ECharacterProgressionRewardTypes _eRewardType, const FCharacterProgressionReward& _reward, class UCharacterProgressionUnlockDB* _unlock);
    void OnPickUpDestroyed(class UInteractionObjectComponent* _component);
    void OnPawnDangerStateChanged(EDangerStates _ePreviousDangerState, EDangerStates _eNewDangerState);
    void OnOptionChangedDynamicDelegate__DelegateSignature(EGameOptionTypes eGameOptionType);
    void OnNeedUpdateFromGameUserSettings();
    void OnComboLastAttack(EQuadrantTypes newQuadrant);
    void OnComboChangedQuadrant(EQuadrantTypes oldQuadrant);
    void OnCharacterInteractionObjectChanged(class UInteractionObjectComponent* _objectComp, bool _bNewComp);
    void OnAltAttack(EQuadrantTypes newQuadrant, uint8 _uiCurrentComboIndex);
    void OnAFKWarningActivated__DelegateSignature(bool _bActivated);
    void Mute(bool bMute);
    void GiveFocusToGameViewport();
    void ForceCameraOffsetAt(bool _bActivate, float _fRatio);
    void DumpPlayerInfo();
    void DropItem__DelegateSignature(class AController* _discarder);
    void DebugToggleFollowPlayer(int32 _iPlayerIndex);
    void DebugSpeedForceZ(bool _bActivate, float _fZValue);
    void CurrentMenuChanged__DelegateSignature(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    void ComboEnded(EQuadrantTypes newQuadrant);
    void CloseIngameMenu__DelegateSignature();
    void ClientSendNewCoopGroup(const TArray<FCoopGroup>& _coopGroup);
    void ClientSendEntireCoopGroup(const TArray<FCoopGroup>& _coopGroup, const FCoopGroup& _coopGroupReturnToPVE);
    void ClientRespawnLocalAI(class AAISpawner* _spawner);
    void ClientRequestTimeSync(uint8 _uiClientRequestID, int64 _serverTimeTicks);
    void ClientFirstRequestTimeSync(uint8 _uiClientRequestID, int64 _serverTimeTicks);
    void Client_RestartMatch();
    void Client_ReceiveAllyHeal();
    void CheckAttackAnimations();
    void ChangeMenuPage__DelegateSignature(ECycleDirection _eDirection);
    void BPF_ValidationReceived(bool _bResult);
    void BPF_UnlockAllEmotes();
    bool BPF_ShouldDisplayInteractionText(bool& _bOutCanInteract);
    void BPF_SetWantsRespawnOnStartPoint(bool _bRespwnOnStartPoint);
    void BPF_SetEmoteLock(bool _bLock, const FName& _emoteName);
    void BPF_SetEmissiveParamOnPawn(float _fParamValue);
    void BPF_SetCurrentMenu(EMenuEnum _eMenu);
    void BPF_RemoveMenuFromStack(EMenuEnum _eMenu);
    class UMenuWidget* BPF_PushMenu(EMenuEnum _eMenuEnum, class UPanelWidget* _container);
    void BPF_PopMenuStack(EMenuEnum _eMenuEnum, bool _bIncluded);
    void BPF_PopMenu(bool _bRestoreFocus);
    bool BPF_IsMenuInStack(EMenuEnum _eMenu);
    bool BPF_IsMenuEnabled(EMenuEnum _eMenu);
    bool BPF_IsKeyBindedToInputAction(FKey _key, InputAction _eInputAction);
    bool BPF_IsInGameMenuEnabled();
    bool BPF_HasSpawnedAtFirstStart();
    class UWidgetPoolComponent* BPF_GetWidgetPoolComponent();
    bool BPF_GetWantRespawn();
    bool BPF_GetVirtualCursorEnabled();
    class UMenuWidget* BPF_GetTopMenuInstance();
    EMenuEnum BPF_GetTopMenu();
    class UTargetableWidgetUpdaterComponent* BPF_GetTagetableWigetUpdaterComponent();
    class UPopupWidget* BPF_GetPopupYesNo();
    class UMenuWidget* BPF_GetParentMenu(EMenuEnum& _eOutMenu, int32 _iOffset);
    class UMenuWidget* BPF_GetMenuInstance(EMenuEnum _eMenu);
    class UUserWidget* BPF_GetMenuAnimations();
    float BPF_GetFadeTime();
    EMenuEnum BPF_GetCurrentMenu();
    class UInteractionObjectComponent* BPF_GetCurrentInteractionObjectComponent();
    void BPF_EnterSpectatorMode();
    void BPF_EnableVirtualCursor(bool _bEnable);
    void BPF_EnableInGameMenu();
    void BPF_DismissNewProgressionRewards(ECharacterProgressionRewardTypes _eReward);
    void BPF_DisableInGameMenu();
    void BPF_DebugForcePerfectLink(bool _bActivate);
    void BPF_DebugForceAttackQuadrant(EQuadrantTypes _eQuadrant);
    void BPF_DebugAutoTargetAttackTicketAI(bool _bActivate);
    void BPF_ClosePickUpMenu();
    void BPF_ClearMenuStack();
    void BPF_CacheMenuIcons();
    void BPF_ActivateHitDetailsDebug(bool _bActivate);
    void BPE_TryQuitBadCombo();
    void BPE_ToggleDebugMenu();
    bool BPE_ShouldEnablePostProcessComponent();
    void BPE_RestartAsked();
    void BPE_PawnInitialized();
    void BPE_OnUsedHealStone();
    void BPE_OnSetInteractiveObjectComponent(class UInteractionObjectComponent* _newInteractionObjectComponent);
    void BPE_OnReceiveAllyHeal();
    void BPE_OnCurrentMenuChanged(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    void BPE_OnComboEditorClose();
    void BPE_MenuEvent();
    void BPE_GameInitialized(bool bHideLoadingScreen);
    void BPE_ChangeEditorQuadrantState(EQuadrantTypes _eNewQuadrant);
    void BakeAttackAnimations();
    void ActivateHitIgnorance(bool _bActivate);
    void ActivateCameraAimDebug(bool _bActivate);
}; // Size: 0x1420

class AFightingPlayerState : public APlayerState
{
    FFightingPlayerStateOnPlayerNameChanged OnPlayerNameChanged;                      // 0x03B8 (size: 0x10)
    void NameChanged();
    EJoinMethod m_eJoinMethod;                                                        // 0x03C8 (size: 0x4)
    uint16 m_uDispatcherToken;                                                        // 0x03CC (size: 0x2)
    int32 m_iTeamNumber;                                                              // 0x03D0 (size: 0x4)
    int32 m_iNumKills;                                                                // 0x03D4 (size: 0x4)
    int32 m_iNumDeaths;                                                               // 0x03D8 (size: 0x4)
    uint8 m_uiRespawnZoneId;                                                          // 0x03DC (size: 0x1)
    uint8 m_bQuitter;                                                                 // 0x03DD (size: 0x1)

    void OnRep_TeamNumber();
    void OnRep_SchoolLevel();
    void NameChanged__DelegateSignature();
    void InformAboutKill(class AFightingPlayerState* KillerPlayerState, const class UDamageType* KillerDamageType, class AFightingPlayerState* KilledPlayerState);
    int32 GetKills();
    void BroadcastDeath(class AFightingPlayerState* KillerPlayerState, const class UDamageType* KillerDamageType, class AFightingPlayerState* KilledPlayerState);
    void BPF_SetTeam(int32 _iTeam);
    int32 BPF_GetTeam();
    int32 BPF_GetDeaths();
}; // Size: 0x3E0

class AGameplayPhotoModeController : public ABaseReplayController
{

    void BPF_LeavePhotoMode();
    class ASCPlayerController* BPF_GetOriginalPlayerController();
    void BPF_EnterPhotoMode(const class UObject* _worldContextObject);
    void BPE_OnPhotoModeDeactivationRequested();
    void BPE_OnPhotoModeActivated();
}; // Size: 0xB70

class AInteractiveMenu : public ASCActor
{
    EMenuEnum m_eMenu;                                                                // 0x02D8 (size: 0x1)
    class UInteractionObjectComponent* m_InteractiveComp;                             // 0x02E0 (size: 0x8)
    class AActor* m_ActorToBlendTo;                                                   // 0x02E8 (size: 0x8)
    class UMenuWidget* m_MenuToShow;                                                  // 0x02F8 (size: 0x8)
    class USceneComponent* m_RootComponent;                                           // 0x0300 (size: 0x8)

    void BPF_OpenMenu(class AFightingPlayerController* _controller, float _fBlendTime, ESlateVisibility _eMenuVisibility);
    FVector2D BPF_GetLeftStickValue(class ASCPlayerController* _controller);
    void BPF_CloseMenu(class AFightingPlayerController* _controller, float _fBlendTime);
}; // Size: 0x310

class AInteractiveMovable : public ASCActor
{
    class USCStreamingActorComponent* m_StreamingComponent;                           // 0x0320 (size: 0x8)
    bool m_bEnableSreamingEvents;                                                     // 0x0328 (size: 0x1)
    class UMovableInteractionComponent* m_InteractionComponent;                       // 0x0330 (size: 0x8)
    class UInteractiveDestructionComponent* m_DestructibleComponent;                  // 0x0338 (size: 0x8)
    class USCSaveGameComponent* m_SaveComponent;                                      // 0x0340 (size: 0x8)
    float m_fAngularFallingSpeedThreshold;                                            // 0x0350 (size: 0x4)
    float m_fLinearFallingSpeedThreshold;                                             // 0x0354 (size: 0x4)
    bool m_bIsBreakSilent;                                                            // 0x0358 (size: 0x1)
    TSubclassOf<class UTargetSettingsDB> m_throwTargetSettingsDB;                     // 0x0360 (size: 0x8)
    TWeakObjectPtr<class AActor> m_TmpTarget;                                         // 0x03B4 (size: 0x8)
    FTransform m_SavedTransform;                                                      // 0x03E0 (size: 0x30)

    void OnUpdatedFromSaveCallback();
    void OnPreSaveLevel();
    void BPF_SetInstigator(class AActor* _Instigator);
    void BPF_SetActivate(bool _bActivated);
    bool BPF_IsReadyToUse();
    FVector BPF_GetPivotLoc();
    class AActor* BPF_GetInstigator();
    FVector BPF_GetHUDLocation();
    EDebugMovableState BPF_GetDebugMovableState();
    void BPE_ShowMovableInteractions();
    void BPE_OnUsabilityUpdated(bool _bUsable);
    void BPE_OnObjectBreak(bool _bIsSilent);
    void BPE_HideMovableInteractions();
    void BPE_HasHitChara();
    FText BPE_GetHUDActionText(bool& _bUsable);
    InputAction BPE_FindAppropriateActionFromContext(class AFightingCharacter* _user);
}; // Size: 0x420

class AInteractiveObject : public AActor
{
    class UInteractionObjectComponent* m_InteractionObjectComponent;                  // 0x02B0 (size: 0x8)

    void UseInteractiveObjectFailed(class APlayerController* _controller, FText _reason);
    void UseInteractiveObject(class APlayerController* _controller);
    class UInteractionObjectComponent* BPF_GetInteractionObjectComponent();
    void BPF_Deactivate();
    void BPE_OnUseFailed(const FText& _reason);
    void BPE_OnUse();
}; // Size: 0x2C0

class AKeyPass : public AActor
{
    class UInteractionObjectComponent* m_InteractionObjectComponent;                  // 0x02B0 (size: 0x8)
    bool m_bCollected;                                                                // 0x02B8 (size: 0x1)
    bool m_bForAllPlayers;                                                            // 0x02B9 (size: 0x1)

    void UseInteractiveObject(class APlayerController* _controller);
    void On_RepCollected();
    void BPE_OnKeyCollected();
    void BPE_KeyLareadyCollected();
}; // Size: 0x2C0

class AKillzone : public AStaticMeshActor
{
    class UBoxComponent* m_BoxComponent;                                              // 0x02C0 (size: 0x8)

    void OnBoxTouched(class UPrimitiveComponent* _OverlappedComp, class AActor* _Other, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex, bool _bFromSweep, const FHitResult& _sweepResult);
    bool BPF_IsKillzoneActive();
    void BPE_OnBoxTouched(class AFightingCharacter* _Char, const FVector& _vImpactpoint);
}; // Size: 0x2D0

class ALDCameraActor : public ASCActor
{
}; // Size: 0x2E0

class ALevelSequenceRoot : public AActor
{
}; // Size: 0x2C0

class ALockableDoor : public AActor
{
    class USkeletalMeshComponent* m_SkeletalMeshComponent;                            // 0x02B0 (size: 0x8)
    class USceneComponent* m_RootComponent;                                           // 0x02B8 (size: 0x8)
    float m_fCloseDistThreshold;                                                      // 0x02C0 (size: 0x4)
    FVector m_vHandleLocation;                                                        // 0x02D0 (size: 0xC)
    class USCSaveGameComponent* m_SaveComponent;                                      // 0x02E8 (size: 0x8)
    bool m_bShouldStayOpen;                                                           // 0x02F0 (size: 0x1)
    class ULevelSequence* m_levelSequenceWay1;                                        // 0x02F8 (size: 0x8)
    class ULevelSequence* m_levelSequenceWay2;                                        // 0x0300 (size: 0x8)
    FLockableDoor_OnDoorEndClose m_OnDoorEndClose;                                    // 0x0308 (size: 0x10)
    void LockableDoorEndClose(const class AActor* _lockableDoorActor);
    bool m_bCanLockNavBuild;                                                          // 0x0318 (size: 0x1)
    class USkeletalMesh* m_SkeletalMesh;                                              // 0x0320 (size: 0x8)
    TArray<FName> m_HiddenMeshComponents;                                             // 0x0328 (size: 0x10)
    bool m_bLocked;                                                                   // 0x0348 (size: 0x1)
    bool m_bOpened;                                                                   // 0x0349 (size: 0x1)
    FName m_sequenceRoleName;                                                         // 0x0350 (size: 0x8)

    void SetOpened(bool bOpened);
    void SetLocked(bool bLocked);
    void OnReplaySystemRecordingChanged(bool _bRecording);
    void OnRep_SkeletalMesh();
    void OnRep_HidenMeshComponents();
    void LockableDoorEndClose__DelegateSignature(const class AActor* _lockableDoorActor);
    void BPF_SetNonOccluding(bool bNonOccluding);
    void BPF_SetDoorInOpenedState(class UAnimationAsset* _openingAnimAsset);
    void BPF_RemoveNavBuildLock();
    void BPF_OpenDoor(class AFightingCharacter* _interactor, class UAnimationAsset* _openingAnimAsset, class UAnimationAsset* _closingAnimAsset);
    void BPF_CloseDoor();
    void BPF_AddNavBuildLock();
    void BPE_OpenedStatusChanged();
    void BPE_OnDoorAnimationFinished();
    bool BPE_MustMirrorOpeningAnim(const class AFightingCharacter* _Instigator, bool _bInteraction1);
    void BPE_LockedStatusChanged();
    void BPE_GetOpeningDoorInfo(const class AFightingCharacter* _Instigator, bool _bInteraction1, bool& _outPlayAnimOnCharacter, bool& _outMustMirrorAnimOnCharacter);
}; // Size: 0x360

class ALootboxes_BlackRoom : public AActor
{

    void LoadTextureAsyncForMaterial(TSoftObjectPtr<UTexture2D> _texture, class UMaterialInstanceDynamic* _material, FName _paramName);
    void BPF_EnableTextureStreamingLoc();
    void BPF_DisableTextureStreamingLoc();
}; // Size: 0x2C0

class APathPatrol : public AActor
{
    TArray<FPatrolControlPoint> m_patrolControlPoints;                                // 0x02B0 (size: 0x10)
    EPatrolType m_ePatrolType;                                                        // 0x02C0 (size: 0x1)
    class AActor* m_lookAtTarget;                                                     // 0x02C8 (size: 0x8)

}; // Size: 0x320

class APushableActor : public AInteractiveMovable
{
    float m_fFallingVelocityReduc;                                                    // 0x0418 (size: 0x4)
    FVector m_vFallingVelocityOffset;                                                 // 0x041C (size: 0xC)
    FVector2D m_vViewMargin;                                                          // 0x042C (size: 0x8)
    FPushableActorOnStateUpdated OnStateUpdated;                                      // 0x0438 (size: 0x10)
    void StateUpdated(EPushableState _eNewState);
    class UStaticMeshComponent* m_StaticMeshComponent;                                // 0x0448 (size: 0x8)
    class UPushObjMovementComponent* m_MovementComponent;                             // 0x0450 (size: 0x8)
    class UBoxComponent* m_InteractionBox;                                            // 0x0458 (size: 0x8)
    class USceneComponent* m_PivotLoc;                                                // 0x0460 (size: 0x8)
    FSCCollisionResponsePreset m_fColProfileAtRest;                                   // 0x0468 (size: 0x30)
    FSCCollisionResponsePreset m_fColProfilePushed;                                   // 0x0498 (size: 0x30)
    float m_fUsabilityAngleRestriction;                                               // 0x04C8 (size: 0x4)

    void StateUpdated__DelegateSignature(EPushableState _eNewState);
    void BPF_SetPushableState(EPushableState _eNewState);
    void BPF_Push(const class AFightingCharacter* _character);
    class AActor* BPF_GetTarget(const class AFightingCharacter* _character);
    EPushableState BPF_GetPushableState();
    FVector2D BPF_GetLeftStickValues(class ASCPlayerController* _playerController);
    float BPF_AngleBetweenMoveInputAndObject(const class AFightingCharacter* _character);
    void BPE_OnPushed();
    void BPE_HasHitWall();
    FBox BPE_GetMovementBox(const class AFightingCharacter* _player);
}; // Size: 0x4D0

class ARailForMovable : public AActor
{
    class USplineComponent* m_Rail;                                                   // 0x02B8 (size: 0x8)
    class UBoxComponent* m_EntryBox;                                                  // 0x02C0 (size: 0x8)
    float m_fSpeedThreshold;                                                          // 0x02C8 (size: 0x4)

}; // Size: 0x2E0

class AReplayCineCameraActor : public ACineCameraActor
{

    class UReplayCineCameraComponent* BPF_GetReplayCineCameraComponent();
}; // Size: 0x8A0

class AReplayController : public ABaseReplayController
{
    FReplayTimelineControllerData m_TimelineControllerData;                           // 0x0B28 (size: 0x28)
    class UReplayTimelineController* m_TimelineController;                            // 0x0B50 (size: 0x8)
    FReplayCameraSettings m_DefaultCameraSettings;                                    // 0x0B58 (size: 0x28)
    FReplayCameraSettings m_SequenceCameraSettings;                                   // 0x0B80 (size: 0x28)
    FReplayController_OnGoToTimeCompleted m_OnGoToTimeCompleted;                      // 0x0BA8 (size: 0x10)
    void DynamicMulticast();
    float m_fGoToTimeCompletedTimeS;                                                  // 0x0BC0 (size: 0x4)
    bool m_bTimeDilationZeroedOnGoToTime;                                             // 0x0BC4 (size: 0x1)
    FReplayController_OnCameraModeChanged m_OnCameraModeChanged;                      // 0x0BD0 (size: 0x10)
    void OnReplayCameraModeChanged(EReplayCameraMode _eCameraMode);
    FReplayController_OnGoToTimeInitiated m_OnGoToTimeInitiated;                      // 0x0BE0 (size: 0x10)
    void OnReplayGoToTime(bool _bUnselectKey);
    bool m_bDebugEnabled;                                                             // 0x0BF0 (size: 0x1)
    TMap<class EReplayKeyTransition, class UCurveFloat*> m_TransitionProfiles;        // 0x0BF8 (size: 0x50)
    EReplayCameraMode m_eCurrentCameraMode;                                           // 0x0C48 (size: 0x1)
    TSubclassOf<class AActor> m_VirtualCameraClass;                                   // 0x0C50 (size: 0x8)
    TSubclassOf<class UReplayLoadingScreenWidget> m_LoadingScreenWidgetClass;         // 0x0C58 (size: 0x8)
    TArray<FReplayOverrideMPCParameter> m_MPCParametersOverride;                      // 0x0C60 (size: 0x10)
    class UReplayMainUserWidget* m_MainUserWidget;                                    // 0x0C70 (size: 0x8)
    class UReplayLoadingScreenWidget* m_LoadingScreenWidgetInstance;                  // 0x0C78 (size: 0x8)
    class AActor* m_VirtualCamera;                                                    // 0x0C80 (size: 0x8)
    TSubclassOf<class AReplayVideoRecorder> m_VideoRecorderClass;                     // 0x0C90 (size: 0x8)
    class AReplayVideoRecorder* m_VideoRecorder;                                      // 0x0C98 (size: 0x8)

    void OnKeysLoaded();
    void OnKeyMoved(class UReplayKey* _key);
    void OnGoToTimeCompleted();
    bool IsReplaying();
    bool IsRecording();
    void GotoTimeInSeconds(float _fTime, bool _bUnselectKey);
    void DebugReplayFillReplayTimeline(int32 _iStringsLength);
    void BPF_StopVideoRecording();
    void BPF_StartVideoRecording(FBPF_StartVideoRecordingOnVideoRecorderCreated _onVideoRecorderCreated);
    void BPF_StartSkipTimeToNextKeyFrameTask();
    void BPF_SetDemoPlayTimeDilation(float _fValue);
    void BPF_SetCameraMode(EReplayCameraMode _eCameraMode);
    void BPF_ResetPreviousTimeDilation();
    void BPF_RequestTimelineControllerCameraMeshFadingUpdate();
    void BPF_PausePlayAndSnapFrame();
    void BPF_LeaveReplay();
    bool BPF_IsRecordingVideo();
    bool BPF_IsCameraEditable();
    void BPF_GoToLastKeyTime();
    class UCurveFloat* BPF_GetTransitionProfile(EReplayKeyTransition _eTransitionType);
    class UReplayTimelineModel* BPF_GetTimelineModel();
    float BPF_GetReplayTimeFromOffsetS(float _fOffset);
    float BPF_GetReplayTimeFromOffsetMS(float _fOffset);
    class UReplaySystem* BPF_GetReplaySystem();
    class UReplayFightingCharacterComponent* BPF_GetReplayFightingCharacterComponent(const class UObject* _worldContextObject);
    class AReplayingCamera* BPF_GetReplayFightingCharacterCameraDummy(const class UObject* _worldContextObject);
    class UReplayCineCameraComponent* BPF_GetReplayCineCameraComponent(EReplayCameraMode _eCameraMode);
    class UReplayCineCameraComponent* BPF_GetCurrentCineCameraComponent();
    void BPE_OnReplayCameraModeChanged(EReplayCameraMode _eCameraMode);
    void BPE_OnPlayingBeginPlay();
    void BPE_OnKeyRemoved(class UReplayKey* _key);
    void BPE_OnGoToTimeCompleted();
}; // Size: 0xCA0

class AReplayHUD : public AHUD
{
    FScreenTextureData m_TextureToDraw;                                               // 0x03A8 (size: 0x88)
    class UTexture2D* m_CurrentTexture;                                               // 0x0430 (size: 0x8)
    TArray<TSoftObjectPtr<UTexture2D>> m_LoadingTextures;                             // 0x0438 (size: 0x10)

    void OnAssetsLoaded(const TArray<TSoftObjectPtr<UObject>>& _items);
    void BPF_SetTextureToDraw(const FScreenTextureData& _screenTexture);
    void BPF_SetTextureLocation(EScreenLocation _eTextureLocation);
    void BPF_SetDrawTextureEnabled(bool _bEnabled);
}; // Size: 0x460

class AReplayReplicationProxy : public AReplayReplicationProxyBase
{
}; // Size: 0x2B0

class AReplaySpectatorPawn : public ASCSpectatorPawnBase
{
    class UReplayCineCameraComponent* m_CineCameraComponent;                          // 0x0368 (size: 0x8)
    float m_fDefaultRollCooldownOnReset;                                              // 0x0370 (size: 0x4)

    void BPE_OnPossess(class AController* _controller);
}; // Size: 0x380

class AReplayVideoRecorder : public AActor
{
    FReplayVideoRecorder_OnVideoRecordingComplete m_OnVideoRecordingComplete;         // 0x02B0 (size: 0x10)
    void VideoRecordEvent(bool bSuccess);
    FReplayVideoRecorder_OnVideoRecordingStarted m_OnVideoRecordingStarted;           // 0x02C0 (size: 0x10)
    void VideoRecordEvent(bool bSuccess);
    FAvailabilityLayerCache m_AvailabilityLayerCache;                                 // 0x02D0 (size: 0x28)

    void BPF_StopVideoRecording();
    void BPF_RemoveReplaySystemListeners();
    void BPF_GoToStart();
    void BPF_GoToEnd();
    void BPE_StartRecordingVideo();
    void BPE_OnPlayBackCompleted(class UWorld* _world);
    void BPE_OnGoToTimeCompleted();
}; // Size: 0x310

class AReplayingCamera : public AActor
{
}; // Size: 0x360

class ASCGameSession : public AGameSession
{
}; // Size: 0x300

class ASCGauntletPerfTestActor : public AActor
{
    TArray<class ASCTestingLocationsBase*> m_TestingLocations;                        // 0x02B0 (size: 0x10)

}; // Size: 0x2C0

class ASCLevelSequenceActor : public ALevelSequenceActor
{
    TArray<FSequenceBinding> m_SequenceBindings;                                      // 0x0330 (size: 0x10)

    void BPF_Play();
    class ULevelSequence* BPF_GetOverridingLevelSequence(class ACharacter* _characterOwner);
}; // Size: 0x350

class ASCNavLinkProxy : public ANavLinkProxy
{
    FSCNavLinkProxy_onActorLeftSmartLink m_onActorLeftSmartLink;                      // 0x0300 (size: 0x10)
    void MulticastDelegateActorDyn(class AActor* _actor);

    void SetNavLinksEnabled(bool _bEnabled);
    void ReceiveSmartLinkLeft(class AActor* Agent);
    bool AreAllNavLinksEnabled();
}; // Size: 0x310

class ASCPlayerCameraManager : public APlayerCameraManager
{
    TArray<FTViewTarget> m_ForcedViewTargetToUpdateUnderneath;                        // 0x28A0 (size: 0x10)

}; // Size: 0x28B0

class ASCPlayerController : public ASCBasePlayerController
{
    TWeakObjectPtr<class UUserWidget> m_HUD;                                          // 0x0680 (size: 0x8)
    TArray<FString> m_ControllerMotionOutputList;                                     // 0x0688 (size: 0x10)
    TArray<FString> m_ControllerSecondaryOutputList;                                  // 0x0698 (size: 0x10)
    FSCPlayerController_OnAllActivitiesUpdated m_OnAllActivitiesUpdated;              // 0x06F8 (size: 0x10)
    void AllActivitiesStarted();
    FSCPlayerController_OnAchievementCompleted m_OnAchievementCompleted;              // 0x0708 (size: 0x10)
    void AchievementCompleted(FString _achievementId);
    FSCPlayerController_OnQueryAchievementsCompleted m_OnQueryAchievementsCompleted;  // 0x0718 (size: 0x10)
    void OnQueryAchievementsCompleted();

    void UnlockAllAchievements();
    void UnlockAchievement(FString achievementId);
    void ResetAllAchievements();
    void ResetAchievement(FString achievementId);
    void QueryAchievements();
    void PushInputContext(class UInputContextData* _inputContextData);
    void PopInputContext(class UInputContextData* _inputContextData);
    void OnQueryAchievementsCompleted__DelegateSignature();
    void DebugTriggerEventProgession(const FString _eventName, const FString _eventParamName, int32 _iEventParamValue);
    void BPF_UpdateActivity(FString _activityID, EActivityWantedState _eActivityWantedState);
    void BPF_UpdateAchievementCompletion(FString _achievementId, float _fCompletionPercent);
    void BPF_ToggleMouseCaptureMode();
    void BPF_StartTimedAchievement(const FName& _achievementId, int32 _iNumOccurencess);
    void BPF_SetInUIInputMode(bool _bActivate, bool _bUIOnly);
    void BPF_SetHUD(class UUserWidget* _inHUD);
    void BPF_RestartAllActivities();
    void BPF_ResetAllActivities();
    void BPF_QueryAchievements();
    bool BPF_IsAchievementCompleted(FString _achievementId);
    bool BPF_HasUnlockAllAchievements();
    float BPF_GetTimedAchievementElapsed(const FName& _achievementId, int32& _iOutOnGoingOccurences);
    class AActor* BPF_GetStartSpot();
    FName BPF_GetLastGamepadControllerType();
    void BPF_ChangeActivityAvailability(FString _activityID, bool _bSetAvailable);
    void BPE_ShowSkipCutsceneWidget();
    void BPE_LeaveGame();
    void BPE_HideSkipCutsceneWidget();
    class UGenericErrorPopupWidget* BPE_GetPopupWidget();
    float BPE_GetMaxAchievementProgress(FString _achievementId);
    void BPE_GetActivitiesState(TArray<FString>& _activitiesState, TArray<FString>& _tasksToStart, TArray<FString>& _tasksToEnd, TArray<FString>& _subTasks);
    class UGenericErrorPopupWidget* BPE_CreatePopupWidget();
    void AllActivitiesStarted__DelegateSignature();
    void AchievementCompleted__DelegateSignature(FString _achievementId);
}; // Size: 0x800

class ASCPlayerStart : public APlayerStart
{
    FSCPlayerStartOnGotoGameplaySequenceStarted OnGotoGameplaySequenceStarted;        // 0x02E0 (size: 0x10)
    void DynamicMulticast();
    FSCPlayerStartOnGotoGameplaySequenceFinished OnGotoGameplaySequenceFinished;      // 0x02F0 (size: 0x10)
    void DynamicMulticast();
    FSCPlayerStartOnPlayerSpawnedHere OnPlayerSpawnedHere;                            // 0x0300 (size: 0x10)
    void OnPlayerStartUsed(class AActor* _player);
    TArray<FName> m_levelsNameToLoad;                                                 // 0x0310 (size: 0x10)
    class USceneComponent* m_AnchorSceneComponent;                                    // 0x0320 (size: 0x8)
    bool m_bKeepBackGroundDuringStartupMenu;                                          // 0x0328 (size: 0x1)
    FVector m_vCameraForwardAtIntroEnd;                                               // 0x032C (size: 0xC)
    FGameplayTag m_PlayerStartGameplayTag;                                            // 0x0338 (size: 0x8)
    class AController* m_spawnedPlayer;                                               // 0x0340 (size: 0x8)
    bool m_bForFirstSpawn;                                                            // 0x0348 (size: 0x1)
    EPlayerScreenSide m_ePlayerScreenSide;                                            // 0x0354 (size: 0x1)
    class ULevelSequence* m_IdleStartupSequence;                                      // 0x0358 (size: 0x8)
    class ULevelSequence* m_StartupSequence;                                          // 0x0360 (size: 0x8)
    float m_fCameraBlendDurationBetweenLoopAndGoto;                                   // 0x0368 (size: 0x4)
    TSubclassOf<class UMatineeCameraShake> m_CameraShakeClass;                        // 0x0370 (size: 0x8)

    bool BPF_WantKeepBackgroundDuringStartupMenu();
    void BPE_PrepareSequence(int32 _sequenceID);
}; // Size: 0x3E0

class ASCSpectatorPawn : public ASCSpectatorPawnBase
{
    float m_fSpeedFactorModifier;                                                     // 0x0368 (size: 0x4)
    float m_fFOVModifier;                                                             // 0x036C (size: 0x4)

}; // Size: 0x3E0

class ASCSpectatorPawnBase : public ASpectatorPawn
{
    class UCurveFloat* m_VerticalStrifeSpeedCurve;                                    // 0x0338 (size: 0x8)
    float m_fVerticalStrifeSpeed;                                                     // 0x0340 (size: 0x4)
    float m_fLookSpeed;                                                               // 0x0344 (size: 0x4)

    void BPE_OnAnyInputConsumed();
}; // Size: 0x370

class ASCTeleporter : public AActor
{
    class USceneComponent* m_RootComponent;                                           // 0x02B0 (size: 0x8)
    class UBoxComponent* m_EntryBoxComponent;                                         // 0x02B8 (size: 0x8)
    class UBoxComponent* m_ExitBoxComponent;                                          // 0x02C0 (size: 0x8)

    void BPF_RemoveActorToTeleport(class AActor* _leavingActor);
    void BPF_LaunchTeleport();
    void BPF_AddActorToTeleport(class AActor* _actorToTeleport);
}; // Size: 0x2E0

class ASCTestingLocationsBase : public AActor
{
}; // Size: 0x2C0

class AShockWaveDamageItem : public AUsableItem
{
    class UCurveFloat* m_KnockbackCoefOverDistToInstig;                               // 0x02E0 (size: 0x8)

}; // Size: 0x2F0

class ASkillTree : public AActor
{
    class USkillsDB* m_SkillsDB;                                                      // 0x02B0 (size: 0x8)

    void BPF_UpdateTreeOverTime(const TArray<class TSubclassOf<USkillGameplayEffect>>& _prevUnlockedSkills, const TArray<class TSubclassOf<USkillGameplayEffect>>& _newUnlockedSkills, float _fDuration, class UCurveFloat* _floatCurve, FBPF_UpdateTreeOverTimeOnFinished _onFinished);
    void BPF_SetTreeState(const TArray<class TSubclassOf<USkillGameplayEffect>>& _unlockedSkills);
    void BPF_BlendTreeState(const TArray<class TSubclassOf<USkillGameplayEffect>>& _prevSkills, const TArray<class TSubclassOf<USkillGameplayEffect>>& _newSkills, float _fAlpha);
    void BPE_SetNodeState(FName _boneName, float _fState, float _fAge);
}; // Size: 0x2C0

class ASkySphere : public AActor
{
    class UMaterialInstance* BaseMaterial;                                            // 0x02B0 (size: 0x8)

}; // Size: 0x2C0

class ASoundLevel : public AThePlainesLevel
{
    TArray<uint8> m_SoundManagerSaveData;                                             // 0x0430 (size: 0x10)

    void BPE_OnMoodChanged(FSoundMoodState _previousState, FSoundMoodState _newState);
    void BPE_OnAIGlobalBehaviorChanged(const class ABaseCharacter* _AICharacter, EGlobalBehaviors _ePreviousBehavior, EGlobalBehaviors _eNewBehavior);
}; // Size: 0x440

class ASoundTensionPortal : public ASoundTensionVolume
{
    int32 m_iTensionLevelBackward;                                                    // 0x0390 (size: 0x4)

}; // Size: 0x3A0

class ASoundTensionVolume : public ASCPlayerVolume
{
    int32 m_iTensionLevel;                                                            // 0x0370 (size: 0x4)
    FSoundTensionThreat m_Threat;                                                     // 0x0378 (size: 0x18)

}; // Size: 0x390

class ASoundTransitionVolume : public ASCPlayerVolume
{
    class USplineComponent* m_SplineComponent;                                        // 0x0370 (size: 0x8)
    FName m_RTPC;                                                                     // 0x0378 (size: 0x8)

}; // Size: 0x390

class ASpawnerGroup : public AActor
{
    FSpawnerGroup_SituationChangeDelegateDyn m_SituationChangeDelegateDyn;            // 0x02B0 (size: 0x10)
    void SpawnerGroupDelegateDynamic(class ASpawnerGroup* _spawnerGroup);
    TArray<class AAISpawner*> m_Spawners;                                             // 0x02F0 (size: 0x10)
    TArray<FSpawnerGroupLayer> m_SpawningLayers;                                      // 0x0300 (size: 0x10)
    TArray<class ASpawnerGroup*> m_groupsToAlert;                                     // 0x0310 (size: 0x10)
    TArray<TWeakObjectPtr<AAISpawner>> m_SpawnersUsed;                                // 0x0320 (size: 0x10)
    FDataTableRowHandle m_AlertedStateDialogSequenceRowHandle;                        // 0x0330 (size: 0x10)
    bool m_bAssignRolesDynamically;                                                   // 0x0340 (size: 0x1)
    bool m_bUseDefaultReal;                                                           // 0x0341 (size: 0x1)
    EJoinDialogActors m_eJoinDialogActorsOnStart;                                     // 0x0342 (size: 0x1)
    TSubclassOf<class UNavigationQueryFilter> m_dialogNavigationQueryFilter;          // 0x0348 (size: 0x8)
    bool m_bLookAtEnabledDuringDialog;                                                // 0x0350 (size: 0x1)
    bool m_bSkipSuspiciousOnDetection;                                                // 0x0351 (size: 0x1)
    bool m_bOverrideThreateningActions;                                               // 0x0352 (size: 0x1)
    uint32 m_uiThreateningActionsMask;                                                // 0x0354 (size: 0x4)
    EEnemyPresenceKnownType m_eMCPresenceKnownType;                                   // 0x0358 (size: 0x1)

    void SpawnerGroupDelegateDynamic__DelegateSignature(class ASpawnerGroup* _spawnerGroup);
    void BPF_TriggerBehaviorChange(class AActor* _alertedBy, const EGlobalBehaviors _eNewBehavior, bool _bSkipBark);
    void BPF_SpawnActors(int32 _iLevel, int32 _index, bool _bForce);
    int32 BPF_GetRemainingAICount(bool _bIncludeLinkedSpawner, bool _bIncludeAbandonningAIs);
    int32 BPF_GetRemainingAI(TArray<class UAIFightingComponent*>& _outAiComponents, bool _bAppendToArray, bool _bIncludeLinkedSpawner, bool _bIncludeAbandonningAIs);
}; // Size: 0x370

class ASpawningVolume : public AActor
{
    class UShapeComponent* m_ShapeComponent;                                          // 0x02B8 (size: 0x8)
    bool m_bAllowSpawnIfCharacterOverlaps;                                            // 0x02C0 (size: 0x1)
    bool m_bSpawnIfNothingUnder;                                                      // 0x02C1 (size: 0x1)
    float m_fSecurityMargin;                                                          // 0x02C4 (size: 0x4)

}; // Size: 0x2D0

class ASpectatorController : public ASCPlayerController
{

    void BPF_ExitSpectatorMode();
}; // Size: 0x800

class ATargetAOEItem : public AUsableItem
{
    int32 m_iTracksAvoidFakeTarget;                                                   // 0x02E0 (size: 0x4)
    class UCurveFloat* m_KnockbackCoefOverDistToInstig;                               // 0x02E8 (size: 0x8)

}; // Size: 0x300

class AThePlainesGameMode : public ASCGameMode
{
    FThePlainesGameModeOnCharacterKilled OnCharacterKilled;                           // 0x03D0 (size: 0x10)
    void TwoControllersDynamicDelegate(class AController* _killer, class AController* _victim, const FDamageInfos& _damageInfos);
    bool m_bOverrideAITraversalInfo;                                                  // 0x03E0 (size: 0x1)
    bool m_bIsTraversalUniversalLockEnabled;                                          // 0x03E1 (size: 0x1)
    float m_fTraversalLockTime;                                                       // 0x03E4 (size: 0x4)
    float m_fTraversalCooldownPerAI;                                                  // 0x03E8 (size: 0x4)
    FName m_ForcedPlayerStart;                                                        // 0x03EC (size: 0x8)
    bool m_bAllowInitialOverlappingAllButQueryOnly;                                   // 0x03F4 (size: 0x1)
    float m_fGMDamageMultiplier;                                                      // 0x03F8 (size: 0x4)

    void TwoControllersDynamicDelegate__DelegateSignature(class AController* _killer, class AController* _victim, const FDamageInfos& _damageInfos);
    void KillAllAis();
    TArray<class APlayerController*> BPF_GetPlayers();
    void BPF_ForceRestartPlayerAtStartNull(class AController* _controller);
    void BPE_TryGetOverrideGenderAndOutfit(ECharacterGender& _eOutGender, int32& _iOutOutfitIndex, bool& _bOutEnableOutfitPropSpawn);
    void BPE_TryGetOverrideAge(int32& _iOutAge);
    bool BPE_IsStartupGameMode();
    void AllAisSetFightingState(EFightingState _eFightingState, float _fDuration);
}; // Size: 0x450

class AThePlainesGameState : public ASCGameState
{
    FThePlainesGameStateOnMatchHasStarted OnMatchHasStarted;                          // 0x0320 (size: 0x10)
    void DynamicMulticast();
    FThePlainesGameStateOnMatchHasEnded OnMatchHasEnded;                              // 0x0330 (size: 0x10)
    void DynamicMulticast();
    FThePlainesGameStateOnLeavingMap OnLeavingMap;                                    // 0x0340 (size: 0x10)
    void DynamicMulticast();
    int32 m_iNumPlayersPerTeam;                                                       // 0x0350 (size: 0x4)
    bool m_bFriendlyFire;                                                             // 0x0354 (size: 0x1)
    uint8 m_uiLastHostZone;                                                           // 0x0355 (size: 0x1)
    int32 m_iNumTeams;                                                                // 0x0358 (size: 0x4)
    float m_fTimeBeforeVanishActive;                                                  // 0x035C (size: 0x4)
    bool m_bShouldGiveXPOnKill;                                                       // 0x0360 (size: 0x1)
    bool m_bHasRunOnce;                                                               // 0x0361 (size: 0x1)
    TArray<FSpawnerPerZone> m_ToSpawnFrom;                                            // 0x0368 (size: 0x10)
    EDangerStates m_eThresholdDangerState;                                            // 0x0388 (size: 0x1)
    float m_fReviveTime;                                                              // 0x038C (size: 0x4)
    float m_fDeathRespawnTime;                                                        // 0x0390 (size: 0x4)
    float m_fReviveLifePercent;                                                       // 0x0394 (size: 0x4)
    float m_fDeathLifePercent;                                                        // 0x0398 (size: 0x4)
    float m_fRoomClearedLifePercent;                                                  // 0x039C (size: 0x4)
    float m_fVanishTime;                                                              // 0x03A0 (size: 0x4)
    bool m_bCanGoDown;                                                                // 0x03A4 (size: 0x1)
    float m_fDownTime;                                                                // 0x03A8 (size: 0x4)
    float m_fRespawnTimeNoDown;                                                       // 0x03AC (size: 0x4)

    void OnRepNumTeam();
    bool BPF_IsPvPGameMode();
    float BPF_GetTimeBeforeVanishActive();
    float BPF_GetRespawnTimeNoDown();
    EGameModeTypes BPF_GetGameModeType();
    float BPF_GetDownTime();
}; // Size: 0x3B0

class AThePlainesLDLevel : public AThePlainesLevel
{
    class UDataTable* m_dynamicPropsDataTable;                                        // 0x0430 (size: 0x8)
    uint8 m_uiEncouterZone;                                                           // 0x0438 (size: 0x1)
    int32 m_iLastManGaugeThresold;                                                    // 0x043C (size: 0x4)
    TArray<FArchetypeSituationDescription> m_ArchetypesInSituation;                   // 0x0440 (size: 0x10)
    class UArchetypeSituationDB* m_ArchetypesInSituationDB;                           // 0x0450 (size: 0x8)
    TArray<FWeaponSituationDescription> m_WeaponsInSituation;                         // 0x0458 (size: 0x10)
    int32 m_iMinMaxGenericWeapons;                                                    // 0x0468 (size: 0x4)
    int32 m_iMaxMaxGenericWeapons;                                                    // 0x046C (size: 0x4)

}; // Size: 0x480

class AThePlainesLevel : public ASCLevelScriptActor
{
    class ASCBlenderManager* m_BlenderManager;                                        // 0x02E0 (size: 0x8)
    class ULevelSequence* m_StartupSequence;                                          // 0x02E8 (size: 0x8)
    bool m_bInChargeOfSoundSave;                                                      // 0x02F0 (size: 0x1)
    TArray<class UAkAudioBank*> m_AudioBanksToLoad;                                   // 0x0398 (size: 0x10)
    TMap<uint32, FSoundStateInfo> m_AKStateGroupValues;                               // 0x03B8 (size: 0x50)
    TArray<class UAkAudioBank*> m_SavedSoundBanksToLoad;                              // 0x0408 (size: 0x10)

    void UnregisterFromSignificanceOnActorEndPlay(class AActor* _actor, TEnumAsByte<EEndPlayReason::Type> _eEndPlayReason);
    bool BPF_IsSoundStateContainedInSaved(FString _SoundState);
    void BPF_InitSoundState(FString _StateGroup, FString _state, bool _bReplicates, bool _bSaveGame);
    void BPE_OnStartAIPhaseChanged(class AFightingCharacter* _fightingChar, const FAIPhaseTransitionData& _phaseTransition);
    void BPE_OnLevelTransition(int32 _iTransitionIndex);
    void BPE_OnEndAIPhaseChanged(class AFightingCharacter* _fightingChar, int32 _iPreviousPhaseIndex, int32 _iCurrentPhaseIndex);
    void BPE_OnAppliedSoundStateFromSave();
    void BPE_AllSoundBanksLoaded();
}; // Size: 0x430

class AThrowableActor : public AInteractiveMovable
{
    FThrowableActorOnStateUpdated OnStateUpdated;                                     // 0x0418 (size: 0x10)
    void StateUpdated(EThrowableState _eNewState);
    bool m_bIsPickedupFromSpawning;                                                   // 0x0440 (size: 0x1)
    FName m_sBoneToAttachToWhenThrowing;                                              // 0x0444 (size: 0x8)
    TSubclassOf<class UThrowObjectAnimRequest> m_ThrowAnimRequest;                    // 0x0450 (size: 0x8)
    FVector m_vThrowStartBoxExtent;                                                   // 0x0458 (size: 0xC)
    FVector m_vLastHitLocation;                                                       // 0x0464 (size: 0xC)
    FVector m_vLastHitNormal;                                                         // 0x0470 (size: 0xC)
    TArray<class AActor*> m_aHitActorToRemove;                                        // 0x04C0 (size: 0x10)
    class UBoxComponent* m_BoxColl;                                                   // 0x04D0 (size: 0x8)
    class USphereComponent* m_BreakableProximity;                                     // 0x04D8 (size: 0x8)
    class USceneComponent* m_ThrowPivot;                                              // 0x04E0 (size: 0x8)
    class UPhysicalActorDependencyComponent* m_PhysicalActorDependencyComponent;      // 0x04E8 (size: 0x8)
    float m_fDistToThrow;                                                             // 0x04F0 (size: 0x4)
    class UThrowableObjMovementComponent* m_MovementComponent;                        // 0x04F8 (size: 0x8)
    class UAIPerceptionStimuliSourceComponent* m_PerceptionStimuli;                   // 0x0500 (size: 0x8)
    class UReplayablePhysObjectComponent* m_ReplayablePhysObjectComponent;            // 0x0508 (size: 0x8)
    class UReplayableDestructionComponent* m_ReplayableDestructionComponent;          // 0x0510 (size: 0x8)
    class UHitBoxComponent* m_throwHitBox;                                            // 0x0518 (size: 0x8)
    float m_fTimeIgnoreFloor;                                                         // 0x0520 (size: 0x4)
    float m_fOnTargetHitSpeedReduction;                                               // 0x0524 (size: 0x4)
    float m_fMissingSpeedReduc;                                                       // 0x0528 (size: 0x4)
    float m_fMissedDistance;                                                          // 0x052C (size: 0x4)
    bool m_bApplyGravityWhenFlyingFreely;                                             // 0x0530 (size: 0x1)
    EBounceType m_eBounceType;                                                        // 0x0531 (size: 0x1)
    EBounceType m_eCurrentBounceType;                                                 // 0x0532 (size: 0x1)
    class UCurveFloat* m_BounceBackAngle;                                             // 0x0538 (size: 0x8)
    FFloatRange m_BounceBackRange;                                                    // 0x0540 (size: 0x10)
    bool m_bSimulatePhysicOnSpawn;                                                    // 0x0550 (size: 0x1)
    FSCCollisionResponsePreset m_ColProfileAtRest;                                    // 0x0554 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileAtRestOnBreakable;                         // 0x0584 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileThrown;                                    // 0x05B4 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileThrownNoCol;                               // 0x05E4 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileSnappedWithColWithoutTarget;               // 0x0614 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileSnappedWithColWithTarget;                  // 0x0644 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileSnapped;                                   // 0x0674 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileAfterHit;                                  // 0x06A4 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfileOnBounce;                                  // 0x06D4 (size: 0x30)
    FSCCollisionResponsePreset m_ColProfilePickedUp;                                  // 0x0704 (size: 0x30)
    EHeight m_eTargettedHeight;                                                       // 0x0740 (size: 0x1)
    EHeight m_eAltTargettedHeight;                                                    // 0x0741 (size: 0x1)
    float m_fHeightLimitForFootAnimation;                                             // 0x0744 (size: 0x4)
    bool m_bUseAlternateHeightForFreeThrow;                                           // 0x0748 (size: 0x1)
    float m_fOffsetDistTrace;                                                         // 0x074C (size: 0x4)
    float m_fDistToCheckCollOnPathFreely;                                             // 0x0750 (size: 0x4)
    float m_fSoundNoiseRadius;                                                        // 0x0754 (size: 0x4)
    bool m_bDestroyActorOnBreak;                                                      // 0x0758 (size: 0x1)
    TSubclassOf<class UThrowableData> m_throwableData;                                // 0x0770 (size: 0x8)
    EThrowableState m_eState;                                                         // 0x0778 (size: 0x1)

    void StateUpdated__DelegateSignature(EThrowableState _eNewState);
    void OnWakeUp(bool _bWakesUp);
    void CheckStabilisationForPhysicOptimization();
    bool BPF_UseFootToThrow(const class AFightingCharacter* _Instigator);
    void BPF_ThrowFreely(class AActor* _Instigator, bool _bForceOrientation, FRotator _rotationOffset);
    void BPF_ThrowAtTarget(class AActor* _target, class AActor* _Instigator, bool _bForceOrientation, FRotator _rotationOffset);
    void BPF_SetupThrow(class AFightingCharacter* _Instigator, class AActor* _target, FVector _vThrowDirection);
    void BPF_SetThrowableState(EThrowableState _eNewState);
    void BPF_OverrideThrowableData(TSubclassOf<class UThrowableData> _newThrowableData);
    bool BPF_IsTooCloseToThrow(const class AActor* _Instigator, const class AActor* _target);
    EThrowableState BPF_GetThrowableState();
    class UThrowableData* BPF_GetThrowableData();
    class AActor* BPF_GetTarget(const class AFightingCharacter* _character);
    EDebugTargetState BPF_GetDebugTargetState(const class AFightingCharacter* _character, float& _fOutDist);
    void BPE_OverrideBounceType(const class AActor* _Instigator, const class AActor* _target);
    void BPE_OnThrown();
    void BPE_GetHitBox(FHitBox& _outHitbox, class AActor* _actorHit);
}; // Size: 0x790

class ATraversalActor : public ASCActor
{
    bool m_bTraversalActive;                                                          // 0x02D8 (size: 0x1)
    bool m_bOverrideTraversalEntryAngle;                                              // 0x02D9 (size: 0x1)
    float m_fTraversalEntryAngle;                                                     // 0x02DC (size: 0x4)
    bool m_bOverrideTraversalExitAngle;                                               // 0x02E0 (size: 0x1)
    float m_fTraversalExitAngle;                                                      // 0x02E4 (size: 0x4)
    FVector m_vBoxExtentAllowed;                                                      // 0x02E8 (size: 0xC)
    FVector m_vBoxExtentForbidden;                                                    // 0x02F4 (size: 0xC)
    bool m_bHasForbiddenTraversalPart;                                                // 0x0300 (size: 0x1)
    ESimpleAxis m_eForbiddenAxis;                                                     // 0x0301 (size: 0x1)
    bool m_bUseEntryMaxDistFromTraversalCenter;                                       // 0x0302 (size: 0x1)
    float m_fEntryMaxDistFromTraversalCenter;                                         // 0x0304 (size: 0x4)
    float m_fLengthBetweenTwoNavLinks;                                                // 0x0308 (size: 0x4)
    float m_fNavLinkOffsetFromBoxExtents;                                             // 0x030C (size: 0x4)
    uint8 m_AllowedEntryTypes;                                                        // 0x0310 (size: 0x1)

    FVector BPE_GetTraversalEndPos();
    void BPE_GetTraversalAnimation(FAnimContainer& _outResult);
}; // Size: 0x320

class AUsableItem : public AActor
{
    class UShapeComponent* m_ShapeComponent;                                          // 0x02B0 (size: 0x8)
    FName m_ItemAttackName;                                                           // 0x02B8 (size: 0x8)
    TArray<FItemEffects> m_Effects;                                                   // 0x02C0 (size: 0x10)
    int32 m_iMatchesWithAvoid;                                                        // 0x02D0 (size: 0x4)

    EItemUseState BPF_GetItemUseState();
    float BPF_ComputeAttackKnockbackCoeff(class AActor* _Instigator, class AActor* Target, const FHitResult& _hitResult);
    void BPE_InterruptItemUseAction();
    void BPE_InstantUse();
    void BPE_EndUsePhase();
    void BPE_EndItemUseAction();
    void BPE_BeginUsePhase();
    void BPE_BeginItemUseAction();
}; // Size: 0x2E0

class AVitalPointActor : public ASCActor
{
    FVitalPointActorOnSelectionChangedDyn OnSelectionChangedDyn;                      // 0x02D8 (size: 0x10)
    void OnVitalSelectionChangedDyn(bool _bSelected, class AVitalPointActor* vitalPoint);
    FVitalPointActorOnVitalPointValidated OnVitalPointValidated;                      // 0x0300 (size: 0x10)
    void OnVitalPointValidated(class AVitalPointActor* vitalPoint);

    void OnVitalSelectionChangedDyn__DelegateSignature(bool _bSelected, class AVitalPointActor* vitalPoint);
    void OnVitalPointValidated__DelegateSignature(class AVitalPointActor* vitalPoint);
    void OnBillBoardSelectionChanged(bool _bSelected, class AAimingBillboardActor* _billboard);
    FVitalPointDataDefinition BPF_GetDefinition();
    class AActor* BPF_GetActorOwner();
}; // Size: 0x350

class AVoiceOverActor : public ALevelSequenceActor
{
    FVoiceOver m_CurrentVoiceOver;                                                    // 0x0330 (size: 0x38)
    float m_fDelayBetweenVoiceOvers;                                                  // 0x0368 (size: 0x4)

    void OnLoadingCompleted();
    void OnDelayAfterSequenceExpired();
    void OnCurrentSequenceFinished();
    void BPF_PlayVoiceOver(const FVoiceOver& _voiceOver);
    void BPE_OnSequenceFinished();
}; // Size: 0x390

class AVortexDamageItem : public AUsableItem
{
    float m_fMaxDistanceToTarget;                                                     // 0x02E0 (size: 0x4)

}; // Size: 0x2F0

class AWuguanPerfTestingLocations : public ASCTestingLocationsBase
{
    TArray<TSoftObjectPtr<AAISituationActor>> m_situationsToSpawn;                    // 0x02C0 (size: 0x10)

}; // Size: 0x320

class IAIWeaponTicketable : public IInterface
{
}; // Size: 0x28

class IBaseComponent : public IInterface
{
}; // Size: 0x28

class ICameraBearerInterface : public IInterface
{

    FTransform GetActorRefTransform(float _fDt);
}; // Size: 0x28

class IControllerButtonInterface : public IInterface
{

    void BPE_SetInputAction(InputAction _eAction, class UWidget* _owner, EControllerIconStyles _eIconStyle, EControllerIconAxisTypes _eAxisType, const FSCUserDefinedEnumHandler& _drawingStyle);
}; // Size: 0x28

class IGenericPickableActorInterface : public IInterface
{

    void OnPickedUp(const FNetStructPickUpObject& _pickupObjectOrderStruct, class AFightingCharacter* _picker);
    void OnOrderPickupEnd(const FNetStructPickUpObject& _pickupObjectOrderStruct, class AFightingCharacter* _picker);
}; // Size: 0x28

class IGhostGateCarrierInterface : public IInterface
{

    FSubZoneShortcutStruct GetSubzoneShortcut();
    class UStaticMeshComponent* GetStaticMeshComponentDoor();
    FVector GetColliderScale();
    class UShapeComponent* GetColliderRegularDoor();
}; // Size: 0x28

class IHandleInput : public IInterface
{

    bool BPE_HandleInput();
}; // Size: 0x28

class IHittableActor : public IInterface
{

    bool CanBeHitted(class AActor* _Instigator);
}; // Size: 0x28

class IInputAvailability : public IInterface
{
}; // Size: 0x28

class IInteractiveInterface : public IInterface
{

    bool CanInteract(class APawn* _Instigator, FText& _outReason);
}; // Size: 0x28

class IPerPlatformWidget : public IInterface
{
}; // Size: 0x28

class IReplayWidgetHandler : public IInterface
{

    class UReplayTimelineModel* BPF_GetTimelineModel();
    void BPF_GetTimelineDilatedTimeBounds(float& _fLowerBound, float& _fUpperBound);
    float BPF_GetTimelineDilatedDemoTimeAlpha(float _fDilatedDemoTime);
    FVector2D BPF_GetContainerLocalSize();
}; // Size: 0x28

class ISkillTreeMenuInterface : public IInterface
{

    void BPE_DebugSkillButtonUpdated();
}; // Size: 0x28

class ITargetableActor : public IInterface
{

    bool IsValidTarget(const class AActor* _targeter);
    EFactionsEnums GetFaction();
}; // Size: 0x28

class UAIAbandoningBTTask : public UAIBTTaskNode
{
    TArray<EOrderType> m_NoReactionDuringOrders;                                      // 0x0088 (size: 0x10)
    TArray<EOrderType> m_PlayReactionAfterOrders;                                     // 0x0098 (size: 0x10)

}; // Size: 0xA8

class UAIActionAttack : public UWGAiAction
{
    bool m_bCheckObstacles;                                                           // 0x0150 (size: 0x1)
    bool m_bCheckFriendlyFire;                                                        // 0x0151 (size: 0x1)

    void BPF_NotifyAttackStarted();
    void BPE_OnPreCreateOrderAttackParams(FName _paramsName, class UOrderAttackParams* _orderParams);
    void BPE_OnCreatedOrderAttackParams(FName _paramsName, class UOrderAttackParams* _orderParams);
    float BPE_GetAttackRange();
}; // Size: 0x158

class UAIActionChangeCombatRole : public UWGAiAction
{
    ESCAICombatRoles m_eCombatRoleToAssign;                                           // 0x0150 (size: 0x1)

}; // Size: 0x158

class UAIActionDash : public UAIActionAttack
{
    float m_fAttackRange;                                                             // 0x0158 (size: 0x4)
    FAnimContainer m_animation;                                                       // 0x0160 (size: 0x18)
    FWeaponAnimInfo m_WeaponAnimation;                                                // 0x0178 (size: 0x90)
    bool m_bUseTargetPositionPrediction;                                              // 0x0208 (size: 0x1)
    float m_fTargetPositionPredictionRatio;                                           // 0x020C (size: 0x4)
    bool m_bOverrideOrientation;                                                      // 0x0210 (size: 0x1)
    float m_fDirectionAngle;                                                          // 0x0214 (size: 0x4)
    float m_fDistance;                                                                // 0x0218 (size: 0x4)
    bool m_bSnapOnTarget;                                                             // 0x021C (size: 0x1)
    float m_fSnapDistance;                                                            // 0x0220 (size: 0x4)
    FAnimContainer m_AnimationPredash;                                                // 0x0228 (size: 0x18)
    FWeaponAnimInfo m_WeaponAnimationPredash;                                         // 0x0240 (size: 0x90)
    FAnimContainer m_AnimationCharge;                                                 // 0x02D0 (size: 0x18)
    FWeaponAnimInfo m_WeaponAnimationCharge;                                          // 0x02E8 (size: 0x90)
    float m_fChargeDuration;                                                          // 0x0378 (size: 0x4)
    FAnimContainer m_AnimationPostDash;                                               // 0x0380 (size: 0x18)
    FWeaponAnimInfo m_WeaponAnimationPostdash;                                        // 0x0398 (size: 0x90)

}; // Size: 0x428

class UAIActionDropObject : public UWGAiAction
{
    FVector m_vDropImpulse;                                                           // 0x0150 (size: 0xC)

    void BPF_DropObjectInHand();
}; // Size: 0x160

class UAIActionEventNotify : public USCAnimNotify
{
    FName m_EventName;                                                                // 0x0048 (size: 0x8)

}; // Size: 0x50

class UAIActionFetchObject : public UWGAiAction
{
    bool m_bFetchClosestWeaponIfNotSet;                                               // 0x0150 (size: 0x1)
    bool m_bUsePerceptionToFindWeapon;                                                // 0x0151 (size: 0x1)
    class AActor* m_ObjectToFetch;                                                    // 0x0158 (size: 0x8)

    void OnPickupStarting(uint8 _uiOrderId, class UOrderComponent* _OrderComponent);
    void BPF_SetObjectToFetch(class AActor* _objectToFetch);
}; // Size: 0x160

class UAIActionFetchObjectBTDecorator : public USCBTDecorator
{
}; // Size: 0x78

class UAIActionHasOrderParamDecorator : public USCBTDecorator
{
    FName m_OrderParamsName;                                                          // 0x0070 (size: 0x8)

}; // Size: 0x78

class UAIActionLaunchCombo : public USCAiAction
{
    FAIComboLaunchParameters m_Parameters;                                            // 0x0088 (size: 0x80)

}; // Size: 0x108

class UAIActionPatrol : public UWGAiAction
{
    class APathPatrol* m_Patrol;                                                      // 0x0150 (size: 0x8)

}; // Size: 0x158

class UAIActionPlayDialogLine : public UWGAiAction
{
    FDataTableRowHandle m_Dialog;                                                     // 0x0150 (size: 0x10)
    FText m_DialogText;                                                               // 0x0160 (size: 0x18)
    float m_fDuration;                                                                // 0x0178 (size: 0x4)
    class AActor* m_SecondaryActor;                                                   // 0x0180 (size: 0x8)
    class UAnimSequence* m_animation;                                                 // 0x0188 (size: 0x8)

}; // Size: 0x190

class UAIActionPlaySequence : public UWGAiAction
{
    TSoftObjectPtr<ALevelSequenceActor> m_LevelSequenceActor;                         // 0x0150 (size: 0x28)
    class ALevelSequenceActor* m_CreatedLevelSequenceActor;                           // 0x0178 (size: 0x8)

    void OnCreatedSequenceActorEndedPlay(class AActor* _actor, TEnumAsByte<EEndPlayReason::Type> _endPlayReason);
}; // Size: 0x180

class UAIActionRainDashes : public UAIActionAttack
{
    float m_fMinDistanceForFinalDash;                                                 // 0x0158 (size: 0x4)
    int8 m_iMaxNumberOfDashes;                                                        // 0x015C (size: 0x1)
    TSubclassOf<class UAIActionDash> m_FirstDashLeft;                                 // 0x0160 (size: 0x8)
    TSubclassOf<class UAIActionDash> m_FirstDashRight;                                // 0x0168 (size: 0x8)
    TSubclassOf<class UAIActionDash> m_IntermediateDashLeft;                          // 0x0170 (size: 0x8)
    TSubclassOf<class UAIActionDash> m_IntermediateDashRight;                         // 0x0178 (size: 0x8)
    TSubclassOf<class UAIActionDash> m_FinalDash;                                     // 0x0180 (size: 0x8)

    void BPF_OnFinishDash();
}; // Size: 0x1A0

class UAIActionStartConversation : public UWGAiAction
{
    FName m_StartingSegment;                                                          // 0x0150 (size: 0x8)
    bool m_bCutOtherDialogs;                                                          // 0x0158 (size: 0x1)
    bool m_bGenericSubtitles;                                                         // 0x0159 (size: 0x1)
    class ACharacter* m_SecondaryActor;                                               // 0x0160 (size: 0x8)

}; // Size: 0x168

class UAIActionThrowObject : public UAIActionAttack
{
}; // Size: 0x158

class UAIActionThrowObjectBTDecorator : public USCBTDecorator
{
}; // Size: 0x70

class UAIActionTimedPauseInCombat : public UWGAiAction
{
    float m_fPauseTime;                                                               // 0x0150 (size: 0x4)

}; // Size: 0x168

class UAIActionTraversalAttack : public UAIActionAttack
{
    float m_fMiniumDistBetweenInstigatorAndTarget;                                    // 0x0158 (size: 0x4)
    float m_fTargetRadiusPrecision;                                                   // 0x015C (size: 0x4)
    float m_fAttackCancelMinDistance;                                                 // 0x0160 (size: 0x4)
    float m_fEntryPointReEvaluatePrecision;                                           // 0x0164 (size: 0x4)
    float m_fOffsetOnTraversalSide;                                                   // 0x0168 (size: 0x4)

    void BPF_OnReachedEntryPoint();
}; // Size: 0x198

class UAIActionTriggerProxy : public UAIActionAttack
{
    bool m_bTriggerProxyDirectlyAtStart;                                              // 0x0158 (size: 0x1)

    void BPF_TriggerProxy();
    void BPF_SetProxyActorToTrigger(class AActor* _proxyActor);
}; // Size: 0x168

class UAIActionWait : public UWGAiAction
{
    float m_fDuration;                                                                // 0x0150 (size: 0x4)

}; // Size: 0x170

class UAIActionWallJumpAttack : public UAIActionAttack
{
    float m_fQueryResultLifetime;                                                     // 0x0158 (size: 0x4)
    float m_fQueryExecuteFrequency;                                                   // 0x015C (size: 0x4)
    class UEnvQuery* m_QueryTemplate;                                                 // 0x0160 (size: 0x8)
    FFloatRange m_ValidAngleRange;                                                    // 0x0168 (size: 0x10)
    FFloatRange m_DistToWallJumpPoint;                                                // 0x0178 (size: 0x10)
    int32 m_iDeprecationVersion;                                                      // 0x0188 (size: 0x4)
    FSCRangeFloatCurve m_angleRange;                                                  // 0x0190 (size: 0x28)
    FSCRangeFloatCurve m_DistToWallJumpSnap;                                          // 0x01B8 (size: 0x28)
    FSCRangeFloatCurve m_DistToWallJumpSnapTarget;                                    // 0x01E0 (size: 0x28)
    float m_fMaxJumpHeightWhenPossible;                                               // 0x0208 (size: 0x4)
    bool m_bAddBoxHalfHeightToJumpPoint;                                              // 0x020C (size: 0x1)
    FHitBox m_WallJumpAttackHitBox;                                                   // 0x0210 (size: 0x298)

    bool BPF_PrepareWallJumpAttack(class UAIFightingComponent* _aiComponent, TSubclassOf<class UAIActionWallJumpAttack> _action, class AActor* _wallJumpActor, const FVector& _vSnapLocation, const class AActor* _target, bool _bIgnoreAngleConstraint);
    bool BPF_PerformWallJumpAttackAction(class UAIFightingComponent* _aiComponent, TSubclassOf<class UAIActionWallJumpAttack> _action, class AActor* _wallJumpActor, const FVector& _vSnapLocation, FGameplayTag _behaviorTag, const class AActor* _target, FString& _outError, bool _bIgnoreAngleConstraint);
    bool BPF_ComputeWallJumpStartLocation(FVector& _vOutLocation, const class AFightingCharacter* _instigatorChara, const class AActor* _target, const class AActor* _wallJumpActor, const FVector& _vSnapLocation, TSubclassOf<class UAIActionWallJumpAttack> _attackClass);
}; // Size: 0x550

class UAIAttackTicketData : public UDataAsset
{
    FAttackTicketConfig m_Config;                                                     // 0x0030 (size: 0x120)
    int32 m_iSerializeVersion;                                                        // 0x0150 (size: 0x4)

}; // Size: 0x158

class UAIBTTaskNode : public USCBTTaskNode
{
    TArray<FBTTaskNodeRelevancyCondition> m_RelevancyConditions;                      // 0x0070 (size: 0x10)
    InputAction m_eCancelTaskOnAvailableInput;                                        // 0x0080 (size: 0x1)
    bool m_bCancelWaitedOrdersOnFinish;                                               // 0x0081 (size: 0x1)

}; // Size: 0x88

class UAIBaseBehaviourDataAsset : public UDataAsset
{
    float m_fProbabilityDepletedPerSecond;                                            // 0x0030 (size: 0x4)
    float m_fMinProbability;                                                          // 0x0034 (size: 0x4)
    float m_fInitialProbability;                                                      // 0x0038 (size: 0x4)
    float m_fCooldown;                                                                // 0x003C (size: 0x4)

}; // Size: 0x40

class UAIBehaviorSwitchActorComponent : public UActorComponent
{
    TArray<class ASpawnerGroup*> m_groupsToAlert;                                     // 0x00C0 (size: 0x10)
    bool m_AlertOnPrimitiveOverlap;                                                   // 0x00D0 (size: 0x1)
    EGlobalBehaviors m_eNewBehavior;                                                  // 0x00D1 (size: 0x1)

    void OnComponentStartOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
    void BPF_TriggerBehaviorChangeToAssociatedGroups(class AActor* _actorTriggeringTheAlert, bool _bSkipBark);
}; // Size: 0xD8

class UAIBehaviorTreeComponent : public USCBehaviorTreeComponent
{
}; // Size: 0x320

class UAIChangeRoleTriggerableActions : public USCAITriggerableActions
{
    ESCAICombatRoles m_eCombatRoleToAssign;                                           // 0x0028 (size: 0x1)

}; // Size: 0x30

class UAICharacterPoseData : public UWGCharacterPoseData
{
}; // Size: 0x98

class UAIComboCondition : public UComboTransitionCondition
{

    void BPF_GetEnvQueryParameterValue(FName _paramName, const class ASCCharacter* _owner, FSCTypedValue& _outValue);
    bool BPE_TestCondition(const class UAIFightingComponent* _aiComponent, const class AActor* _target);
    void BPE_GetEnvQueryParameterValue(FName _paramName, const class ASCCharacter* _owner, FSCTypedValue& _outValue);
}; // Size: 0xE0

class UAIComponent : public USCAIComponent
{
    FAIComponentOnSpawned OnSpawned;                                                  // 0x00E8 (size: 0x10)
    void SpawnedDelegate(class AAISpawner* Spawner);
    class UArchetypeAsset* m_CurrentAIArchetype;                                      // 0x00F8 (size: 0x8)
    TArray<FSCSoundSwitchValue> m_VoiceArchetypeSwitches;                             // 0x0100 (size: 0x10)
    class AAISpawner* m_Spawner;                                                      // 0x0120 (size: 0x8)
    class UBehaviorTree* m_Behavior;                                                  // 0x0128 (size: 0x8)

    void SpawnedDelegate__DelegateSignature(class AAISpawner* Spawner);
    void OnRep_Spawner();
    void OnAIInitialized();
    void BPF_TriggerBehaviorChange(class AActor* _alertedBy, const EGlobalBehaviors _eNewBehavior, const EAlertedReason _eAlertedReason, bool _bSkipBark);
    FSCSoundSwitchValue BPF_GetVoiceArchetypeSwitch();
    class AAISpawner* BPF_GetSpawner();
    class UArchetypeAsset* BPF_GetArchetypeData();
}; // Size: 0x138

class UAIContextualDefense : public UDataAsset
{
    TArray<class UAIInfluenceNode*> m_Nodes;                                          // 0x0030 (size: 0x10)

}; // Size: 0x40

class UAICounterFeintBehaviourDataAsset : public UAIBaseBehaviourDataAsset
{
}; // Size: 0x40

class UAIDataProviderActionWallJumpAttack : public UAIDataProvider_QueryParams
{
    EWallJumpAttackParameter m_eParameter;                                            // 0x0040 (size: 0x1)

}; // Size: 0x48

class UAIDebugSpawnerComponent : public UActorComponent
{
    TArray<FAIDebugSpawnerInstance> m_Spawners;                                       // 0x00C0 (size: 0x10)

    void BPF_SpawnAIs(int32 _iCoun);
}; // Size: 0x138

class UAIDefenseBTTask : public UAIBTTaskNode
{
    bool m_bFinishWhenIsNotStun;                                                      // 0x008A (size: 0x1)

}; // Size: 0x90

class UAIFightingCameraWeightComponent : public UFightingCameraWeightComponent
{
    float m_fDamageValidityWindow;                                                    // 0x0198 (size: 0x4)
    bool m_bIgnoreFriendlyDamage;                                                     // 0x019C (size: 0x1)
    class UCurveFloat* m_WeightByDamageCurve;                                         // 0x01A0 (size: 0x8)
    FStateWeight m_ticketStateWeight;                                                 // 0x01A8 (size: 0x10)

}; // Size: 0x1C0

class UAIFightingComponent : public UAIComponent
{
    FAIFightingComponentOnOpponentAvoidedAttack OnOpponentAvoidedAttack;              // 0x0138 (size: 0x10)
    void OnOpponentAvoidedAttack(EAvoidType _eAvoidType, const FHitRequest& _hitRequest);
    FAIFightingComponentOnComboFinished OnComboFinished;                              // 0x0148 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnComboStarted OnComboStarted;                                // 0x0158 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnAICalledForHelp OnAICalledForHelp;                          // 0x0168 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnAIPhaseChangedDynamic OnAIPhaseChangedDynamic;              // 0x0178 (size: 0x10)
    void OnAIPhaseChangedDynamic(int32 _iPreviousPhase, int32 _iCurrentPhase, FName _PhaseName);
    FAIFightingComponentOnStartFetchingObject OnStartFetchingObject;                  // 0x0188 (size: 0x10)
    void FetchObjectDelegate(class AActor* _actor, float _fetchDistance);
    FAIFightingComponentOnStartThrowingObject OnStartThrowingObject;                  // 0x0198 (size: 0x10)
    void ThrowObjectDelegate(class AActor* _objectThrown, class AActor* _targetActor);
    FAIFightingComponentOnCombatRoleChangedDynamic OnCombatRoleChangedDynamic;        // 0x0208 (size: 0x10)
    void OnCombatRoleChangedDynamic(ESCAICombatRoles NewCombatRole, ESCAICombatRolesChangeReason ChangeReason);
    FAIFightingComponentOnGlobalBehaviorChangedDelegate OnGlobalBehaviorChangedDelegate; // 0x0248 (size: 0x10)
    void AIGlobalBehaviorChangedDynamic(EGlobalBehaviors NewBehavior, const bool FromDialog);
    FAIFightingComponentOnAbandonning OnAbandonning;                                  // 0x0258 (size: 0x10)
    void MulticastDelegateActorDyn(class AActor* _actor);
    FAIFightingComponentOnPostGlobalBehaviorChangedDelegate OnPostGlobalBehaviorChangedDelegate; // 0x0268 (size: 0x10)
    void AIGlobalBehaviorChangedDynamic(EGlobalBehaviors NewBehavior, const bool FromDialog);
    FAIFightingComponentOnSeenEnemyDeath OnSeenEnemyDeath;                            // 0x0278 (size: 0x10)
    void AINotify(class UAIFightingComponent* Who);
    FAIFightingComponentOnEnemyRevivalDelegate OnEnemyRevivalDelegate;                // 0x0288 (size: 0x10)
    void AINotify(class UAIFightingComponent* Who);
    FAIFightingComponentOnKillSpare OnKillSpare;                                      // 0x0298 (size: 0x10)
    void AINotify(class UAIFightingComponent* Who);
    FAIFightingComponentOnDefensePreparedDelegate OnDefensePreparedDelegate;          // 0x02A8 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnDefenseStarted OnDefenseStarted;                            // 0x02B8 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnDefenseCancelled OnDefenseCancelled;                        // 0x02C8 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnDefenseFinished OnDefenseFinished;                          // 0x02D8 (size: 0x10)
    void DynamicMulticast();
    FAIFightingComponentOnPendantChargesAdded OnPendantChargesAdded;                  // 0x02F8 (size: 0x10)
    void PendantCharge(int32 _iNumOfCharges);
    FAIFightingComponent_OnEnemyOrderStateChanged m_OnEnemyOrderStateChanged;         // 0x0308 (size: 0x10)
    void AIEnemyOrderStateChanged(EOrderState _eOrderState, EOrderType _eOrderType);
    FAIFightingComponentOnDeathCounterOnKilledChanged OnDeathCounterOnKilledChanged;  // 0x0318 (size: 0x10)
    void DeathCounter(int32 _iCounterDecrease, bool _bReset);
    FAIFightingComponentOnPrefightLowStructureStateChanged OnPrefightLowStructureStateChanged; // 0x0328 (size: 0x10)
    void PrefightLowStructureChanged(bool _bForcedLowStructure);
    FAIFightingComponentOnMCDominationStepChangedDelegate OnMCDominationStepChangedDelegate; // 0x0338 (size: 0x10)
    void AIDominationStepChanged(EMcDominationGaugeSteps _eNewStep);
    int32 m_iDeathCounterDecreaseWhenKilled;                                          // 0x034C (size: 0x4)
    bool m_bDeathCounterResetWhenKilled;                                              // 0x0350 (size: 0x1)
    float m_fChainedDodgeDelay;                                                       // 0x03C0 (size: 0x4)
    float m_fLateralDodgeAngle;                                                       // 0x03C4 (size: 0x4)
    float m_fMemoryValidity;                                                          // 0x03C8 (size: 0x4)
    float m_fPickupMaxDist;                                                           // 0x03CC (size: 0x4)
    float m_fThreatMinDistForPickup;                                                  // 0x03D0 (size: 0x4)
    float m_fAlertPropagationDistance;                                                // 0x03D4 (size: 0x4)
    bool m_bCanBeAlerted;                                                             // 0x03D8 (size: 0x1)
    TArray<FVariableWeightEnumHandler> m_DisabledVariableWeightsOnSpawnerIdle;        // 0x03E0 (size: 0x10)
    uint8 m_uiIdleIndex;                                                              // 0x03F0 (size: 0x1)
    FAnimContainer m_SurprisedAnimation;                                              // 0x0438 (size: 0x60)
    FAnimContainer m_HeavySurprisedAnimation;                                         // 0x0498 (size: 0x60)
    FTurnAnimationArray m_TurnAnimations;                                             // 0x04F8 (size: 0x40)
    TArray<class UBlendSpace1D*> m_AbandoningBlendSpaces;                             // 0x0538 (size: 0x10)
    FFloatRange m_fAbandoningPlayRateRange;                                           // 0x0548 (size: 0x10)
    TWeakObjectPtr<class UAIPhaseScenario> m_PhaseScenario;                           // 0x0560 (size: 0x8)
    int32 m_iCurrentPhaseNodeIndex;                                                   // 0x0568 (size: 0x4)
    FPhasesTransitionObjectCache m_PhaseTransitionObjects;                            // 0x0618 (size: 0x10)
    TArray<class UAIPhaseTransition*> m_CurrentPhaseTransitions;                      // 0x0628 (size: 0x10)
    TArray<FCarriedPropDataRow> m_carriedPropsInfoRep;                                // 0x0958 (size: 0x10)

    void ThrowObjectDelegate__DelegateSignature(class AActor* _objectThrown, class AActor* _targetActor);
    void PrefightLowStructureChanged__DelegateSignature(bool _bForcedLowStructure);
    void PendantCharge__DelegateSignature(int32 _iNumOfCharges);
    void OnTargetHitDuringAttack(const FHitDescription& _hitDescription);
    void OnRep_CarriedProps();
    void OnOrderTraversalEnded(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnOrderGrabbedStarted(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnOrderGrabbedEnded(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnOrderAvoidedStarted(uint8 _uiOrderId, class UOrderComponent* _OrderComponent);
    void OnOrderAttackStarted(uint8 _uiOrderId, class UOrderComponent* _OrderComponent);
    void OnOpponentAvoidedAttack__DelegateSignature(EAvoidType _eAvoidType, const FHitRequest& _hitRequest);
    void OnMoveStatusChanged(class UFightingMovementComponent* _movementComponent);
    void OnEnemyFalling();
    void OnAIPhaseChangeSequenceFinished();
    void OnAIPhaseChangedDynamic__DelegateSignature(int32 _iPreviousPhase, int32 _iCurrentPhase, FName _PhaseName);
    void HittedDetection(const FHitDescription& _hitDescription);
    void FetchObjectDelegate__DelegateSignature(class AActor* _actor, float _fetchDistance);
    void DeathCounter__DelegateSignature(int32 _iCounterDecrease, bool _bReset);
    void BPF_UnspawnCarriedProps();
    EDefenseTactics BPF_TestContextualDefense(class UAttackDB* _attackToTest);
    bool BPF_SwitchToPhaseBySoftLink(const FAIPhaseNodeSoftLink& _phaseLink);
    void BPF_SwitchToPhaseByName(FName _name);
    bool BPF_SwitchToPhaseByHardLink(const FAIPhaseNodeHardLink& _phaseLink);
    void BPF_SwitchToPhase(int32 _iPhase);
    void BPF_SwitchToIdle(bool _bEnabledPerception);
    void BPF_SwitchToFriendly(const bool _bFromDialog);
    void BPF_SwitchToCombatRole(ESCAICombatRoles _eNewRole);
    void BPF_SwitchToAbandoning(const bool _bFromDialog, const bool _bShouldStayInAbandonStateForever);
    void BPF_SpawnCarriedProps();
    void BPF_SetStructureGaugeVisible(bool _bVisible);
    void BPF_SetPhaseMesh(int32 _iPhaseNodeIndex);
    void BPF_SetPerceptionEnabled(bool _bEnabled);
    void BPF_SetPathPatrol(class APathPatrol* _newpathPatrol);
    void BPF_SetHealthGaugeVisible(bool _bVisible);
    void BPF_SetDeathCounterResetWhenKilled(bool _bReset);
    void BPF_SetDeathCounterDecreaseWhenKilled(int32 _iCount);
    void BPF_SetCarriedPendantCharges(int32 _iCharges);
    void BPF_SetCanUseReactionAction(bool _bValue);
    void BPF_SetCanTakeAttackTicket(bool _bValue);
    void BPF_SetCanDefend(bool _bValue);
    void BPF_RespawnStartupWeapon();
    void BPF_ResetComboToDefault(FName _nameOfDifficultyLevel);
    void BPF_ResetAvoidAbilityToDefault();
    void BPF_RemoveCarriedProps(int32 _iIndex);
    void BPF_PushContextualDefenseOverride(FName _overrideName, class UAIContextualDefense* _contextualDefenseOverride, EAIContextualDefenseType _eType);
    void BPF_PopContextualDefenseOverride(FName _overrideName, EAIContextualDefenseType _eType);
    void BPF_OverrideCombo(FName _nameOfDifficultyLevel, class UCombo* _combo);
    void BPF_OverrideAvoidAbility(const TSubclassOf<class UAvoidAbility>& _avoidAbility);
    bool BPF_IsStructureGaugeVisible();
    bool BPF_IsInPrefightLowStructure();
    bool BPF_IsInLastManPhase();
    bool BPF_IsHealthGaugeVisible();
    bool BPF_HasSpawnerGroupConfrontationDialog();
    bool BPF_HasPathPatrol();
    bool BPF_HasAttackTicket();
    int32 BPF_GetXPBonus();
    EDefenseTactics BPF_GetPreparedDefenseTactic();
    int32 BPF_GetNbOccurencesInStructureBroken();
    EAlertedReason BPF_GetLastAlertedReason();
    EGlobalBehaviors BPF_GetGlobalBehavior(bool _bWithTimer);
    class AActor* BPF_GetEnemy();
    void BPF_GetDefenseTargetAttackInfos(FAIDefenseTargetAttackInfos& _outTargetAttackInfos);
    void BPF_GetDefenseLastDefendedTargetAttackInfos(FAIDefenseTargetAttackInfos& _outTargetAttackInfos);
    int32 BPF_GetCurrentPhaseNodeIndex();
    void BPF_GetCurrentPhase(FName& _outName, class UAIPhaseScenario*& _outScenario);
    EDefenseTactics BPF_GetCurrentDefenseTactic();
    ESCAICombatRoles BPF_GetCurrentCombatRole();
    TArray<class AActor*> BPF_GetCarriedProps();
    int32 BPF_GetCarriedPendantCharges();
    bool BPF_GetCanUseReactionAction();
    class UObject* BPF_GetBlackBoardValueAsObject(FName _key);
    void BPF_ForgetEnemy();
    void BPF_ForceEnemyReactionBehavior(EGlobalBehaviors _eGlobalBehavior);
    void BPF_ForceEnemy(class AActor* _Enemy, EGlobalBehaviors _eForcedDetectionReaction);
    void BPF_EndPendingPhaseTransition();
    bool BPF_CanTriggerSpare();
    void BeforeGhostDamagesReset();
    void AINotify__DelegateSignature(class UAIFightingComponent* Who);
    void AIGlobalBehaviorChangedDynamic__DelegateSignature(EGlobalBehaviors NewBehavior, const bool FromDialog);
    void AIEnemyOrderStateChanged__DelegateSignature(EOrderState _eOrderState, EOrderType _eOrderType);
    void AIDominationStepChanged__DelegateSignature(EMcDominationGaugeSteps _eNewStep);
}; // Size: 0x968

class UAIFightingStateBTTask : public UAIBTTaskNode
{
    EFightingState m_eFightingState;                                                  // 0x0088 (size: 0x1)

}; // Size: 0x90

class UAIHelpers : public UBlueprintFunctionLibrary
{

    void FightingAIDelegate__DelegateSignature(class UAIFightingComponent* AIComponent);
    FSCAITicketEnum Conv_SCEnumToAITicketEnum(const FSCUserDefinedEnumHandler& _scEnum);
    class UAIFightingComponent* Conv_PawnToAiComponent(class APawn* _pawn);
    class UAIFightingComponent* Conv_AISpawnerToAiComponent(class AAISpawner* _spawner);
    class AFightingCharacter* Conv_AiComponentToFightingCharacter(class UAIFightingComponent* _aiComponent);
    bool BPF_TestConditionInstances(const TArray<FAIConditionClassInstance>& _conditions, const class AFightingCharacter* _owner);
    bool BPF_TestConditionInstance(const FAIConditionClassInstance& _condition, const class AFightingCharacter* _owner);
    void BPF_SetTicketsCooldown(const FSCAITicketEnum& _ticketEnum, class UAIFightingComponent* _resquester, float _fTimer);
    void BPF_SetAttackJokerSituationsEnabled(const TArray<EAIAttackTicketJokerSituation>& _situationsToSet, class UAIFightingComponent* _requester, bool _bEnabled);
    void BPF_SetAllAttackJokerSituationsEnabled(class UAIFightingComponent* _requester, bool _bEnabled);
    void BPF_ResetTicketsCooldown(const FSCAITicketEnum& _ticketEnum, class UAIFightingComponent* _resquester);
    void BPF_ResetAllTicketsCooldown(class UAIFightingComponent* _requester);
    bool BPF_RequestPassiveAttackTicket(const FSCAITicketEnum& _ticketEnum, class UAIFightingComponent* _resquester);
    void BPF_ReleaseOwnedAttackTicket(class UAIFightingComponent* _resquester);
    void BPF_ReleaseAttackTicket(const FSCAITicketEnum& _ticketEnum, class UAIFightingComponent* _resquester);
    bool BPF_ProjectPointToNavigation(const class UObject* _worldCtxt, const FVector& _vPoint, FVector& _vOutProjected, const FVector& _vExtent);
    bool BPF_IsPassiveAttackTicketAvailable(const FSCAITicketEnum& _ticketEnum, class UAIFightingComponent* _resquester);
    bool BPF_IsCharacterFrozenBySanctuary(const class AFightingCharacter* _AICharacter);
    bool BPF_IsCharacterAssignedToSanctuary(const class AFightingCharacter* _AICharacter);
    bool BPF_IsAttackerRegisteredInCombatForTarget(const class AActor* _attackerToTest, const class AActor* _targetActor);
    bool BPF_IsAnySanctuaryActive();
    bool BPF_HasAttackTicket(class UAIFightingComponent* _resquester, const FSCAITicketEnum& _ticket);
    void BPF_GetTicketCooldownRemaining(const class UAIFightingComponent* _requester, const FSCAITicketEnum& _ticketEnum, float& _fOutMin, float& _fOutMax, int32& _iOutTicketsCount);
    void BPF_GetOwnedAttackTickets(class UAIFightingComponent* _resquester, TArray<FSCAITicketEnum>& _outOwnedTickets);
    int32 BPF_GetCurrentNumberOfAIAttackers(const class AActor* _targetActor);
    void BPF_ForceAssignAICharacterToSanctuary(const class UAIFightingComponent* _aiFightingComponent);
    void BPF_AddDomination(float _fDominationBonus);
}; // Size: 0x28

class UAIIdleDB : public UDataAsset
{
    FIdleAnimAndTransition m_IdleAndExitAnimation;                                    // 0x0030 (size: 0x78)
    ESCRotationWay m_eSouthRotationWay;                                               // 0x00A8 (size: 0x1)
    bool m_bCanPlayFidget;                                                            // 0x00A9 (size: 0x1)
    ELookAtApplyMode m_eLookAtApplyMode;                                              // 0x00AA (size: 0x1)

}; // Size: 0xB0

class UAIInfluenceNode : public UObject
{
    int32 m_iVerNum;                                                                  // 0x0028 (size: 0x4)
    TArray<class UAIInfluenceNode*> m_LinkedNodes;                                    // 0x0030 (size: 0x10)
    int32 m_iNodeIndex;                                                               // 0x0040 (size: 0x4)

}; // Size: 0x48

class UAIInfluenceTest : public UAIInfluenceNode
{
    bool m_bInverted;                                                                 // 0x0048 (size: 0x1)

}; // Size: 0x50

class UAIInfluence_TestSequence : public UAIInfluenceNode
{
    TArray<class UAIInfluenceTest*> m_Tests;                                          // 0x0048 (size: 0x10)
    float m_fProbability;                                                             // 0x0058 (size: 0x4)

}; // Size: 0x60

class UAILaunchAttackTriggerableAction : public USCAITriggerableActions
{
    FSCAITicketEnum m_ComboStartNodeEnumValue;                                        // 0x0028 (size: 0x50)
    bool m_bCheckCanAttack;                                                           // 0x0078 (size: 0x1)
    bool m_bTestTicketAvailable;                                                      // 0x0079 (size: 0x1)
    bool m_bResetTicketCooldown;                                                      // 0x007A (size: 0x1)

}; // Size: 0x80

class UAIManagerHelpers : public UBlueprintFunctionLibrary
{

    void BPF_SetWantedArchetypeType(EArchetypeType _eWantedType);
    void BPF_SetAIPositioningOptionToggled(const class AActor* _targetActor, EAIPositioningOption _eOption, bool _bToggled);
    void BPF_SetAICanDropWeapon(bool _bCanDropWeapon);
    bool BPF_IsAIPositioningOptionToggled(const class AActor* _targetActor, EAIPositioningOption _eOption);
    void BPF_GetRemainingAisInActiveSituations(TArray<class UAIFightingComponent*>& _outAiComponents);
    int32 BPF_GetRawLastManGauge();
    class AAIDirectorActor* BPF_GetDirectorActor();
    float BPF_GetDifficultyLevelGauge();
    void BPF_GetAllAiSituations(TArray<class AAISituationActor*>& _outAiSituations);
    void BPF_GetAllActiveAiSituations(TArray<class AAISituationActor*>& _outAiSituations);
    class AActor* BPF_GetAiSituationNamedActor(const class UAIFightingComponent* _aiComponent, const FAISituationNamedActor& _name);
    void BPF_GetAiSituationActors(TArray<class AAISituationActor*>& _outAiSituations, const class UAIFightingComponent* _aiComponent, bool _bIncludeAlertedSpawners);
    void BPF_AllowStructureDamageOnAI(bool _bAllowStructureDamage);
}; // Size: 0x28

class UAIMasterArchetype : public UObject
{
    TMap<class EDefenseTactics, class FSCAITriggerableActionsArray> m_DefaultPostDefenseActions; // 0x0028 (size: 0x50)
    TMap<class EDefenseTactics, class FAIConditionedActionArray> m_DefaultPostDefenseActionsMap; // 0x0078 (size: 0x50)
    TArray<FAIAttackReaction> m_ReactionAttacks;                                      // 0x00C8 (size: 0x10)
    TArray<FAIActionReaction> m_ReactionActions;                                      // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class UAIMoveToBTTask : public UBTTask_MoveTo
{
    FBlackboardKeySelector AcceptableRadiusKey;                                       // 0x00B0 (size: 0x28)
    FBlackboardKeySelector FilterClassKey;                                            // 0x00D8 (size: 0x28)
    bool m_bCanPredictStopTransition;                                                 // 0x0100 (size: 0x1)
    bool m_bOverridePacingGoalActor;                                                  // 0x0101 (size: 0x1)

}; // Size: 0x108

class UAIPhaseNodeHelper : public UBlueprintFunctionLibrary
{

    int32 BPF_GetPhaseNodeIndex(const FAIPhaseNodeHardLink& _nodeHardLink);
}; // Size: 0x28

class UAIPhaseScenario : public UObject
{
    TSubclassOf<class UArchetypeAsset> m_rootPhase;                                   // 0x0028 (size: 0x8)
    TArray<FPhaseNodeHandler> m_PhaseNodes;                                           // 0x0030 (size: 0x10)

    FName BPF_GetPhaseNameFromIndex(int32 _iPhaseIndex);
}; // Size: 0x40

class UAIPhaseTransition : public UObject
{

    bool BPF_GotoNextPhase();
    void BPE_OnParentPhaseStarted(class UAIFightingComponent* _aiComponent);
    void BPE_OnParentPhaseEnded(class UAIFightingComponent* _aiComponent);
    FString BPE_GetLog();
}; // Size: 0x40

class UAIPhaseTransitionBossKill : public UAIPhaseTransition
{

    void OnKillSpare(class UAIFightingComponent* _aiComponent);
}; // Size: 0x50

class UAIPhaseTransitionBossSpare : public UAIPhaseTransitionBossKill
{
}; // Size: 0x50

class UAIPhaseTransitionDialogCompleted : public UAIPhaseTransition
{
    FName m_DialogToWaitFor;                                                          // 0x0040 (size: 0x8)

    void OnInteractiveDialogInterrupted();
}; // Size: 0x58

class UAIPhaseTransitionDifficultyLevelChanged : public UAIPhaseTransition
{
    FSCMathExpressionFloat m_Expression;                                              // 0x0040 (size: 0x20)

}; // Size: 0x60

class UAIPhaseTransitionFocusAttackVictim : public UAIPhaseTransition
{
    class UVitalPointData* m_VitalPoint;                                              // 0x0040 (size: 0x8)

}; // Size: 0x50

class UAIPhaseTransitionHealthChange : public UAIPhaseTransition
{
    FSCMathExpressionFloat m_Expression;                                              // 0x0040 (size: 0x20)

    void OnDeathDismiss(class UHealthComponent* _healthComponent);
}; // Size: 0x68

class UAIPhaseTransitionPhaseDuration : public UAIPhaseTransition
{
    float m_fDuration;                                                                // 0x0040 (size: 0x4)

    void OnComboFinished();
}; // Size: 0x60

class UAIPhaseTransitionRoleChange : public UAIPhaseTransition
{
    ESCAICombatRoles m_eRole;                                                         // 0x0040 (size: 0x1)

}; // Size: 0x60

class UAIPhaseTransitionSequence : public UWGLevelSequence
{

    void BPF_OnLevelTransition(int32 _iTransitionIndex);
    void BPF_NotifyEvent(EAIPhaseTransitionEvents _event);
}; // Size: 0x100

class UAIPhaseTransitionSituationAiCountChange : public UAIPhaseTransition
{
    FSCMathExpressionInteger m_Expression;                                            // 0x0040 (size: 0x20)

}; // Size: 0x70

class UAIPhaseTransitionTakedown : public UAIPhaseTransition
{
}; // Size: 0x48

class UAIPositionningPOIComponent : public UActorComponent
{
    FAIPositionningPOI m_Data;                                                        // 0x00C0 (size: 0x60)
    TArray<class AAISpawner*> m_AllowedSpawners;                                      // 0x0120 (size: 0x10)

    void BPF_SetData(const FAIPositionningPOI& _data, const TArray<class AAISpawner*>& _allowedSpawners);
}; // Size: 0x160

class UAIReactionActionService : public UBTService
{
}; // Size: 0x70

class UAIReactionAttackService : public UBTService
{
}; // Size: 0x70

class UAISanctuaryComponent : public UActorComponent
{
    FInt32Range m_RangeNbOfEnnemies;                                                  // 0x00C0 (size: 0x10)
    bool m_bSanctuaryHasLimitedDuration;                                              // 0x00D0 (size: 0x1)
    float m_fSanctuaryDuration;                                                       // 0x00D4 (size: 0x4)
    bool m_bSendBarkEventWhenSanctuaryIsSafe;                                         // 0x00D8 (size: 0x1)

}; // Size: 0x148

class UAISenseConfig_SCClose : public UAISenseConfig_Sight
{
}; // Size: 0x70

class UAISituationVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class UAISizeDb : public UDataAsset
{
    FVector m_vScale;                                                                 // 0x0030 (size: 0xC)
    TArray<FVector> m_TargetRelativeLocation;                                         // 0x0040 (size: 0x10)

}; // Size: 0x50

class UAIWallJumAttack_EQContext_ItemWJStartLocation : public UEnvQueryContext
{
}; // Size: 0x28

class UAIWallJumpAttackHitOrderService : public UHitOrderService
{
}; // Size: 0x2C8

class UAIWallJumpFindActorToTargetCondition : public UComboAIConditionFindActorEnvQuery
{
    TSubclassOf<class UAIActionWallJumpAttack> m_AttackAction;                        // 0x0120 (size: 0x8)

    TSubclassOf<class UAIActionWallJumpAttack> BPF_GetAttackActionClass();
    class UAIActionWallJumpAttack* BPF_GetAttackAction();
}; // Size: 0x128

class UAIWaveDirectorVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class UASMAIComponent : public UASMComponent
{
}; // Size: 0x110

class UASMComponent : public UActorComponent
{

    EFightingActionState BPF_GetCurrentActionState();
}; // Size: 0x110

class UASMDetectionComponent : public UActorComponent
{
    TArray<class TSubclassOf<USCGameplayAbility>> m_AbilityDetection;                 // 0x00D8 (size: 0x10)

}; // Size: 0x150

class UASMPlayerComponent : public UASMComponent
{
}; // Size: 0x110

class UAbilityHitActionLauncher : public UHitActionLauncher
{
    FGameplayTag m_InstigatorEventTag;                                                // 0x0038 (size: 0x8)
    FGameplayTag m_VictimEventTag;                                                    // 0x0040 (size: 0x8)
    bool m_bApplyDamage;                                                              // 0x0048 (size: 0x1)
    bool m_bNotifyHitted;                                                             // 0x0049 (size: 0x1)
    bool m_bApplyFreezeFrame;                                                         // 0x004A (size: 0x1)

}; // Size: 0x50

class UAbilityPayload : public UObject
{
}; // Size: 0x28

class UAbilityTask_DetectInputAction : public UAbilityTask
{
    FAbilityTask_DetectInputAction_OnInputActionDetected m_OnInputActionDetected;     // 0x0080 (size: 0x10)
    void DetectInputActionDelegate();

    class UAbilityTask_DetectInputAction* BPF_DetectInputAction(class UGameplayAbility* _owningAbility, InputAction _eAction, bool _bDetectDeactivation, bool _bEndTaskOnDetected, InputContext _eInputContext);
}; // Size: 0x98

class UAbilityTask_HandleDefense : public UAbilityTask
{

    class UAbilityTask_HandleDefense* BPF_HandleDefense(class UGameplayAbility* _owningAbility, EHitDismissReason _eDismissReason);
}; // Size: 0x90

class UAbilityTask_HandleFocusBillboard : public UAbilityTask
{
    FAbilityTask_HandleFocusBillboard_OnVitalPointSelected m_OnVitalPointSelected;    // 0x0080 (size: 0x10)
    void HandleFocusBillboardDelegate(class AVitalPointActor* _target);

    class UAbilityTask_HandleFocusBillboard* BPF_HandleFocusBillboard(class UGameplayAbility* _owningAbility, const FTargetForSlotsEnumHandler& _focusTargetSlot);
    class AAimingBillboardActor* BPF_GetAimedVitalPoint();
    class AAimingBillboardActor* BPF_GetAimedBillboard();
}; // Size: 0x100

class UAbilityTask_PushAvailabilityLayers : public UAbilityTask
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0080 (size: 0x8)

    class UAbilityTask_PushAvailabilityLayers* BPF_PushAvailabilityLayerWithContext(class UGameplayAbility* _owningAbility, class UAvailabilityLayerData* _AvailabilityLayerData, EALBinaryOperation _eOperation, int32 m_iPriority, bool _bPushContext, EALPriority _eContextPriority);
    class UAbilityTask_PushAvailabilityLayers* BPF_PushAvailabilityLayer(class UGameplayAbility* _owningAbility, class UAvailabilityLayerData* _AvailabilityLayerData, EALBinaryOperation _eOperation, int32 m_iPriority);
}; // Size: 0x98

class UAbilityTask_SlowMotionTask : public UAbilityTask
{
    class UCurveFloat* m_Curve;                                                       // 0x0080 (size: 0x8)
    FAbilityTask_SlowMotionTask_OnFinish m_OnFinish;                                  // 0x0098 (size: 0x10)
    void SlowMotionTaskDelegate();
    FAbilityTask_SlowMotionTask_OnStarted m_OnStarted;                                // 0x00A8 (size: 0x10)
    void SlowMotionTaskDelegate();
    FAbilityTask_SlowMotionTask_OnPaused m_OnPaused;                                  // 0x00B8 (size: 0x10)
    void SlowMotionTaskDelegate();

    class UAbilityTask_SlowMotionTask* BPF_SlowMotionTask(class UGameplayAbility* _owningAbility, class UCurveFloat* _curve, float _fScale, float _fBlendDuration, float _fCameraSlowMotionFactor, bool _bBlockOthers, bool _bScaleInputStack, bool _bStopOnOtherSlomo, bool _bForce);
}; // Size: 0xE8

class UAbilityTask_WaitUnscaled : public UAbilityTask
{
    FAbilityTask_WaitUnscaled_OnFinish m_OnFinish;                                    // 0x0080 (size: 0x10)
    void WaitUnscaled();

    class UAbilityTask_WaitUnscaled* BPF_WaitUnscaled(class UGameplayAbility* _owningAbility, float _fDuration);
}; // Size: 0x98

class UAbsorbDB : public UDataAsset
{
    float m_fDuration;                                                                // 0x0030 (size: 0x4)
    class UCurveFloat* m_fAttackScaleScurve;                                          // 0x0038 (size: 0x8)
    float m_fSpecialAbilityDuration;                                                  // 0x0040 (size: 0x4)
    int32 m_iFrameBuildUp;                                                            // 0x0044 (size: 0x4)
    int32 m_iFrameRelease;                                                            // 0x0048 (size: 0x4)
    float m_fSpecialAbilityGuardGaugeCost;                                            // 0x004C (size: 0x4)
    class UCurveFloat* m_SpecialAbilityMovementDynamic;                               // 0x0050 (size: 0x8)
    bool m_bSpecialAbilityConsumStamina;                                              // 0x0058 (size: 0x1)
    bool m_bSpecialAbilityHasImpactOnGuardGauge;                                      // 0x0059 (size: 0x1)
    bool m_bSpecialAbilityOverrideAnimDynamicByCurve;                                 // 0x005A (size: 0x1)
    float m_fSpecialAbilityTrackingDuration;                                          // 0x005C (size: 0x4)
    class UAbsorbPropertyDB* m_DefaultAbsorbPropertyDB;                               // 0x0060 (size: 0x8)
    float m_fDamageToRecoryRatio;                                                     // 0x0068 (size: 0x4)
    float m_fDamageToRecoryRatioOnGuard;                                              // 0x006C (size: 0x4)
    float m_fSpecialAbilityAbsorbSuccessRefillValue;                                  // 0x0070 (size: 0x4)
    float m_fSpecialAbilitySuperAbsorbSuccessRefillValue;                             // 0x0074 (size: 0x4)
    uint8 m_uiNormalAbsorbStackNumber;                                                // 0x0078 (size: 0x1)
    uint8 m_uiSuperAbsorbStackNumber;                                                 // 0x0079 (size: 0x1)
    bool m_bGhostDamageActivatedForAttacks;                                           // 0x007A (size: 0x1)
    int32 m_iOrdersAllowedToPushAbsorbSuccessfulLayer;                                // 0x007C (size: 0x4)
    bool m_bNormalAbsorbIsDeathDodger;                                                // 0x0080 (size: 0x1)
    bool m_bSuperAbsorbIsDeathDodger;                                                 // 0x0081 (size: 0x1)
    int32 m_iSuperAbsorbFreezeframe;                                                  // 0x0084 (size: 0x4)
    int32 m_iSuperAbsorbOrders;                                                       // 0x0088 (size: 0x4)

}; // Size: 0x90

class UAbsorbPropertyDB : public USpecialAbilityPropertyDB
{
    uint8 m_uiAbsorbStackNumber;                                                      // 0x0050 (size: 0x1)
    bool m_bAbsorbIsDeathDodger;                                                      // 0x0051 (size: 0x1)
    int32 m_iAbsorbFreezeframeNumber;                                                 // 0x0054 (size: 0x4)
    bool m_bResistsInterruptAttack;                                                   // 0x0058 (size: 0x1)
    bool m_bResistsGuardBreakAttack;                                                  // 0x0059 (size: 0x1)
    bool m_bFromSpecialAbility;                                                       // 0x005A (size: 0x1)
    EAbsorbFeedbackTypes m_eAbsorbFeedbackType;                                       // 0x005B (size: 0x1)
    bool m_bGhostDamageActivated;                                                     // 0x005C (size: 0x1)

}; // Size: 0x60

class UAbsorbWindowNotifyState : public USCAnimNotifyState
{
    class UAbsorbPropertyDB* m_AbsorbPropertyDB;                                      // 0x0048 (size: 0x8)

}; // Size: 0x50

class UAbstractCameraData : public UDataAsset
{
    class UCameraTransitionInfo* m_DefaultCameraTransition;                           // 0x0030 (size: 0x8)
    TArray<FCameraTransitionInfoPairStruct> m_CameraTransitionDB;                     // 0x0038 (size: 0x10)
    class UCameraTransitionInfo* m_OutCameraTransition;                               // 0x0048 (size: 0x8)
    TArray<FCameraDataModifierWithBehavior> m_Modifiers;                              // 0x0050 (size: 0x10)

    void ClearTransitions();
}; // Size: 0x60

class UActionAvailableCondition : public UBaseActorCondition
{
    InputAction m_eAction;                                                            // 0x0028 (size: 0x1)

}; // Size: 0x30

class UActionPlayOrderBTTask : public UAIBTTaskNode
{
    FEditableOrderType m_EnqueueAfterOrder;                                           // 0x0088 (size: 0x58)
    FName m_NotifyEventOnBeforeStart;                                                 // 0x00E0 (size: 0x8)
    FName m_NotifyEventOnFinished;                                                    // 0x00E8 (size: 0x8)
    bool m_bNotifyEventOnFinishedOnlyOnSuccess;                                       // 0x00F0 (size: 0x1)
    FName m_OrderParamsName;                                                          // 0x00F4 (size: 0x8)
    EOrderType m_eOrderType;                                                          // 0x00FC (size: 0x1)
    FSCUserDefinedEnumHandler m_eOrderTypeBP;                                         // 0x0100 (size: 0x50)
    EFightingActionState m_eActionState;                                              // 0x0150 (size: 0x1)
    bool m_bFailIfParamInvalid;                                                       // 0x0151 (size: 0x1)
    bool m_bWaitForOrderEnd;                                                          // 0x0152 (size: 0x1)

}; // Size: 0x158

class UActionTargetCondition : public UBaseActorTargetCondition
{
    EActionType m_eAction;                                                            // 0x0028 (size: 0x1)

}; // Size: 0x30

class UActivateLookAtOrderService : public UOrderService
{
    FLookAtLimits m_lookAtLimit;                                                      // 0x0028 (size: 0x90)

}; // Size: 0xB8

class UActorClassCondition : public UBaseActorCondition
{
    TSoftClassPtr<AActor> m_Class;                                                    // 0x0028 (size: 0x28)

}; // Size: 0x50

class UActorHasAttachedActorCondition : public UBaseActorCondition
{
    TSoftClassPtr<AActor> m_Class;                                                    // 0x0028 (size: 0x28)

}; // Size: 0x50

class UActorHasAttackTicketCondition : public UBaseActorCondition
{
}; // Size: 0x28

class UActorLastTimeOnScreenCondition : public UBaseActorTargetCondition
{
    FFloatRange m_ValidTimeRangeCondition;                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

class UActorTargetCondition : public UBaseActorCondition
{
    FBaseActorTargetConditionInstance m_OptionalSubConditionOnTarget;                 // 0x0028 (size: 0x10)

}; // Size: 0x38

class UActorTransformOrderService : public UOrderService
{
    FVector m_vTranslation;                                                           // 0x0028 (size: 0xC)
    FRotator m_Rotation;                                                              // 0x0034 (size: 0xC)

}; // Size: 0x40

class UAddVariableWeightOrderService : public UOrderService
{
    FSCUserDefinedEnumHandler m_EnumLayer;                                            // 0x0028 (size: 0x50)
    class UBlendProfile* m_BoneMask;                                                  // 0x0078 (size: 0x8)
    class UBlendProfile* m_OptionalMirroredBoneMask;                                  // 0x0080 (size: 0x8)
    bool m_bRemoveOnOrderServiceStop;                                                 // 0x0088 (size: 0x1)

}; // Size: 0x90

class UAddWeaponIdleVariableWeightOrderService : public UAddVariableWeightOrderService
{

    FSCUserDefinedEnumHandler BPE_GetEnumLayerForWeapon(const class UBaseWeaponData* _weaponData);
    class UBlendProfile* BPE_GetBlendProfileForWeapon(const class UBaseWeaponData* _weaponData);
}; // Size: 0x90

class UAkAudioEventsBTService : public UBTService
{
    class UAkAudioEvent* m_InAkEvent;                                                 // 0x0070 (size: 0x8)
    class UAkAudioEvent* m_OutAkEvent;                                                // 0x0078 (size: 0x8)

}; // Size: 0x80

class UAnalogInputData : public UInputData
{
    float m_validityThreshold;                                                        // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UAnalogInputSequenceData : public UGenericInputData
{
    class UVectorInputData* m_VectorInputData;                                        // 0x00C0 (size: 0x8)
    bool m_bUseRawVectorInputs;                                                       // 0x00C8 (size: 0x1)
    TArray<FAnalogInputSequenceStep> m_Steps;                                         // 0x00D0 (size: 0x10)
    int32 m_iMaxParalellStates;                                                       // 0x00E0 (size: 0x4)
    TArray<EControllerIconAxisTypes> m_UIAxis;                                        // 0x00E8 (size: 0x10)

}; // Size: 0xF8

class UAngleFeedbackUserWidget : public USCUserWidget
{

    void BPE_DisplayAngleFeedback(float _fAngle);
}; // Size: 0x310

class UAngleTargetWeightEvaluation : public UBaseDirectionalTargetWeightEvaluation
{
    FRuntimeFloatCurve m_AngleCurve;                                                  // 0x0028 (size: 0x88)

}; // Size: 0xB0

class UAngleWithActorCondition : public UBaseActorTargetCondition
{
    EAngleComputeMethod m_eMethod;                                                    // 0x0028 (size: 0x1)
    FFloatRange m_angleRange;                                                         // 0x002C (size: 0x10)

}; // Size: 0x40

class UAnimContainerLibrary : public UBlueprintFunctionLibrary
{

    void GetSpeedStateAnim(const FSpeedStateAnimContainer& _animContainer, ESpeedState _eSpeedState, FAnimContainer& _result);
    void GetRotationAnim(const FRotationAnimContainer& _animContainer, ETransitionRotation _eTransitionRotation, FAnimContainer& _result);
    void GetQuadrantAnim(const FQuadrantAnimContainer& _animContainer, EQuadrantTypes _eQuadrant, FAnimContainer& _result);
    void GetOrientedRotationAnim(const FOrientedRotationAnimContainer& _animContainer, ETransitionRotation _eTransitionRotation, bool _bIsLeft, FAnimContainer& _result);
    void GetCardinalChangementAnim(const FCardinalChangementAnimContainer& _animContainer, ESCCardinalPoints _eInCardinal, ESCCardinalPoints _eOutCardinal, FAnimContainer& _result);
    void GetCardinalAnim(const FCardinalAnimContainer& _animContainer, ESCCardinalPoints _eCardinal, FAnimContainer& _result);
}; // Size: 0x28

class UAnimDrivenCameraOrderBTService : public UBTService
{
    EOrderType m_eOrderType;                                                          // 0x0070 (size: 0x1)
    bool m_bForceAsCurrentCamera;                                                     // 0x0071 (size: 0x1)
    bool m_bWaitForFirstFrameOrderService;                                            // 0x0072 (size: 0x1)
    ECameraAnimDrivenComputationMethod m_eComputationMethod;                          // 0x0073 (size: 0x1)
    TWeakObjectPtr<class UCameraComponentThird> m_cameraComponent;                    // 0x0074 (size: 0x8)

    class UAbstractCameraData* GetCameraData();
}; // Size: 0x88

class UAnimDrivenMovementComponent : public UActorComponent
{
    bool m_bUseDisplacement;                                                          // 0x0150 (size: 0x1)
    float m_fDisplacementCoeff;                                                       // 0x0154 (size: 0x4)
    bool m_bUseRotation;                                                              // 0x0158 (size: 0x1)
    float m_fRotationCoeff;                                                           // 0x015C (size: 0x4)

}; // Size: 0x160

class UAnimInstanceReplicationComponent : public UActorComponent
{
    uint32 m_uiReplicatedAnimGraphVersionHash;                                        // 0x00C8 (size: 0x4)
    TArray<FReplayReplicatedStateMachine> m_ReplicatedStateMachineSnapshots;          // 0x00D0 (size: 0x10)
    TArray<FReplayReplicatedAnimInstanceAssetPlayers> m_ReplicatedAnimInstancePlayerAssets; // 0x00F0 (size: 0x10)
    TArray<class TSubclassOf<USCAnimInstance>> m_AllowedReplicatedTypes;              // 0x0110 (size: 0x10)
    TArray<FSCAnimInstanceRef> m_ReplicatedSubAnimInstances;                          // 0x0120 (size: 0x10)
    TArray<FSCAnimInstanceRef> m_ScrubSnapshotOnlySubAnimInstances;                   // 0x0130 (size: 0x10)
    class USCAnimInstance* m_AnimInstance;                                            // 0x0140 (size: 0x8)

    void OnReplaySystemRecordingChanged(bool _bIsRecording);
}; // Size: 0x150

class UAnimInstanceWithDependancy : public USCAnimInstance
{
    FAnimContainer m_IdleAnimContainerFL;                                             // 0x0628 (size: 0x18)
    FAnimContainer m_IdleAnimContainerFR;                                             // 0x0640 (size: 0x18)
    FAnimContainer m_IdleAnimContainerBR;                                             // 0x0658 (size: 0x18)
    FAnimContainer m_IdleAnimContainerBL;                                             // 0x0670 (size: 0x18)
    FBlendSpaceDirectionContainer m_LockMoveBlendSpace;                               // 0x0688 (size: 0x20)
    FBlendSpaceDirectionContainer m_LockMoveUpperBodyBlendSpace;                      // 0x06A8 (size: 0x20)
    TArray<FAnimContainer> m_FreeMoveAnimContainer;                                   // 0x06C8 (size: 0x10)
    TArray<FBlendSpaceDirectionContainer> m_FreeMoveBlendSpace;                       // 0x06D8 (size: 0x10)
    class USCAnimInstance* m_MasterAnimInstance;                                      // 0x06E8 (size: 0x8)
    bool m_bAnyAnimInProgress;                                                        // 0x06F1 (size: 0x1)
    FAnimInfo m_animInfo1;                                                            // 0x06F8 (size: 0x40)
    FAnimInfo m_animInfo2;                                                            // 0x0738 (size: 0x40)
    FAnimInfo m_animInfo3;                                                            // 0x0778 (size: 0x40)
    FAnimInfo m_animInfo4;                                                            // 0x07B8 (size: 0x40)
    FAnimInfo m_V0Info;                                                               // 0x07F8 (size: 0x40)
    FAnimInfo m_V1Info;                                                               // 0x0838 (size: 0x40)
    FAnimInfo m_V2Info;                                                               // 0x0878 (size: 0x40)
    FAnimInfo m_V3Info;                                                               // 0x08B8 (size: 0x40)
    FAnimStructMoveTransition m_UTurnInfo;                                            // 0x0900 (size: 0x90)
    FAnimStructMoveTransition m_StartAnimInfo;                                        // 0x0990 (size: 0x90)
    FAnimStructMoveTransition m_StopAnimInfo;                                         // 0x0A20 (size: 0x90)
    FAnimStructMoveTransition m_TurnInInfo;                                           // 0x0AB0 (size: 0x90)
    FAnimStructMoveTransition m_LandingInfo;                                          // 0x0B40 (size: 0x90)
    EMoveTransitionType m_eTransitionType;                                            // 0x0BD0 (size: 0x1)
    FName m_VariableWeightMasterStateName;                                            // 0x0BD4 (size: 0x8)

    void Update(float _fDt);
    class USCAnimInstance* BPF_GetMasterAnimInstance();
    void BPE_UpdateFromMasterAnimInstance(float _fDt);
}; // Size: 0xBE0

class UAnimNotifyHitFloor : public USCAnimNotify
{
}; // Size: 0x48

class UAnimQuadrantStructHelper : public UBlueprintFunctionLibrary
{

    void BPF_MakeAnimQuadrantStruct(EQuadrantTypes _eQuadrant, FAnimQuadrantStruct& _outStruct);
}; // Size: 0x28

class UAnimSequenceDB : public UDataAsset
{
    TArray<class UAnimSequenceEntitlementDB*> m_DBs;                                  // 0x0030 (size: 0x10)

    void BPF_GetSequences(class ASCPlayerController* _controller, FAnimSequenceDBCache& _outCache);
}; // Size: 0x40

class UAnimSequenceEntitlementDB : public UDataAsset
{
    TArray<FName> m_AvailableForEntitlements;                                         // 0x0030 (size: 0x10)
    TArray<class UAnimSequenceEntryDB*> m_DBs;                                        // 0x0040 (size: 0x10)

}; // Size: 0x50

class UAnimSequenceEntryDB : public UDataAsset
{
    TSubclassOf<class ABaseWeapon> m_WeaponClass;                                     // 0x0030 (size: 0x8)
    TArray<FAnimSequenceDBEntry> m_AnimSequences;                                     // 0x0038 (size: 0x10)

}; // Size: 0x48

class UAnimationNotifySerializer : public UBlueprintFunctionLibrary
{

    FSCAnimNotifyExtraInfo BPF_ReadNotifyExtraInfoFromBufferArray(const TArray<uint8>& _extraInfoBufferArray);
}; // Size: 0x28

class UArchetypeAsset : public UObject
{
    EAIArchetype m_eAIArchetype;                                                      // 0x0028 (size: 0x1)
    FName m_ArchetypeName;                                                            // 0x002C (size: 0x8)
    bool m_bIsBoss;                                                                   // 0x0034 (size: 0x1)
    bool m_bForceTargetWidgetDisplay;                                                 // 0x0035 (size: 0x1)
    bool m_bDismissDeathForTakedown;                                                  // 0x0036 (size: 0x1)
    bool m_bInfiniteStructure;                                                        // 0x0037 (size: 0x1)
    float m_fGrabbableStructureRatio;                                                 // 0x0038 (size: 0x4)
    FAISuperDizzyParams m_SuperDizzyPerDifficulty;                                    // 0x003C (size: 0x48)
    bool m_bCanBeSuperDizzy;                                                          // 0x0084 (size: 0x1)
    float m_fSuperDizzyResistance;                                                    // 0x0088 (size: 0x4)
    float m_fSuperDizzyRecoveryCooldown;                                              // 0x008C (size: 0x4)
    float m_fSuperDizzyRecoveryCooldownWhenComplete;                                  // 0x0090 (size: 0x4)
    float m_fSuperDizzyGaugeRatioAfterSuperDizzy;                                     // 0x0094 (size: 0x4)
    float m_fSuperDizzyRecoveryPerSec;                                                // 0x0098 (size: 0x4)
    float m_fSpeed;                                                                   // 0x009C (size: 0x4)
    bool m_bIsSpecial;                                                                // 0x00A0 (size: 0x1)
    float m_fDamageMultiplier;                                                        // 0x00A4 (size: 0x4)
    bool m_bInvincible;                                                               // 0x00A8 (size: 0x1)
    bool m_bHideHealthGauge;                                                          // 0x00A9 (size: 0x1)
    bool m_bHideStructureGauge;                                                       // 0x00AA (size: 0x1)
    bool m_bAICanSeeForever;                                                          // 0x00AB (size: 0x1)
    uint8 m_uiResilience;                                                             // 0x00AC (size: 0x1)
    uint8 m_uiResilienceBonusFromAttack;                                              // 0x00AD (size: 0x1)
    float m_fAbandonTicketTimeout;                                                    // 0x00B0 (size: 0x4)
    class UAttackPropertiesResistanceDB* m_AttackPropertyResistanceDBPerDifficulty;   // 0x00B8 (size: 0x18)
    class UAttackPropertiesResistanceDB* m_AttackPropertyResistanceDB;                // 0x00D0 (size: 0x8)
    int32 m_iXPBonus;                                                                 // 0x00D8 (size: 0x4)
    bool m_bBreakWeaponOnDeath;                                                       // 0x00DC (size: 0x1)
    class UBaseMovementDB* m_MovementDB;                                              // 0x00E0 (size: 0x8)
    bool m_bLowStructureOnSpawn;                                                      // 0x00E8 (size: 0x1)
    class UCurveFloat* m_GuardRecoveryRateByLife;                                     // 0x00F0 (size: 0x8)
    class UCurveFloat* m_GuardRecoveryRateByLifePerDifficulty;                        // 0x00F8 (size: 0x18)
    bool m_bCanDefend;                                                                // 0x0110 (size: 0x1)
    float m_fParriedDuration;                                                         // 0x0114 (size: 0x4)
    float m_fStructureBrokenParriedDuration;                                          // 0x0118 (size: 0x4)
    class UAIContextualDefense* m_ContextualDefense;                                  // 0x0120 (size: 0x8)
    TSubclassOf<class UAvoidAbility> m_AvoidDB;                                       // 0x0128 (size: 0x8)
    TSubclassOf<class UDodgeTypeUseCaseMatrix> m_DodgeTypeUseCaseMatrixClass;         // 0x0130 (size: 0x8)
    class UAIContextualDefense* m_ContextualDefenseAgainstThrowables;                 // 0x0138 (size: 0x8)
    class UAIContextualDefense* m_ContextualDefenseGromGround;                        // 0x0140 (size: 0x8)
    TMap<class EDefenseTactics, class FSCAITriggerableActionsArray> m_DefaultPostDefenseActions; // 0x0148 (size: 0x50)
    TMap<class EDefenseTactics, class FAIConditionedActionArray> m_DefaultPostDefenseActionsMap; // 0x0198 (size: 0x50)
    bool m_bCanAvoidMultiHitAttacks;                                                  // 0x01E8 (size: 0x1)
    bool m_bCanAttack;                                                                // 0x01E9 (size: 0x1)
    bool m_bDropAnyWeaponAtStart;                                                     // 0x01EA (size: 0x1)
    TSubclassOf<class ABaseWeapon> m_WeaponToEquipAtStart;                            // 0x01F0 (size: 0x8)
    TArray<FAIWeaponInfo> m_UsableWeapons;                                            // 0x01F8 (size: 0x10)
    TArray<class UThrowableInfoForAIDataAsset*> m_UsableThrowablesFromGround;         // 0x0208 (size: 0x10)
    TMap<EAIWuguanTicketEvaluation, float> m_AttackTicketEvalFactors;                 // 0x0218 (size: 0x50)
    TArray<FAIAttackReaction> m_ReactionAttacks;                                      // 0x0268 (size: 0x10)
    TArray<FAIActionReaction> m_ReactionActions;                                      // 0x0278 (size: 0x10)
    bool m_bCanUseReactionActions;                                                    // 0x0288 (size: 0x1)
    float m_fFarFromEnemyDistThresold;                                                // 0x028C (size: 0x4)
    FLocomotionPaceSelector m_LocomotionPaceSelector;                                 // 0x0290 (size: 0x24)
    TSubclassOf<class UNavigationQueryFilter> m_NavigationQueryFilter;                // 0x02B8 (size: 0x8)
    uint8 m_uiHelpSignalTriggers;                                                     // 0x02C0 (size: 0x1)
    uint8 m_uiLostAttackTicketCause;                                                  // 0x02C1 (size: 0x1)
    TArray<FAIDifficultyLevel> m_difficultyLevels;                                    // 0x02C8 (size: 0x10)
    float m_fDamageReceivedToDifficultyBonus;                                         // 0x02D8 (size: 0x4)
    float m_fDamageDealtToDifficultyMalus;                                            // 0x02DC (size: 0x4)
    float m_fHitWithNoDamageDominationGaugeBonus;                                     // 0x02E0 (size: 0x4)
    float m_fHitWithNoDamageDominationGaugeMalus;                                     // 0x02E4 (size: 0x4)
    float m_fTakedownDominationBonus;                                                 // 0x02E8 (size: 0x4)
    float m_fSuccessfulMCParryBonus;                                                  // 0x02EC (size: 0x4)
    float m_fSuccessfulMCAvoidBonus;                                                  // 0x02F0 (size: 0x4)
    float m_fRespawnTime;                                                             // 0x02F4 (size: 0x4)
    class UBehaviorTree* m_Behavior;                                                  // 0x02F8 (size: 0x8)
    class UBlackboardData* m_Blackboard;                                              // 0x0300 (size: 0x8)
    bool m_bCanLeaveAbandon;                                                          // 0x0308 (size: 0x1)
    int32 m_iArchetypeDifficulty;                                                     // 0x030C (size: 0x4)
    FName m_VoiceArchetypeSwitchName;                                                 // 0x0310 (size: 0x8)
    TMap<class ECharacterGender, class FVoiceVariationsAkSwitchContainer> m_VoiceVariationsSwitchValuesPerGenderMap; // 0x0318 (size: 0x50)
    class UDataTable* m_BarksDb;                                                      // 0x0368 (size: 0x8)
    class UDataTable* m_BarksDBArena;                                                 // 0x0370 (size: 0x8)
    TMap<class FName, class FPatrolActivity> m_PatrolActivities;                      // 0x0378 (size: 0x50)
    class UVitalPointDB* m_VitalPointDB;                                              // 0x03C8 (size: 0x8)
    ESCAICombatRoles m_eRoleAffinity;                                                 // 0x03D0 (size: 0x1)
    TMap<ESCAICombatRoles, int32> m_iCirclePerCombatRoles;                            // 0x03D8 (size: 0x50)
    TMap<class ESCAICombatRoles, class FFloatRange> m_PerRoleCombatPositionRange;     // 0x0428 (size: 0x50)
    TMap<class ESCAICombatRoles, class FAIRangePerCircleIndex> m_PerRolePerCircleCombatPositionRange; // 0x0478 (size: 0x50)
    TMap<ESCAICombatRoles, int32> m_iCirclePerCombatRolesInPauseOverride;             // 0x04C8 (size: 0x50)
    TMap<class ESCAICombatRoles, class FAIRangePerCircleIndex> m_PerRolePerCircleCombatPositionRangeInPauseOverride; // 0x0518 (size: 0x50)
    TMap<class ESCAICombatRoles, class FFloatRange> m_fJiggleDelayRange;              // 0x0568 (size: 0x50)
    TMap<ESCAICombatRoles, float> m_fJiggleMovementMinDist;                           // 0x05B8 (size: 0x50)
    FCardinalAnimContainer m_JiggleAnimations;                                        // 0x0608 (size: 0x60)
    TArray<FJiggleAnimContainer> m_JiggleAnimationContainers;                         // 0x0668 (size: 0x10)
    FFloatRange m_JiggleAnimationsRateModifierRange;                                  // 0x0678 (size: 0x10)
    class UFidgetDB* m_FidgetDBs;                                                     // 0x0688 (size: 0x28)
    bool m_bCanBeSpared;                                                              // 0x06B0 (size: 0x1)
    FBaseActorConditionInstance m_SpareCondition;                                     // 0x06B8 (size: 0x10)
    float m_fHealth;                                                                  // 0x06C8 (size: 0x4)
    float m_fHealthMultiplier;                                                        // 0x06CC (size: 0xC)
    float m_fStructure;                                                               // 0x06D8 (size: 0x4)
    float m_fStructureMultiplier;                                                     // 0x06DC (size: 0xC)

}; // Size: 0x6E8

class UArchetypeSituationDB : public UDataAsset
{
    TArray<FArchetypeSituationDescription> m_ArchetypesInSituation;                   // 0x0030 (size: 0x10)

}; // Size: 0x40

class UArenaChallengeDescription : public UObject
{
    FText m_Title;                                                                    // 0x0028 (size: 0x18)
    FText m_Description;                                                              // 0x0040 (size: 0x18)
    FGameplayTag m_ArenaTag;                                                          // 0x0058 (size: 0x8)
    TSoftObjectPtr<APlayerStart> m_desiredPlayerStart;                                // 0x0060 (size: 0x28)
    FAchievementUnlockConditionClassInstance m_MasterObjective;                       // 0x0088 (size: 0x10)
    TArray<FGameplayTag> m_CheatsToActivate;                                          // 0x0098 (size: 0x10)
    TMap<class FGameplayTag, class FString> m_CheatsWithArgument;                     // 0x00A8 (size: 0x50)
    TMap<class FGameplayTag, class FString> m_CheatArguments;                         // 0x00F8 (size: 0x50)
    TSoftClassPtr<ABaseWeapon> m_carriedWeapon;                                       // 0x0148 (size: 0x28)
    int32 m_iAge;                                                                     // 0x0170 (size: 0x4)
    int32 m_iDeathCount;                                                              // 0x0174 (size: 0x4)
    ECharacterGender m_eCharacterGender;                                              // 0x0178 (size: 0x1)
    bool m_bOverrideOutfit;                                                           // 0x0179 (size: 0x1)
    int32 m_iOutfitIndex;                                                             // 0x017C (size: 0x4)
    bool m_bEnableOutfitPropSpawn;                                                    // 0x0180 (size: 0x1)
    TSoftObjectPtr<UWorld> m_AIInitialSpawnSublevel;                                  // 0x0188 (size: 0x28)
    FArenaChallengeRefillDescription m_RefillDescription;                             // 0x01B0 (size: 0x78)

    class AAIWaveRefillDirector* BPF_GetRefillDirector();
    int32 BPF_GetNbWaves();
    int32 BPF_GetDeathCount();
    TMap<class FGameplayTag, class FString> BPF_GetCheatsToActivate();
    TSoftClassPtr<ABaseWeapon> BPF_GetCarriedWeapon();
    class UBaseArenaObjective* BPF_GetArenaObjective();
    int32 BPF_GetAge();
}; // Size: 0x228

class UArenaHardpointsObjective : public UBaseArenaObjective
{
    TArray<FHardpointInfos> m_HardpointsInfos;                                        // 0x0278 (size: 0x10)
    FArenaHardpointsObjectiveOnAllHardpointsClearedOnce OnAllHardpointsClearedOnce;   // 0x0288 (size: 0x10)
    void DynamicMulticast();
    FArenaHardpointsObjectiveOnHardpointCapturedDelegate OnHardpointCapturedDelegate; // 0x0298 (size: 0x10)
    void OnHardpointCaptured(const FHardpointInfos& _HardpointInfo, int32 _CurrentChallengeIndex);
    FArenaHardpointsObjectiveOnHardpointActivationChanged OnHardpointActivationChanged; // 0x02A8 (size: 0x10)
    void OnHardpointActivationChanged(const class AArenaHardpointAreaActor* _HardpointActor, bool _Activated);
    EHardpointActivationRule m_eHardpointActivationRule;                              // 0x02B8 (size: 0x1)
    ESequentialLoopRule m_eSequentialLoopRule;                                        // 0x02B9 (size: 0x1)
    float m_fHardpointCaptureValue;                                                   // 0x02BC (size: 0x4)
    bool m_bHasClearedAllHardpointsOnce;                                              // 0x02C0 (size: 0x1)

    void OnHardpointCaptured__DelegateSignature(const FHardpointInfos& _HardpointInfo, int32 _CurrentChallengeIndex);
    void OnHardpointActivationChanged__DelegateSignature(const class AArenaHardpointAreaActor* _HardpointActor, bool _Activated);
    int32 BPF_GetTotalNumberOfHardpoints();
    int32 BPF_GetCurrentHardpointIndex();
    class AArenaHardpointAreaActor* BPF_GetCurrentHardpointAreaActor();
}; // Size: 0x308

class UArenaManagerBlueprintHelper : public UBlueprintFunctionLibrary
{

    void BPF_SetCurrentArena(int32 _iBatchIndex, int32 _iChallengeIndex);
    void BPF_SetChallengeIndex(int32 _iChallengeIndex);
    void BPF_SetArena(FGameplayTag _arenaTag);
    void BPF_OnCurrentChallengeSpecificLevelShown();
    void BPF_OnCurrentChallengeSpecificLevelLoaded();
    void BPF_MarkChallengeAsSeen(const class UArenaChallengeDescription* _challengeDescription);
    bool BPF_IsDebugChallenge();
    bool BPF_HasChallengeBeenSeen(const class UArenaChallengeDescription* _challengeDescription);
    int32 BPF_GetMaxAICharactersPerPool();
    int32 BPF_GetLastSelectedChallengeIndex();
    int32 BPF_GetLastSelectedBatchIndex();
    FArenaParams BPF_GetCurrentParams();
    class UBaseArenaObjective* BPF_GetCurrentMasterObjective();
    int32 BPF_GetCurrentChallengeIndex();
    class UArenaChallengeDescription* BPF_GetCurrentChallenge();
    FGameplayTag BPF_GetCurrentArena();
    int32 BPF_GetChallengeHighScore(class UArenaChallengeDescription* _challengeDescription);
    int32 BPF_GetChallengeBestStarCount(const class UArenaChallengeDescription* _challengeDescription);
    class UArenaSettings* BPF_GetArenaSettings();
    TArray<FArenaBatch> BPF_GetArenaBatches(FGameplayTag _restrictionTag);
    void BPF_EnableProgressionSystem(bool _bEnabled);
    FArenaBatchProgressionInfo BPF_ComputeBatchProgression(const FArenaBatch& _ArenaBatch);
    FArenaProgressionInfo BPF_ComputeArenaProgression(FGameplayTag _restrictionTag);
}; // Size: 0x28

class UArenaSettings : public UObject
{
    TMap<class FGameplayTag, class FGameplayTagContainer> m_ArenasPerType;            // 0x0028 (size: 0x50)
    TArray<FArenaBatch> m_ArenaBatches;                                               // 0x00C8 (size: 0x10)
    float m_fObjectiveStartTimerValue;                                                // 0x00D8 (size: 0x4)
    EArenaUnlockingBehavior m_eArenaUnlockingBehavior;                                // 0x00DC (size: 0x1)
    int32 m_iMaxStarCountThatUnlocksBatch;                                            // 0x00E0 (size: 0x4)
    int32 m_iMaxStarCountThatGrantsCurrency;                                          // 0x00E4 (size: 0x4)
    int32 m_iCurrencyPerStar;                                                         // 0x00E8 (size: 0x4)
    int32 m_iMaxNumberOfDifferentCharacterBP;                                         // 0x00EC (size: 0x4)
    int32 m_iNbImpostorPerClasses;                                                    // 0x00F0 (size: 0x4)
    FFloatRange m_fDelayBetweenSpawns;                                                // 0x00F4 (size: 0x10)
    float m_fOutsideVolumeCaptureTimeDelay;                                           // 0x0104 (size: 0x4)
    float m_fBaseCaptureSpeedPerSecond;                                               // 0x0108 (size: 0x4)
    float m_fCaptureSpeedMultiplierPerScoreMultiplier;                                // 0x010C (size: 0xC)
    float m_fNoEnemyInsideHardpointMultiplier;                                        // 0x0118 (size: 0x4)
    bool m_bEnableAllHardpointsEnemiesKilledMultiplier;                               // 0x011C (size: 0x1)
    float m_fAllHardpointsEnemiesKilledMultiplier;                                    // 0x0120 (size: 0x4)
    float m_fDelayBetweenHardpointActivation;                                         // 0x0124 (size: 0x4)
    float m_fDelayBeforeScoreDecrease;                                                // 0x0128 (size: 0x4)
    class UCurveFloat* m_CaptureScoreDecreaseOverTime;                                // 0x0130 (size: 0x8)
    bool m_bChangeAIToAbandoningOnHardpointCapture;                                   // 0x0138 (size: 0x1)
    float m_fAIDespawnDistance;                                                       // 0x013C (size: 0x4)
    float m_fAIDespawnDelayWhileNotRendered;                                          // 0x0140 (size: 0x4)

    float BPF_GetCaptureSpeedMultiplierPerScoreMultiplier(int32 _iScoreMultiplierIndex);
}; // Size: 0x148

class UArenaTargetsObjective : public UBaseArenaObjective
{
    TArray<TSoftObjectPtr<AAISpawner>> m_Targets;                                     // 0x0278 (size: 0x10)

    TArray<TSoftObjectPtr<AAISpawner>> BPF_GetTargets();
    void BPE_OnTargetDown(class AAISpawner* _AISpawner);
}; // Size: 0x2E0

class UArenaWaveObjective : public UBaseArenaObjective
{
    int32 m_iFinalWaveIndex;                                                          // 0x0278 (size: 0x4)
    EScoringType m_eScoringType;                                                      // 0x027C (size: 0x1)

    void OnWaveAndSituationComplete(int32 _iWaveIndex);
}; // Size: 0x290

class UAsyncImage : public UImage
{
    FAsyncImageOnLoadingStarted OnLoadingStarted;                                     // 0x0210 (size: 0x10)
    void AsyncImageDelegate(class UAsyncImage* _image);
    FAsyncImageOnLoadingCanceled OnLoadingCanceled;                                   // 0x0220 (size: 0x10)
    void AsyncImageDelegate(class UAsyncImage* _image);
    FAsyncImageOnLoaded OnLoaded;                                                     // 0x0230 (size: 0x10)
    void AsyncImageDelegate(class UAsyncImage* _image);
    TSoftObjectPtr<UTexture2D> m_AsyncAsset;                                          // 0x0240 (size: 0x28)
    float m_fApparitionDuration;                                                      // 0x0268 (size: 0x4)
    TSoftObjectPtr<UMaterialInterface> m_AsyncMaterial;                               // 0x0270 (size: 0x28)
    bool m_bMatchSize;                                                                // 0x0298 (size: 0x1)
    bool m_bHideOnLoadStart;                                                          // 0x0299 (size: 0x1)

    void BPF_SetTexture(class UTexture2D* _asset, bool _bMatchSize);
    void BPF_SetMaterial(class UMaterialInterface* _asset);
    void BPF_LoadTextureAssetAsync(TSoftObjectPtr<UTexture2D> _asset, bool _bMatchSize, int32 _iQueueID, bool _bForce);
    void BPF_LoadMaterialAssetAsync(TSoftObjectPtr<UMaterialInterface> _asset);
    void BPF_Clear();
    void AsyncImageDelegate__DelegateSignature(class UAsyncImage* _image);
}; // Size: 0x2A8

class UAsyncTaskAiAction : public UBlueprintAsyncActionBase
{
    FAsyncTaskAiActionOnSuccess OnSuccess;                                            // 0x0030 (size: 0x10)
    void DynamicMulticast();
    FAsyncTaskAiActionOnFailure OnFailure;                                            // 0x0040 (size: 0x10)
    void DynamicMulticast();

    class UAsyncTaskAiAction* BPF_ScheduleAIAction(class UAIFightingComponent* _aiComponent, TSubclassOf<class USCAiAction> _actionClass, class USCAiAction* _action, class USCAiAction*& _scheduledAction, bool _bCancelPendingActions);
}; // Size: 0x50

class UAsyncTaskAiLaunchCombo : public UBlueprintAsyncActionBase
{
    FAsyncTaskAiLaunchComboOnSuccess OnSuccess;                                       // 0x0030 (size: 0x10)
    void DynamicMulticast();
    FAsyncTaskAiLaunchComboOnFailure OnFailure;                                       // 0x0040 (size: 0x10)
    void DynamicMulticast();

    class UAsyncTaskAiLaunchCombo* BPF_AIAction_LaunchCombo(class UAIFightingComponent* _aiComponent, TSubclassOf<class UAIActionLaunchCombo> _actionClass, const FAIComboLaunchParameters& _parameters, class UAIActionLaunchCombo*& _action);
}; // Size: 0x50

class UAsyncTaskApplySkillsFromSaves : public UBlueprintAsyncActionBase
{
    FAsyncTaskApplySkillsFromSavesSavesApplied SavesApplied;                          // 0x0030 (size: 0x10)
    void OnSavesApplied();

    class UAsyncTaskApplySkillsFromSaves* BPF_ApplySavesSkillOnCurrentSave(class UObject* _context, class USCAbilitySystemComponent* _abilitySystemComponent, TArray<int32> _indicesOfSave);
}; // Size: 0x40

class UAsyncTaskPlayAnimation : public UMenuAsyncActionBase
{
    FAsyncTaskPlayAnimationOnFinished OnFinished;                                     // 0x0080 (size: 0x10)
    void AsyncTaskPlayTransitionAnimation();

    void OnTransitionFinished();
    class UAsyncTaskPlayAnimation* BPF_PlayTransitionAnimationAsync(class UObject* _menu, class UWidgetAnimation* _inAnimation, TEnumAsByte<EUMGSequencePlayMode::Type> _ePlayMode, bool _bDisableInputs);
    void AsyncTaskPlayTransitionAnimation__DelegateSignature();
}; // Size: 0x90

class UAsyncTaskSwapGender : public UBlueprintAsyncActionBase
{
    FAsyncTaskSwapGenderOnSuccess OnSuccess;                                          // 0x0030 (size: 0x10)
    void OnSwapGender();
    FAsyncTaskSwapGenderOnFail OnFail;                                                // 0x0040 (size: 0x10)
    void OnSwapGender();

    class UAsyncTaskSwapGender* BPF_SwapGender(class UPlayerFightingComponent* _playerComponent, ECharacterGender _eNewGender);
}; // Size: 0x58

class UAsyncTaskSwitchAudioCulture : public UBlueprintAsyncActionBase
{
    FAsyncTaskSwitchAudioCultureCultureSwitched CultureSwitched;                      // 0x0030 (size: 0x10)
    void OnCultureSwitched();
    FAsyncTaskSwitchAudioCultureCultureSwitchFailed CultureSwitchFailed;              // 0x0040 (size: 0x10)
    void OnCultureSwitched();

    class UAsyncTaskSwitchAudioCulture* BPF_SwitchAudioCulture(class UObject* _context, FString _cultureName);
}; // Size: 0x70

class UAsyncTaskTick : public UMenuAsyncActionBase
{
    FAsyncTaskTickOnTick OnTick;                                                      // 0x0090 (size: 0x10)
    void AsyncTaskTickDel(class UAsyncTaskTick* _task, float _fDeltaTime, float _fProgress, float _fTotalTime);
    FAsyncTaskTickOnFinished OnFinished;                                              // 0x00A0 (size: 0x10)
    void AsyncTaskTickDel(class UAsyncTaskTick* _task, float _fDeltaTime, float _fProgress, float _fTotalTime);

    class UAsyncTaskTick* BPF_Tick(class UAsyncTaskTick* _existingTask, class UObject* _menu, float _fFrequency, float _fDuration);
    void BPF_Stop();
    void AsyncTaskTickDel__DelegateSignature(class UAsyncTaskTick* _task, float _fDeltaTime, float _fProgress, float _fTotalTime);
}; // Size: 0xB0

class UAsyncTaskWait : public UMenuAsyncActionBase
{
    FAsyncTaskWaitOnFinished OnFinished;                                              // 0x0080 (size: 0x10)
    void AsyncTaskWaitDel();

    class UAsyncTaskWait* BPF_Wait(class UObject* _menu, float _fDuration);
    void AsyncTaskWaitDel__DelegateSignature();
}; // Size: 0x90

class UAsyncTaskWaitForAISituationSpawnedFromSave : public UBlueprintAsyncActionBase
{
    FAsyncTaskWaitForAISituationSpawnedFromSaveAllSpawned AllSpawned;                 // 0x0030 (size: 0x10)
    void OnSpawned();
    FAsyncTaskWaitForAISituationSpawnedFromSaveNothingToSpawn NothingToSpawn;         // 0x0040 (size: 0x10)
    void OnSpawned();

    class UAsyncTaskWaitForAISituationSpawnedFromSave* BPF_WaitForAISituationToSpawnFromSave(const TArray<class AAISituationActor*> _situationsToWaitFor);
}; // Size: 0x60

class UAsyncTaskWaitForInput : public UBlueprintAsyncActionBase
{
    FAsyncTaskWaitForInputValidated Validated;                                        // 0x0030 (size: 0x10)
    void OnInputWait();
    FAsyncTaskWaitForInputSkipped Skipped;                                            // 0x0040 (size: 0x10)
    void OnInputWait();
    FAsyncTaskWaitForInputLaunched Launched;                                          // 0x0050 (size: 0x10)
    void OnInputWait();
    FAsyncTaskWaitForInputSkippedOnError SkippedOnError;                              // 0x0060 (size: 0x10)
    void OnInputWait();

    class UAsyncTaskWaitForInput* BPF_WaitForInputWithFreezeExtraValidationDelegate(class UObject* _context, float _fDelayBeforeFreeze, float _fDelayBeforeAllowingInput, FBPF_WaitForInputWithFreezeExtraValidationDelegateAdditionalDelegate _additionalDelegate, TSubclassOf<class USCGameplayAbility> _abilityToTest, TArray<InputAction> _specificActionsToTest, TArray<InputAction> _extraAvailableActions, ESCBlendType _eBlendType, class UCurveFloat* _curveDynamic, float _fCameraSlomotionFactor, bool _bLaunchOnlyIfAvailable);
    class UAsyncTaskWaitForInput* BPF_WaitForInputWithFreeze(class UObject* _context, float _fDelayBeforeFreeze, float _fDelayBeforeAllowingInput, TSubclassOf<class USCGameplayAbility> _abilityToTest, TArray<InputAction> _specificActionsToTest, TArray<InputAction> _extraAvailableActions, ESCBlendType _eBlendType, class UCurveFloat* _curveDynamic, float _fCameraSlomotionFactor, bool _bLaunchOnlyIfAvailable);
    void BPF_Cancel();
}; // Size: 0xA0

class UAsyncTaskWaitForSignIn : public UMenuAsyncActionBase
{
    FAsyncTaskWaitForSignInOnSuccess OnSuccess;                                       // 0x0088 (size: 0x10)
    void AsyncTaskWaitForSignInCompleted(const FText& _error);
    FAsyncTaskWaitForSignInOnFail OnFail;                                             // 0x0098 (size: 0x10)
    void AsyncTaskWaitForSignInCompleted(const FText& _error);

    class UAsyncTaskWaitForSignIn* BPF_WaitForSignIn(class UObject* _menu);
    void AsyncTaskWaitForSignInCompleted__DelegateSignature(const FText& _error);
}; // Size: 0xB0

class UAsyncTextureBinding : public UPropertyBinding
{

    FAsyncTextureStruct GetValue();
}; // Size: 0x60

class UAsyncWaitForInputAvailability : public UBlueprintAsyncActionBase
{
    FAsyncWaitForInputAvailabilityOnInputAvailable OnInputAvailable;                  // 0x0030 (size: 0x10)
    void DynamicMulticast();

    class UAsyncWaitForInputAvailability* BPF_WaitForInputAvailability(class ABaseCharacter* _inCharacter, InputAction _eInInputAction);
}; // Size: 0x58

class UAttachWeapon_Notify : public USCAnimNotify
{
    FName m_sBoneToAttachWeaponTo;                                                    // 0x0048 (size: 0x8)
    bool m_bFakie;                                                                    // 0x0050 (size: 0x1)
    bool m_bIsEndReattachment;                                                        // 0x0051 (size: 0x1)
    bool m_bAttachInFakieIfCancelledFromThisNotify;                                   // 0x0052 (size: 0x1)

}; // Size: 0x58

class UAttackAbility : public USCGameplayAbility
{
    bool m_bUseCameraForwardWhenNoTarget;                                             // 0x063D (size: 0x1)

}; // Size: 0x640

class UAttackBTTask : public UAIBTTaskNode
{
}; // Size: 0x88

class UAttackComponent : public UActorComponent
{
    FAttackComponent_OnAttackChangeState m_OnAttackChangeState;                       // 0x0110 (size: 0x10)
    void OnAttackChangeState(EAttackStates _eNewState);
    FAttackComponent_OnAttackHitDynamic m_OnAttackHitDynamic;                         // 0x0120 (size: 0x10)
    void OnAttackHitDymanic(const FAttackHitRequest& _hitRequest, const FImpactResult& _impactResult, class AActor* _hittedActor);
    FAttackComponent_OnAttackHitFilteredDynamic m_OnAttackHitFilteredDynamic;         // 0x0148 (size: 0x10)
    void OnAttackHitFilteredDynamic(const FAttackHitRequest& _hitRequest, const FImpactResult& _impactResult, class AActor* _hittedActor, EHitDismissReason _eDismissReason);
    FAttackComponent_OnAttackLaunchedDynamic m_OnAttackLaunchedDynamic;               // 0x01A0 (size: 0x10)
    void DynamicMulticast();
    FAttackComponent_OnNewAttacksChanged m_OnNewAttacksChanged;                       // 0x01B0 (size: 0x10)
    void OnNewAttacksChanged();
    FAttackComponent_OnTargetChange m_OnTargetChange;                                 // 0x01C0 (size: 0x10)
    void OnTargetChange(EActionType _eAction);
    FAttackComponentOnMovableUsable OnMovableUsable;                                  // 0x01E8 (size: 0x10)
    void OnMovableUsabilityChanged(EMovableType _eMovableType, bool _bUsable);
    FAttackComponentOnDangerStateChanged OnDangerStateChanged;                        // 0x01F8 (size: 0x10)
    void OnDangerStateChanged(EDangerStates _ePreviousDangerState, EDangerStates _eNewDangerState);
    FAnimSyncContainer m_TakedownDebugAnims;                                          // 0x0208 (size: 0x30)
    FAnimSyncContainer m_EnvTakedownDebugAnim;                                        // 0x0238 (size: 0x30)
    FAttackIKLimbProfiles m_AttackIKProfiles;                                         // 0x0268 (size: 0x2C0)
    FAttackComponent_OnFocusMechanicStart m_OnFocusMechanicStart;                     // 0x0528 (size: 0x10)
    void OnFocusMechanicStart();
    FAttackComponent_OnFocusMechanicValidated m_OnFocusMechanicValidated;             // 0x0538 (size: 0x10)
    void OnFocusMechanicValidated(class AVitalPointActor* _vitalPointSelected);
    FAttackComponent_OnFocusMechanicStop m_OnFocusMechanicStop;                       // 0x0548 (size: 0x10)
    void OnFocusMechanicStop(bool _bCancel);
    FAttackComponent_OnFocusMechanicUpdate m_OnFocusMechanicUpdate;                   // 0x0558 (size: 0x10)
    void OnFocusMechanicUpdate(float _fDeltaTime, float _fRealTimeDeltaTime);
    FAttackComponent_OnFocusMechanicNewPointSelected m_OnFocusMechanicNewPointSelected; // 0x0568 (size: 0x10)
    void OnFocusMechanicNewPointSelected(class AVitalPointActor* _previousVitalPointSelected, class AVitalPointActor* _vitalPointSelected);
    FAttackComponentOnFocusPointsValueChanged OnFocusPointsValueChanged;              // 0x0578 (size: 0x10)
    void FocusPointValueChanged(float _fPrevious, float _fNew);
    FAttackComponentOnFocusBarValueChanged OnFocusBarValueChanged;                    // 0x0588 (size: 0x10)
    void FocusPointValueChanged(float _fPrevious, float _fNew);
    FAttackComponentOnChargedCapStarted OnChargedCapStarted;                          // 0x0598 (size: 0x10)
    void OnAttackChargedCapStart(uint8 _attackOrderID, uint8 _uiLevel, float _fDuration);
    FAttackComponentOnChargedCapEnded OnChargedCapEnded;                              // 0x05A8 (size: 0x10)
    void OnAttackChargedCapEnd(uint8 _attackOrderID, uint8 _uiLevel, EChargeCapEndReason _eEndReason);
    FAttackComponentOnChargedCapUpdate OnChargedCapUpdate;                            // 0x05B8 (size: 0x10)
    void OnAttackChargedCapUpdate(uint8 _attackOrderID, uint8 _uiLevel, float _fDt, float _fCurrentRatioInChargingPhase);
    FAttackComponentOnChargedAttackLaunched OnChargedAttackLaunched;                  // 0x05C8 (size: 0x10)
    void OnAttackChargedLaunched(uint8 _attackOrderID, uint8 _uiLevel);
    TSubclassOf<class UPushObjectAnimRequest> m_pushAnimRequest;                      // 0x05F0 (size: 0x8)
    class UCombo* m_DefaultCombo;                                                     // 0x0608 (size: 0x8)
    TArray<InputAction> m_AttackActions;                                              // 0x0620 (size: 0x10)
    class UComboManager* m_ComboManager;                                              // 0x0630 (size: 0x8)
    float m_fAttackReorientationDurationFromIdle;                                     // 0x0638 (size: 0x4)
    float m_fAttackReorientationDurationFromAttack;                                   // 0x063C (size: 0x4)
    float m_fAttackReorientationDurationIfChangedDuringAttack;                        // 0x0640 (size: 0x4)
    class UIdleDB* m_IdleDB;                                                          // 0x0648 (size: 0x8)
    class UEnvironmentalAttackDetectionDB* m_TakedownDB;                              // 0x0650 (size: 0x8)
    float m_fEnterFightDistance;                                                      // 0x0688 (size: 0x4)
    float m_fExitFightDistance;                                                       // 0x068C (size: 0x4)
    float m_fVirtualTargetAntiSpamRange;                                              // 0x0690 (size: 0x4)
    class UCurveFloat* m_VirtualTargetRemapCurve;                                     // 0x0698 (size: 0x8)
    TWeakObjectPtr<class AActor> m_Target;                                            // 0x06B4 (size: 0x8)
    FName m_HitTargetBoneName;                                                        // 0x06D4 (size: 0x8)
    TMap<class FName, class ELimbs> m_UpperLimbBoneNames;                             // 0x06E0 (size: 0x50)
    FName m_TargetSocketHigh;                                                         // 0x0730 (size: 0x8)
    FName m_TargetSocketHighMiss;                                                     // 0x0738 (size: 0x8)
    FName m_TargetSocketHighMissSide;                                                 // 0x0740 (size: 0x8)
    FName m_TargetSocketMid1;                                                         // 0x0748 (size: 0x8)
    FName m_TargetSocketMidMiss;                                                      // 0x0750 (size: 0x8)
    FName m_TargetSocketMidMissSide;                                                  // 0x0758 (size: 0x8)
    FName m_TargetSocketMid2;                                                         // 0x0760 (size: 0x8)
    FName m_TargetSocketLowLeft;                                                      // 0x0768 (size: 0x8)
    FName m_TargetSocketLowMiss;                                                      // 0x0770 (size: 0x8)
    FName m_TargetSocketLowMissSide;                                                  // 0x0778 (size: 0x8)
    FName m_TargetSocketLowRight;                                                     // 0x0780 (size: 0x8)
    FName m_AimIKCurveName;                                                           // 0x0788 (size: 0x8)
    FName m_FakeHipsBoneName;                                                         // 0x0790 (size: 0x8)
    class UTargetDB* m_TargetDB;                                                      // 0x0798 (size: 0x8)
    float m_StaminaConsumptionValues;                                                 // 0x07AC (size: 0xC)
    bool m_bAttackHasImpactOnGuardGauge;                                              // 0x07B8 (size: 0x1)
    float m_FreezeFrameNb;                                                            // 0x0834 (size: 0xC)
    float m_ResilientFreezeFrameNb;                                                   // 0x0840 (size: 0xC)
    float m_GuardFreezeFrameNb;                                                       // 0x084C (size: 0xC)
    class URushAttackDB* m_RushAttackDB;                                              // 0x0908 (size: 0x8)
    float m_fFlatHitBoxesCapsuleHalfHeightFactorThresold;                             // 0x0910 (size: 0x4)
    uint32 m_uiFlatHitBoxesControllerNatureMask;                                      // 0x0914 (size: 0x4)
    float m_fDangerTimeOut;                                                           // 0x092C (size: 0x4)
    EDangerStates m_eDangerState;                                                     // 0x0930 (size: 0x1)
    FHitBox m_OffensiveAvoidHitBox;                                                   // 0x0938 (size: 0x298)
    float m_fMaxDistSnap;                                                             // 0x0BD0 (size: 0x4)
    bool m_bDisableSnapWhenTargetInRange;                                             // 0x0BD4 (size: 0x1)
    FSCUserDefinedEnumHandler m_EnvironementImpactType;                               // 0x0BE0 (size: 0x50)
    TArray<class UAnimSequence*> m_TakedownHistory;                                   // 0x0C30 (size: 0x10)
    bool m_bCanGuardBreakAfterDeflected;                                              // 0x0C40 (size: 0x1)
    class UFocusDB* m_FocusDB;                                                        // 0x0C48 (size: 0x8)

    void SetWantsComboRestart(bool _bWantsRestart);
    void ServerSetTarget(class AActor* _target);
    void OnTargetChange__DelegateSignature(EActionType _eAction);
    void OnRep_DangerState(EDangerStates _ePreviousDangerState);
    void OnNewAttacksChanged__DelegateSignature();
    void OnMovableUsabilityChanged__DelegateSignature(EMovableType _eMovableType, bool _bUsable);
    void OnFocusMechanicValidated__DelegateSignature(class AVitalPointActor* _vitalPointSelected);
    void OnFocusMechanicUpdate__DelegateSignature(float _fDeltaTime, float _fRealTimeDeltaTime);
    void OnFocusMechanicStop__DelegateSignature(bool _bCancel);
    void OnFocusMechanicStart__DelegateSignature();
    void OnFocusMechanicNewPointSelected__DelegateSignature(class AVitalPointActor* _previousVitalPointSelected, class AVitalPointActor* _vitalPointSelected);
    void OnDangerStateChanged__DelegateSignature(EDangerStates _ePreviousDangerState, EDangerStates _eNewDangerState);
    void OnAttackHitFilteredDynamic__DelegateSignature(const FAttackHitRequest& _hitRequest, const FImpactResult& _impactResult, class AActor* _hittedActor, EHitDismissReason _eDismissReason);
    void OnAttackHitDymanic__DelegateSignature(const FAttackHitRequest& _hitRequest, const FImpactResult& _impactResult, class AActor* _hittedActor);
    void OnAttackChargedLaunched__DelegateSignature(uint8 _attackOrderID, uint8 _uiLevel);
    void OnAttackChargedCapUpdate__DelegateSignature(uint8 _attackOrderID, uint8 _uiLevel, float _fDt, float _fCurrentRatioInChargingPhase);
    void OnAttackChargedCapStart__DelegateSignature(uint8 _attackOrderID, uint8 _uiLevel, float _fDuration);
    void OnAttackChargedCapEnd__DelegateSignature(uint8 _attackOrderID, uint8 _uiLevel, EChargeCapEndReason _eEndReason);
    void OnAttackChangeState__DelegateSignature(EAttackStates _eNewState);
    void MulticastOrderAttackTrackingOver(uint8 _uiOrderId);
    class AActor* GetNextAttackTarget();
    void FocusPointValueChanged__DelegateSignature(float _fPrevious, float _fNew);
    void BPF_ValidateFocus(class AVitalPointActor* _vitalPoint);
    void BPF_UpdateLockMoveTarget(class AActor* _currentAttacked);
    void BPF_StopFocus(bool _bCancel);
    void BPF_StartFocus();
    void BPF_SetTargetForSlot(FName _BPTargetSlot, class AActor* _target);
    void BPF_SetServiceActive(EActionType _eActionType, bool _bActive);
    void BPF_SetMoveDuringAttacks(bool _bMove);
    void BPF_SetFocusPointsInfinite(bool _bInfinite);
    void BPF_SetAutoDeflectStructureBroken(bool _bAutoDeflectOn, float _fOverrideStructureDamageDeflect, float _fOverrideStructureDamageParry);
    void BPF_ResetToDefaultCombo();
    void BPF_OverrideCombo(class UCombo* _combo);
    bool BPF_IsPlayingAttack();
    bool BPF_IsFocusPointsInfinite();
    class AVitalPointActor* BPF_GetVitalPointSelected();
    class AInteractiveMovable* BPF_GetTempMovable(EActionType _eActionType);
    class AActor* BPF_GetTargetForSlot(FName _BPTargetSlot);
    class AActor* BPF_GetTargetForInput(InputAction _eInput);
    class AActor* BPF_GetTargetForAction(EActionType _eActionType, bool _bForceOutOfDate);
    class UTargetDB* BPF_GetTargetDB();
    TArray<class AActor*> BPF_GetPotentialTargetsForAction(EActionType _eActionType);
    FHitBox BPF_GetNextActiveHitBox(bool _bIncludeActive, bool& _bSuccess, bool& _bOutMirror, float& _fOutDelay);
    ELimbs BPF_GetLimbFromBone(FName _boneName, bool _bMirror);
    float BPF_GetFocusTimeLeftInRatio();
    float BPF_GetFocusTimeLeft();
    class UFocusDB* BPF_GetFocusDB();
    EDangerStates BPF_GetDangerState();
    class AThrowableActor* BPF_GetCurrentThrowable();
    class APushableActor* BPF_GetCurrentPushable();
    float BPF_GetCurrentFocusPointsValue();
    FAvoidWindow BPF_GetCurrentAvoidWindow(bool& _bSuccess);
    float BPF_GetCurrentAttackTimeLeft();
    EAttackStates BPF_GetCurrentAttackState();
    float BPF_GetCurrentAttackRatio();
    FName BPF_GetCurrentAttackName();
    float BPF_GetCurrentAttackDuration();
    FComboAttack BPF_GetCurrentAttack(bool& _bSuccess);
    FAbsorbWindow BPF_GetCurrentAbsorbWindow(bool& _bSuccess);
    FHitBox BPF_GetBestActiveHitBox(bool& _bSuccess, bool& _bOutMirror);
    void BPF_ConsumeFocusPoints(float _fFocusPoints);
    bool BPF_CanConsumeFocusPoints(float _fFocusPointsNeeded);
    void BPF_AddFocusPointRefillValue(float _fFocusPointsToAdd);
    void BPF_AddFocusPointRefill(FSCUserDefinedEnumHandler _focusGainEnum);
}; // Size: 0xC80

class UAttackCookingDB : public UDataAsset
{
}; // Size: 0x30

class UAttackDB : public UDataAsset
{
    FComboAttack m_Attack;                                                            // 0x0030 (size: 0x150)
    int32 m_iVersionNumber;                                                           // 0x0180 (size: 0x4)

}; // Size: 0x188

class UAttackForceTrackingNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UAttackFramesNotifyState : public UAnimNotifyState
{
    class UAttackDB* m_DB;                                                            // 0x0030 (size: 0x8)

}; // Size: 0x38

class UAttackHitBoxTargetInfluenceTest : public UAIInfluenceTest
{
    EAttackTarget m_eHitTarget;                                                       // 0x0050 (size: 0x1)

}; // Size: 0x58

class UAttackMemoryInfluenceTest : public UAIInfluenceTest
{
    FGameplayTagContainer m_AttackProperties;                                         // 0x0050 (size: 0x20)
    bool m_bTestThrowAttack;                                                          // 0x0070 (size: 0x1)
    TSoftClassPtr<AThrowableActor> m_ThrowableClassToTest;                            // 0x0078 (size: 0x28)
    float m_fMemoryLimit;                                                             // 0x00A0 (size: 0x4)
    uint8 m_uiHitsCount;                                                              // 0x00A4 (size: 0x1)
    uint8 m_HitTypes;                                                                 // 0x00A5 (size: 0x1)
    bool m_bDodged;                                                                   // 0x00A6 (size: 0x1)
    bool m_bAvoided;                                                                  // 0x00A7 (size: 0x1)

}; // Size: 0xA8

class UAttackOriginHelper : public UBlueprintFunctionLibrary
{

    EAttackOrigin BPF_Mirror(EAttackOrigin _eAttackOrigin, bool _bMirror);
}; // Size: 0x28

class UAttackPreview : public UObject
{
}; // Size: 0x58

class UAttackProgressNotification : public UBaseNotification
{
    bool m_bDiscovered;                                                               // 0x0030 (size: 0x1)
    bool m_bUnlocked;                                                                 // 0x0031 (size: 0x1)
    FName m_Attack;                                                                   // 0x0034 (size: 0x8)
    int32 m_iBaseXP;                                                                  // 0x003C (size: 0x4)
    int32 m_iGainedXP;                                                                // 0x0040 (size: 0x4)

    class UAttackProgressNotification* BPF_InitUnlocked(FName _attack);
    class UAttackProgressNotification* BPF_InitProgress(FName _attack, int32 _iBaseXP, int32 _iGainedXP);
    class UAttackProgressNotification* BPF_InitDiscovered(FName _attack);
}; // Size: 0x48

class UAttackPropertiesInfluenceTest : public UAIInfluenceTest
{
    FGameplayTagContainer m_AttackProperties;                                         // 0x0050 (size: 0x20)

}; // Size: 0x70

class UAttackPropertiesResistanceDB : public UInheritedDataAsset
{
    FAttackPropertyResistanceMatrixByFightingState m_ResistanceMatrix;                // 0x0038 (size: 0x144)
    bool m_bIsConsidereredAsKnockdownThreat;                                          // 0x017C (size: 0x1)
    bool m_bInterruptDownWhenAlone;                                                   // 0x017D (size: 0x1)
    FPropertyReaction m_DownReaction;                                                 // 0x0180 (size: 0xD0)
    FStructureBrokenReaction m_StructureBrokenReaction;                               // 0x0250 (size: 0x40)
    FDizzyReaction m_DizzyReaction;                                                   // 0x0290 (size: 0xF0)
    FSuperDizzyReaction m_SuperDizzyReaction;                                         // 0x0380 (size: 0xC)
    FPushPropertyReaction m_PushedReaction;                                           // 0x0390 (size: 0xB90)
    FAnimContainer m_FallFromPushedAnim;                                              // 0x0F20 (size: 0x18)

}; // Size: 0xF38

class UAttackPropertyLevelHelper : public UBlueprintFunctionLibrary
{

    int32 BPF_GetAttackPropertyLevel(const FAttackPropertyLevel& _attackPropertyLevel, EHitBoxAttackProperties _eProperty);
}; // Size: 0x28

class UAttackStateCondition : public UBaseActorCondition
{
    TArray<EAttackStates> m_AllowedStates;                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAttackTrackingOrderService : public UOrderService
{
    float m_fForceTrackingFrames;                                                     // 0x0028 (size: 0x4)
    bool m_bAlwaysTrackHittedTarget;                                                  // 0x002C (size: 0x1)
    bool m_bIsTrackingWindowOpenedByDefault;                                          // 0x002D (size: 0x1)
    bool m_bIsRushAttack;                                                             // 0x002E (size: 0x1)
    bool m_bUseDisplacementDirAsAttackDir;                                            // 0x002F (size: 0x1)
    TArray<EOrderType> m_StopTrackingIfTargetPlaysOrder;                              // 0x0030 (size: 0x10)

    void BPF_GetTrackingLocation(const FBPOrderServiceInstance& _instance, bool& _bSuccess, FVector& _value);
}; // Size: 0x40

class UAttackWithWeaponInfluenceTest : public UAIInfluenceTest
{
}; // Size: 0x50

class UAttacksComboDB : public UDataAsset
{
    FAttackComboDB m_Struct;                                                          // 0x0030 (size: 0x120)

}; // Size: 0x150

class UAuthoriseHitNotify : public USCAnimNotify
{
}; // Size: 0x48

class UAvailabilityKeyValuePair : public UDataAsset
{
    EFightingActionState m_eFightingActionState;                                      // 0x0030 (size: 0x1)
    class UAvailabilityLayerData* m_Data;                                             // 0x0038 (size: 0x8)
    bool m_bOverrideAllLayers;                                                        // 0x0040 (size: 0x1)

}; // Size: 0x48

class UAvailabilityLayerDB : public UDataAsset
{
    TArray<class UAvailabilityKeyValuePair*> m_pairs;                                 // 0x0030 (size: 0x10)
    class UAvailabilityLayerData* m_defaultLayerData;                                 // 0x0040 (size: 0x8)
    class UAvailabilityLayerData* m_NoActionLayerData;                                // 0x0048 (size: 0x8)
    class UAvailabilityLayerData* m_NothingLayerData;                                 // 0x0050 (size: 0x8)
    class UAvailabilityLayerData* m_FallLayerData;                                    // 0x0058 (size: 0x8)

}; // Size: 0x60

class UAvailabilityLayerData : public UDataAsset
{
    InputContext m_eContext;                                                          // 0x0030 (size: 0x1)
    TArray<FAvailabilityLayerCombinations> m_Combinations;                            // 0x0038 (size: 0x10)
    bool m_bInvertSelection;                                                          // 0x0048 (size: 0x1)
    TArray<InputAction> m_inputActionArray;                                           // 0x0050 (size: 0x10)

}; // Size: 0x70

class UAvailabilityLayerNotifyState : public USCAnimNotifyState
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0048 (size: 0x8)
    EALBinaryOperation m_eOperation;                                                  // 0x0050 (size: 0x1)
    int32 m_iPriority;                                                                // 0x0054 (size: 0x4)
    FString m_alName;                                                                 // 0x0058 (size: 0x10)

}; // Size: 0x78

class UAvailabilityLayerOrderService : public UOrderService
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0028 (size: 0x8)
    EALBinaryOperation m_eOperation;                                                  // 0x0030 (size: 0x1)
    int32 m_iPriority;                                                                // 0x0034 (size: 0x4)

}; // Size: 0x38

class UAvoidAbility : public USCGameplayAbility
{

    FAutoAvoidInfos BPF_GetAutoAvoidInfos();
    ESCCardinalPoints BPE_GetCardinalAvoidForHitBox(const FHitBox& _hitbox);
    void BPE_GetAvoidAnimationsBis(class AActor* _forActor, class AActor* _forTarget, ESCCardinalPoints _eCardinal, ESCCardinalPoints _eTargetCardinal, const bool _bTargetAttackIsMirrored, const bool _bIsHitBoxValid, const FHitBox& _hitbox, TArray<FAnimContainer>& _outAnimContainer, bool& _bMirror, uint8& _outUIAvoidType);
    void BPE_GetAvoidAnimations(const FSCGameplayAbilityActorInfo& _infos, const FGameplayEventData& _triggerEventData, class UAbilityPayload* _payload, TArray<FAnimContainer>& _outAnimContainer, bool& _bMirror, uint8& _outUIAvoidType);
}; // Size: 0x820

class UAvoidBTTask : public UAIDefenseBTTask
{
}; // Size: 0x90

class UAvoidDB : public UDataAsset
{
    TSubclassOf<class UAvoidMatchCondition> m_AvoidMatchConditionClass;               // 0x0030 (size: 0x8)
    FCardinalMatchArray m_CardinalMatchArray;                                         // 0x0038 (size: 0x70)
    bool m_bHasImpactOnGuardGauge;                                                    // 0x00A8 (size: 0x1)
    float m_fGuardGaugeCost;                                                          // 0x00AC (size: 0x4)
    bool m_bAvoidConsumStamina;                                                       // 0x00B0 (size: 0x1)
    bool m_bOverrideAnimDynamicByCurve;                                               // 0x00B1 (size: 0x1)
    class UCurveFloat* m_AvoidMovementdynamic;                                        // 0x00B8 (size: 0x8)
    float m_fAvoidDuration;                                                           // 0x00C0 (size: 0x4)
    int32 m_iFrameBuildUp;                                                            // 0x00C4 (size: 0x4)
    int32 m_iFrameRelease;                                                            // 0x00C8 (size: 0x4)
    float m_fTrackingDuration;                                                        // 0x00CC (size: 0x4)
    float m_fJumpSelectionAngleWidth;                                                 // 0x00D0 (size: 0x4)
    float m_fDuckSelectionAngleWidth;                                                 // 0x00D4 (size: 0x4)
    float m_fDodgeAvoidNorthAngle;                                                    // 0x00D8 (size: 0x4)
    float m_fDodgeAvoidSouthAngle;                                                    // 0x00DC (size: 0x4)
    class UAvoidPropertyDB* m_DefaultAvoidPropertyDBs;                                // 0x00E0 (size: 0x38)
    EAvoidLaunchMethod m_eAvoidLaunchMethodOnHitDismissed;                            // 0x0118 (size: 0x1)
    float m_fAvoidedDuration;                                                         // 0x011C (size: 0x1C)
    float m_SuperAvoidedDuration;                                                     // 0x0138 (size: 0x1C)
    float m_fAvoidSuccessfulRefillValue;                                              // 0x0154 (size: 0x4)
    float m_fSuperAvoidSuccessfulRefillValue;                                         // 0x0158 (size: 0x4)
    float m_fAvoidSuccessfulGuardGaugeRefillValue;                                    // 0x015C (size: 0x4)
    float m_fSuperAvoidSuccessfulGuardGaugeRefillValue;                               // 0x0160 (size: 0x4)
    class UCurveFloat* m_AvoidedAttackScaleCurves;                                    // 0x0168 (size: 0x38)
    FBool m_AvoidDismissesPerfectLink;                                                // 0x01A0 (size: 0x7)
    FBool m_SuperAvoidDismissesPerfectLink;                                           // 0x01A7 (size: 0x7)
    int32 m_iOrdersAllowedToPushAvoidSuccessfulLayer;                                 // 0x01B0 (size: 0x4)
    int32 m_iSuperAvoidOrders;                                                        // 0x01B4 (size: 0x4)
    class UAvoidMatchCondition* m_AvoidMatchCondition;                                // 0x01B8 (size: 0x8)

}; // Size: 0x1C0

class UAvoidMatchCondition : public UObject
{

    EAvoidTrackingTypes BPE_GetAttackTrackingResponseFromAvoidType(EAvoidType _eAvoidType);
    bool BPE_DoesAvoidMatch(EAvoidType _eAvoidType, const FHitBox& _hitbox, bool _bMirror);
    bool BPE_DoesAvoidDismissesHit(EAvoidType _eAvoidType, ESCCardinalPoints _eCardPoint, const FHitBox& _hitbox, bool _bMirror);
}; // Size: 0x28

class UAvoidPropertyDB : public USpecialAbilityPropertyDB
{
    float m_fAvoidedDuration;                                                         // 0x0050 (size: 0x4)
    class UCurveFloat* m_AvoidedAttackScaleCurves;                                    // 0x0058 (size: 0x8)
    EAvoidFeedbackTypes m_eAvoidFeedbackTypes;                                        // 0x0060 (size: 0x1)
    bool m_bAvoidedEnterDizzyOnAttacked;                                              // 0x0061 (size: 0x1)
    class UAvoidPropertyDB* m_AvoidDBOnDizzyAttack;                                   // 0x0068 (size: 0x8)
    bool m_bShouldEndCombo;                                                           // 0x0070 (size: 0x1)

}; // Size: 0x78

class UAvoidWindowNotifyState : public USCAnimNotifyState
{
    TArray<EAvoidType> m_AvoidTypeArray;                                              // 0x0048 (size: 0x10)
    FAvoidPropertyContainer m_AvoidPropertyContainer;                                 // 0x0058 (size: 0x38)

}; // Size: 0x90

class UBPInfluenceTest : public UAIInfluenceTest
{
    FText m_NodeName;                                                                 // 0x0050 (size: 0x18)

    bool BPE_RunBPTest(const class UAIFightingComponent* _testedAI);
    FText BPE_GetDescriptionDetails();
}; // Size: 0x68

class UBTTask_CameraNode : public UBTTaskNode
{
    class UAbstractCameraData* m_CameraData;                                          // 0x0070 (size: 0x8)

}; // Size: 0x78

class UBTTask_DynamicCameraNode : public UBTTaskNode
{
    FBlackboardKeySelector m_CameraDataBlackboardKeySelector;                         // 0x0070 (size: 0x28)
    FBlackboardKeySelector m_ActorRefBlackboardKeySelector;                           // 0x00A0 (size: 0x28)

}; // Size: 0xD0

class UBaseActorCondition : public UObject
{
}; // Size: 0x28

class UBaseActorConditionHelpers : public UBlueprintFunctionLibrary
{

    class UObject* BPF_GetInstance(const FBaseActorConditionInstance& _instance);
    bool BPF_Evaluate(const FBaseActorConditionInstance& _instance, class AActor* _actor, bool _bDefaultResult);
}; // Size: 0x28

class UBaseActorTargetCondition : public UObject
{
}; // Size: 0x28

class UBaseArenaObjective : public UWGAchievementUnlockCondition
{
    FBaseArenaObjective_OnStarsCountChanged m_OnStarsCountChanged;                    // 0x01C8 (size: 0x10)
    void OnStarsCountChanged(int32 _newCount, int32 _oldCount);
    FBaseArenaObjective_OnScoreChanged m_OnScoreChanged;                              // 0x01D8 (size: 0x10)
    void OnScoreChanged(int32 _newScore);
    FBaseArenaObjectiveOnObjectiveStart OnObjectiveStart;                             // 0x01E8 (size: 0x10)
    void DynamicMulticast();
    FBaseArenaObjectiveObjectiveStartTimerElapsedDelegate ObjectiveStartTimerElapsedDelegate; // 0x01F8 (size: 0x10)
    void DynamicMulticast();
    EScoreComparisonType m_eScoreComparisonType;                                      // 0x0208 (size: 0x1)
    TArray<int32> m_ScoreThresholds;                                                  // 0x0210 (size: 0x10)
    FStarUnlockConditionClassInstance m_GoldenStarUnlockCondition;                    // 0x0220 (size: 0x10)
    int32 m_iScore;                                                                   // 0x0230 (size: 0x4)
    bool m_bUseChrono;                                                                // 0x0234 (size: 0x1)
    bool m_bPauseChronoOnTakeDown;                                                    // 0x0235 (size: 0x1)
    bool m_bIsArenaObjectiveComplete;                                                 // 0x0236 (size: 0x1)
    int32 m_iStarCount;                                                               // 0x0240 (size: 0x4)

    bool ShouldShowScoreAsTime();
    void OnStarsCountChanged__DelegateSignature(int32 _newCount, int32 _oldCount);
    void OnScoreChanged__DelegateSignature(int32 _newScore);
    void OnPlayerTakeDownEnemyStarted(uint8 _uiID, class UOrderComponent* _OrderComponent);
    void OnPlayerTakeDownEnemyEnded(uint8 _uiID, class UOrderComponent* _OrderComponent);
    void OnPlayerDownStateChanged(class UCharacterHealthComponent* _healthComponent, EDownState _state);
    void OnGiveInitialControlToPlayer();
    int32 CountObtainedStars(int32 _iScore, bool _bCountGoldenStar);
    bool BPF_IsValidLevel(int32 _iLevel);
    int32 BPF_GetStarsCount();
    int32 BPF_GetScoreThreshold(int32 _iLevel);
    int32 BPF_GetScore();
    class UStarUnlockCondition* BPF_GetGoldenStarUnlockCondition();
    int32 BPF_GetCurrentChronoScore();
    void BPF_DebugGiveBestScore();
    int32 BPF_CountObtainedStars(int32 _iScore);
    void BPF_ComputeHighScore(int32& _iOutSavedHighScore, bool& _bOutIsNewHighScore);
    void BPE_OnPlayerPawnReady();
}; // Size: 0x278

class UBaseCombatPositionSettings : public UBasePositionSettings
{
    TMap<EAIWuguanTicketEvaluation, float> m_fTestScoreFactors;                       // 0x0038 (size: 0x50)

}; // Size: 0x88

class UBaseDirectionalTargetWeightEvaluation : public UObject
{
}; // Size: 0x28

class UBaseEnvironmentalInteractionComponent : public UActorComponent
{
    FBaseEnvironmentalInteractionComponent_OnImpact m_OnImpact;                       // 0x00C0 (size: 0x10)
    void OnImpact(class AFightingCharacter* _takenDown, const FNetOrderStructTakedown& _takedownInfos);
    bool m_bActive;                                                                   // 0x00D0 (size: 0x1)
    EPushObstacleReaction m_eReaction;                                                // 0x00D4 (size: 0x4)
    int32 m_uiAllowedInteractionTypes;                                                // 0x00D8 (size: 0x4)

    void OnImpact__DelegateSignature(class AFightingCharacter* _takenDown, const FNetOrderStructTakedown& _takedownInfos);
    void BPE_OnTakedownStarted(class AFightingCharacter* _Instigator, class AFightingCharacter* _takenDown);
    EPushObstacleReaction BPE_GetPushReaction(const class AFightingCharacter* _Instigator, const class AFightingCharacter* _takenDown);
    bool BPE_CanTakeDown(class AFightingCharacter* _Instigator, class AFightingCharacter* _takenDown);
}; // Size: 0xE0

class UBaseHitDetectionDB : public UDataAsset
{
    bool m_bUseBoneTransform;                                                         // 0x0030 (size: 0x1)
    FName m_boneName;                                                                 // 0x0034 (size: 0x8)
    bool m_bIsSocket;                                                                 // 0x003C (size: 0x1)
    bool m_bOnTargetOnly;                                                             // 0x003D (size: 0x1)
    FVector m_vOffset;                                                                // 0x0040 (size: 0xC)
    FRotator m_RotationOffset;                                                        // 0x004C (size: 0xC)

    FName BPF_GetRealBoneName(class USkeletalMeshComponent* _meshComponent);
    FName BPF_GetBoneOnCharacter(class ABaseCharacter* _character, bool _bMirror, FTransform& _delta);
}; // Size: 0x58

class UBaseItemData : public UDataAsset
{
    FText m_ItemName;                                                                 // 0x0030 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_InventoryIcon;                                       // 0x0048 (size: 0x28)
    EEquipmentSlot m_EquipmentSlot;                                                   // 0x0070 (size: 0x1)
    bool m_bIsAResource;                                                              // 0x0071 (size: 0x1)
    bool m_bHasDurability;                                                            // 0x0072 (size: 0x1)
    bool m_bIsUnique;                                                                 // 0x0073 (size: 0x1)
    bool m_bCanBeSalvaged;                                                            // 0x0074 (size: 0x1)
    bool m_bCanBeDyed;                                                                // 0x0075 (size: 0x1)

}; // Size: 0x78

class UBaseMovementDB : public UInheritedDataAsset
{
    class UDetailedMoveTransitionDB* m_DetailedMoveTransitionDB;                      // 0x0038 (size: 0x8)
    TSubclassOf<class UTransitionAnimRequest> m_TransitionAnimRequest;                // 0x0040 (size: 0x8)
    FSpeedStateBlendTo m_BlendDescription;                                            // 0x0048 (size: 0x100)
    float m_fRushMoveAnimSpeed;                                                       // 0x0148 (size: 0x4)
    float m_fRushMoveOverallStretchFactor;                                            // 0x014C (size: 0x4)
    float m_fRushMoveMaxAngularSpeed;                                                 // 0x0150 (size: 0x4)
    float m_fRushMoveTransitionMaxAngularSpeed;                                       // 0x0154 (size: 0x4)
    float m_fRushStaminaConsumptionRate;                                              // 0x0158 (size: 0x4)
    class UCurveFloat* m_RushStaminaConsumptionOverWeightRatio;                       // 0x0160 (size: 0x8)
    float m_fRushCooldownBurnAllStamina;                                              // 0x0168 (size: 0x4)
    float m_fWantToRushInLockMoveTimeOut;                                             // 0x016C (size: 0x4)
    bool m_bSwitchToExploOnLongRush;                                                  // 0x0170 (size: 0x1)
    float m_fRushDurationToExplo;                                                     // 0x0174 (size: 0x4)
    bool m_bAuthorizeMirroring;                                                       // 0x0178 (size: 0x1)
    TArray<FAnimContainer> m_AlertedAIIdlesAnims;                                     // 0x0180 (size: 0x10)
    TArray<FAnimContainer> m_BaseAIIdlesAnims;                                        // 0x0190 (size: 0x10)
    FAnimContainer m_FreeMoveAnim;                                                    // 0x01A0 (size: 0x60)
    FreeMoveAnimQuadrant m_FreeMoveAnimQuadrant;                                      // 0x0200 (size: 0x80)
    FAnimContainer m_FreeMoveAnimWeapon;                                              // 0x0280 (size: 0x60)
    FreeMoveAnimQuadrant m_FreeMoveAnimWeaponQuadrant;                                // 0x02E0 (size: 0x80)
    FCardinalSpeed m_LockMoveSpeed;                                                   // 0x0360 (size: 0x54)
    float m_fLockMoveOverallStretchFactor;                                            // 0x03B4 (size: 0x4)
    FCardinalSpeed m_FreeMoveSpeeds;                                                  // 0x03B8 (size: 0x150)
    float m_fFreeMoveV1AnimSpeed;                                                     // 0x0508 (size: 0x4)
    float m_fFreeMoveV1OverallStretchFactor;                                          // 0x050C (size: 0x4)
    float m_fFreeMoveV2AnimSpeed;                                                     // 0x0510 (size: 0x4)
    float m_fFreeMoveV2OverallStretchFactor;                                          // 0x0514 (size: 0x4)
    float m_fFreeMoveMaxAngularSpeed;                                                 // 0x0518 (size: 0x4)
    float m_fFreeMoveTransitionMaxAngularSpeed;                                       // 0x051C (size: 0x4)
    FBool m_bCamOverTheShoulder;                                                      // 0x0520 (size: 0x4)
    uint32 m_uiLookAtLockMoveTargetAllowedPerAlertLevelMask;                          // 0x0524 (size: 0x4)
    FLockMoveAnimQuadrant m_LockMoveAnim;                                             // 0x0528 (size: 0xA0)
    FLockMoveAnimQuadrant m_LockMoveAnimWeapon;                                       // 0x05C8 (size: 0xA0)
    float m_fAnimNorthSpeed;                                                          // 0x0668 (size: 0x4)
    float m_fAnimSouthSpeed;                                                          // 0x066C (size: 0x4)
    float m_fAnimEastSpeed;                                                           // 0x0670 (size: 0x4)
    float m_fAnimWestSpeed;                                                           // 0x0674 (size: 0x4)
    float m_fLockMoveMaxAngularSpeed;                                                 // 0x0678 (size: 0x4)
    float m_fLockMoveTransitionMaxAngularSpeed;                                       // 0x067C (size: 0x4)
    float m_fV3LandingVelocityThreshold;                                              // 0x0680 (size: 0x4)
    float m_fV2LandingVelocityThreshold;                                              // 0x0684 (size: 0x4)
    float m_fV1LandingVelocityThreshold;                                              // 0x0688 (size: 0x4)
    float m_fV3ActionToLocomotionSpeedThreshold;                                      // 0x068C (size: 0x4)
    float m_fV2ActionToLocomotionSpeedThreshold;                                      // 0x0690 (size: 0x4)
    float m_fV1ActionToLocomotionSpeedThreshold;                                      // 0x0694 (size: 0x4)
    float m_fActionToLocomotionBlendDuration;                                         // 0x0698 (size: 0x4)
    ESCBlendType m_eActionToLocomotionBlendType;                                      // 0x069C (size: 0x1)
    float m_WeightCategoryMobilityRatios;                                             // 0x06A0 (size: 0x10)
    float m_WeightCategoryMobilityRatiosLockMove;                                     // 0x06B0 (size: 0x10)
    bool m_bOverweightImpactFreemoveState;                                            // 0x06C0 (size: 0x1)
    class UCurveFloat* m_LockMoveVelocityLerpCurve;                                   // 0x06C8 (size: 0x8)
    class UCurveFloat* m_FreeMoveVelocityLerpCurves;                                  // 0x06D0 (size: 0x20)
    FLocomotionRotationParams m_LockMoveRotationParams;                               // 0x06F0 (size: 0x30)
    FLocomotionRotationParams m_FreeMoveRotationParams;                               // 0x0720 (size: 0x30)
    FFloatRange m_AccumulationRotationDelayTimeRange;                                 // 0x0750 (size: 0x10)
    class UCurveFloat* m_RotationSpeedMultiplierByTime;                               // 0x0760 (size: 0x8)
    bool m_bEnableTransitions;                                                        // 0x0768 (size: 0x1)
    float m_fMaxStrafeDeltaAngle;                                                     // 0x076C (size: 0x4)
    float m_fStartInterruptFirstStepRatio;                                            // 0x0770 (size: 0x4)
    bool m_bFreeMoveEnableAnimTransitions;                                            // 0x0774 (size: 0x1)
    bool m_bFreeMoveEnablePivotFoot;                                                  // 0x0775 (size: 0x1)
    bool m_bLockMoveEnableAnimTransitions;                                            // 0x0776 (size: 0x1)
    bool m_bLockMoveEnablePivotFoot;                                                  // 0x0777 (size: 0x1)
    bool m_EnableInputStabilisationOnMove;                                            // 0x0778 (size: 0x1)
    bool m_EnableSpeedBlender;                                                        // 0x0779 (size: 0x1)
    float m_fMaxCoeffToUsePreviousSpeed;                                              // 0x077C (size: 0x4)
    float m_fMaxCoeffOrderedToUsePreviousSpeed;                                       // 0x0780 (size: 0x4)
    uint32 m_uiForceKeepForwardOnStartsByMoveStatus;                                  // 0x0784 (size: 0x4)
    class USpeedPivotFootData* m_FreeMovePivotFootParams;                             // 0x0788 (size: 0x20)
    class USpeedPivotFootData* m_LockMovePivotFootParams;                             // 0x07A8 (size: 0x8)
    class UDodgeDB* m_DodgeDB;                                                        // 0x07B0 (size: 0x8)

    float BPF_GetFreeMoveSpeed(const FVector& _vLocalDir, const float _fGlobalIntensity, const ESpeedState _eSpeedState);
    float BPF_GetFreeMoveOverallAnimSpeed(ESpeedState _eSpeedState);
    float BPF_GetFreeMoveAnimSpeed(ESpeedState _eSpeedState);
}; // Size: 0x7B8

class UBaseNotification : public UObject
{
    EMenuEnum m_eOpenMenu;                                                            // 0x0028 (size: 0x1)

}; // Size: 0x30

class UBasePositionSettings : public UObject
{
    TArray<FCombatCircleDescription> m_CirclesDescriptions;                           // 0x0028 (size: 0x10)

}; // Size: 0x38

class UBaseShapeHitDetectionDB : public UBaseHitDetectionDB
{
    bool m_bApplyOwnerScale;                                                          // 0x0058 (size: 0x1)

}; // Size: 0x70

class UBaseStartMenu : public UMenuWidget
{

    bool BPF_IsDebugPIEEnabled();
}; // Size: 0x3F0

class UBaseTargetEvaluation : public UObject
{
    class UCurveFloat* m_Curve;                                                       // 0x0028 (size: 0x8)
    ETargetingPrio m_eTargettingType;                                                 // 0x0030 (size: 0x1)

}; // Size: 0x38

class UBaseTargetWeightEvaluation : public UObject
{
}; // Size: 0x28

class UBaseUseCondition : public UObject
{

    bool IsFulfilled();
    void GetSurroundingPlayersNumInRange(float _fRange, int32& _iOutPlayersInside, int32& _iOutTotalPlayers);
    bool BPF_IsTargetPlayingOrder(EOrderType _eOrderType, uint8& _uiOutOrderID);
    bool BPF_IsStaminaRatioBelow(float _fStaminaThreshold);
    bool BPF_IsHitted(EGuardType& _eOutGuardType);
    bool BPF_IsHealthRatioBelow(float _fHealthThreshold);
    bool BPF_IsDamageTakenRatioBelow(float _fDmgTakenThreshold, float _fTime);
    bool BPF_IsAttackIncoming(float& _fOutTimeTillStrike);
    bool BPF_HasAttackTicket();
    ESpeedState BPF_GetTargetSpeedState();
    EFightingState BPF_GetTargetFightingState();
    int32 BPF_GetHitCount(float _fTime, EGuardType _eGuardTypeFilter);
    float BPF_GetDistFromTarget();
    FName BPF_GetDifficultyName();
    float BPF_GetDifficultyLevelGauge();
    float BPF_GetDamageTaken(float _fTime);
    void BPE_OnFulfilled();
}; // Size: 0x58

class UBaseWeaponData : public UObject
{
    FName m_Socket;                                                                   // 0x0028 (size: 0x8)
    FName m_OnWeaponSocketName;                                                       // 0x0030 (size: 0x8)
    TMap<class EOrderType, class bool> m_UseSwapHandByOrder;                          // 0x0038 (size: 0x50)
    bool m_bUseSwapHand;                                                              // 0x0088 (size: 0x1)
    bool m_bMirrorAllowed;                                                            // 0x0089 (size: 0x1)
    bool m_bAllowFakieFromAnimNotify;                                                 // 0x008A (size: 0x1)
    class UCurveFloat* m_DesignatedTargetPreciseSearchWidthCurveForAttack;            // 0x0090 (size: 0x8)
    class UCurveFloat* m_DesignatedTargetRoughSearchWidthCurveForAttack;              // 0x0098 (size: 0x8)
    TMap<ETargetingPrio, float> m_mfRangeMaxForAttack;                                // 0x00A0 (size: 0x50)
    float m_afDamageReceiveFromAttackPower;                                           // 0x00F0 (size: 0xC)
    float m_afGuardTypeDamageMultiplier;                                              // 0x00FC (size: 0xC)
    class UCurveFloat* m_SlowMotionCurve;                                             // 0x0108 (size: 0x8)
    float m_fSlowMotionScale;                                                         // 0x0110 (size: 0x4)
    TSubclassOf<class UThrowObjectAnimRequest> m_ThrowFromPickupAnimRequest;          // 0x0118 (size: 0x8)
    FBaseWeaponOverrideInfo m_MainCharOverrides;                                      // 0x0120 (size: 0x18)
    bool m_bUseSpecificMirrorPickupAnim;                                              // 0x0138 (size: 0x1)
    TMap<class EOrderType, class FVariableWeightLayerToBoneMask> m_variableWeightLayerByOrder; // 0x0140 (size: 0x50)

    void BPE_PrePickUpWeapon(class AFightingCharacter* _owner, class UPlayerAnim* _animGraph, const class ABaseWeapon* _weapon, bool _bMirror);
    void BPE_PreDropWeapon(class AFightingCharacter* _owner, class UPlayerAnim* _animGraph, const class ABaseWeapon* _weapon);
    void BPE_OnUnequipWeapon(class AFightingCharacter* _owner, class UPlayerAnim* _animGraph, const class ABaseWeapon* _weapon);
    void BPE_OnEquipWeapon(class AFightingCharacter* _owner, class UPlayerAnim* _animGraph, const class ABaseWeapon* _weapon);
}; // Size: 0x190

class UBasicSpawningComponent : public UActorComponent
{
}; // Size: 0xC0

class UBehaviorTargetCondition : public UBaseActorTargetCondition
{
    uint32 m_uiBehaviorMask;                                                          // 0x0028 (size: 0x4)

}; // Size: 0x30

class UBehaviourCombinationInputData : public UCombinationInputData
{
    FInputBehaviourStruct m_BehaviourStruct;                                          // 0x00E8 (size: 0xC)

}; // Size: 0xF8

class UBehaviourVectorInputData : public UVectorInputData
{
    FInputBehaviourStruct m_BehaviourStruct;                                          // 0x0180 (size: 0xC)
    bool m_bConsiderChangingValueAsNewPress;                                          // 0x018C (size: 0x1)

}; // Size: 0x190

class UBeingTakendownTask : public UBTTaskNode
{
}; // Size: 0x78

class UBindableAsyncImage : public UUserWidget
{
    class UAsyncImage* m_AsyncImage;                                                  // 0x0268 (size: 0x8)
    FAsyncTextureStruct AsyncTexture;                                                 // 0x0270 (size: 0x28)
    FBindableAsyncImageAsyncTextureDelegate AsyncTextureDelegate;                     // 0x0298 (size: 0x10)
    FAsyncTextureStruct GetAsyncTextureAsset();

}; // Size: 0x2E8

class UBindableBoolProperty : public UBindablePropertyBase
{

    void BPF_SetValue(bool _bValue);
    void BPF_SetRef(bool& _bValue);
    bool BPF_GetValue();
}; // Size: 0x68

class UBindableEnumProperty : public UBindablePropertyBase
{

    void BPF_SetValue(uint8 _uiValue);
    void BPF_SetRef(uint8& _uiValue);
    uint8 BPF_GetValue();
}; // Size: 0x68

class UBindableFlagProperty : public UBindableIntProperty
{

    void BPF_RemoveFlags(int32 _iFlags);
    bool BPF_HasAnyFlags(int32 _iFlags);
    bool BPF_HasAllFlags(int32 _iFlags);
    void BPF_AddFlags(int32 _iFlags);
}; // Size: 0x68

class UBindableFloatProperty : public UBindablePropertyBase
{

    void BPF_SetValue(float _fValue);
    void BPF_SetRef(float& _fValue);
    float BPF_GetValue();
}; // Size: 0x68

class UBindableIntProperty : public UBindablePropertyBase
{

    void BPF_SetValue(int32 _iValue);
    void BPF_SetRef(int32& _iValue);
    int32 BPF_GetValue();
}; // Size: 0x68

class UBindableMaterialWidget : public USCUserWidget
{
    class UMaterialInstanceDynamic* m_MaterialInstance;                               // 0x0310 (size: 0x8)
    FName m_FloatParameterName;                                                       // 0x0318 (size: 0x8)
    float FloatValue;                                                                 // 0x0320 (size: 0x4)
    FBindableMaterialWidgetFloatValueDelegate FloatValueDelegate;                     // 0x0324 (size: 0x10)
    float GetFloat();

    void BPF_SetMaterialInstance(class UMaterialInstanceDynamic* _materialInstance);
}; // Size: 0x358

class UBindablePropertyBase : public UObject
{
    FBindablePropertyBase_OnUpdateFromModel m_OnUpdateFromModel;                      // 0x0028 (size: 0x10)
    void BindablePropertyUpdateSignature(class UBindablePropertyBase* _property);
    FBindablePropertyBase_OnPropertyUpdate m_OnPropertyUpdate;                        // 0x0038 (size: 0x10)
    void BindablePropertyUpdateSignature(class UBindablePropertyBase* _property);
    FBindablePropertyBase_OnPropertyPreUpdate m_OnPropertyPreUpdate;                  // 0x0048 (size: 0x10)
    void BindablePropertyUpdateSignature(class UBindablePropertyBase* _property);

    void BPF_SetOwner(class UObject* _owner);
    bool BPF_IsValid();
}; // Size: 0x60

class UBindablePropertyUserWidget : public USCUserWidget
{
    FBindablePropertyUserWidget_OnInputUpdate m_OnInputUpdate;                        // 0x0310 (size: 0x10)
    void OnInputUpdateSignature();
    FBindablePropertyUserWidget_OnPropertyUpdated m_OnPropertyUpdated;                // 0x0320 (size: 0x10)
    void OnPropertyUpdatedSignature();
    bool m_bSelfBindingProperty;                                                      // 0x0330 (size: 0x1)
    bool m_bConstructProperty;                                                        // 0x0331 (size: 0x1)
    TSubclassOf<class UBindablePropertyBase> m_PropertyClass;                         // 0x0338 (size: 0x8)
    FName m_PropertyName;                                                             // 0x0340 (size: 0x8)
    class UBindablePropertyBase* m_Property;                                          // 0x0348 (size: 0x8)

    void OnPropertyUpdated(class UBindablePropertyBase* _property);
    void BPF_RefreshDisplay();
    void BPF_OnInputUpdate();
    void BPF_CreateProperty();
    void BPE_OnSelfBinding();
}; // Size: 0x350

class UBindableStringProperty : public UBindablePropertyBase
{

    void BPF_SetValue(FString _value);
    void BPF_SetRef(FString& _value);
    FString BPF_GetValue();
}; // Size: 0x68

class UBlackboardBoolCameraMixerBlender : public UBoolCameraMixerBlender
{
    FName m_KeyName;                                                                  // 0x0050 (size: 0x8)

}; // Size: 0x58

class UBlackboardSubActorCondition : public UBaseActorCondition
{
    FName m_BlackboardKey;                                                            // 0x0028 (size: 0x8)

}; // Size: 0x30

class UBlendInLockCameraTransitionInfo : public UCameraTransitionInfo
{
    bool m_bUseDefaultTargetReachDurationAsFallback;                                  // 0x0070 (size: 0x1)

}; // Size: 0x78

class UBlendProfileBySpeedStatePayload : public UBlendProfilePayload
{
    FBlendProfileBySpeedStateStruct m_BlendProfiles;                                  // 0x0028 (size: 0x20)

}; // Size: 0x48

class UBlendProfileHelper : public UBlueprintFunctionLibrary
{

    class UBlendProfile* BPF_GetBlendProfile(const FBlendProfileBySpeedStateStruct& _blendProfileBySpeedStateStruct, ESpeedState _eSpeedState);
}; // Size: 0x28

class UBlendableWidget : public USCUserWidget
{
    float m_fBlendDuration;                                                           // 0x0310 (size: 0x4)
    ESCType m_eBlendValueType;                                                        // 0x0314 (size: 0x1)
    FLinearColor m_ColorStart;                                                        // 0x0318 (size: 0x10)
    FLinearColor m_ColorEnd;                                                          // 0x0328 (size: 0x10)

    void BPF_StartTimerBlend(bool _bReverse);
    float BPF_GetBlendedFloat();
    FLinearColor BPF_GetBlendedColor();
    int32 BPF_BindMaterialParameterToBlendAlpha(class UMaterialParameterCollection* _collection, FName _parameterName);
}; // Size: 0x360

class UBlueprintActorCondition : public UBaseActorCondition
{

    bool BPE_Evaluate(const class AActor* _actor);
}; // Size: 0x28

class UBlueprintOrderService : public UOrderService
{

    void BPE_OnTick(const FBPOrderServiceInstance& _instance, float _fDelta);
    void BPE_OnStop(const FBPOrderServiceInstance& _instance, bool _bInterrupted);
    void BPE_OnStart(const FBPOrderServiceInstance& _instance);
}; // Size: 0x28

class UBoneToBoneSafeZoneOrderService : public USafeZoneOrderService
{
    TArray<FSafeZoneBonePair> m_bonePairList;                                         // 0x0078 (size: 0x10)
    float m_fForcedRatio;                                                             // 0x0088 (size: 0x4)

}; // Size: 0x90

class UBoolCameraMixerBlender : public UOverTimeCameraMixerBlender
{
    bool m_bInversed;                                                                 // 0x0030 (size: 0x1)
    float m_fDuration;                                                                // 0x0034 (size: 0x4)
    ESCBlendType m_eBlendType;                                                        // 0x0038 (size: 0x1)
    class UCurveFloat* m_Curve;                                                       // 0x0040 (size: 0x8)
    bool m_bConstantSpeed;                                                            // 0x0048 (size: 0x1)

    bool GetOldValue();
    bool BPE_GetBool(class UCameraComponentThird* _camera, bool _bNoDamping);
}; // Size: 0x50

class UBoxHitDetectionDB : public UBaseShapeHitDetectionDB
{
    FVector m_Extent;                                                                 // 0x0070 (size: 0xC)

}; // Size: 0x80

class UBoxWithNavComponent : public UBoxComponent
{

    void BPF_SetAreaClass(TSubclassOf<class UNavArea> _navArea);
}; // Size: 0x4C0

class UButtonInputRegionWidget : public USpacer
{
}; // Size: 0x120

class UButtonUserWidget : public USCUserWidget
{
    FButtonUserWidget_IsActionEnabledDelegate m_IsActionEnabledDelegate;              // 0x0310 (size: 0x10)
    bool ButtonActionEnabledDelegate(const class UButtonUserWidget* _button, const FButtonAction& _action);
    FButtonUserWidget_OnFocusReceived_Bindable m_OnFocusReceived_Bindable;            // 0x0320 (size: 0x10)
    void BindableButtonUserWidgetDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FButtonUserWidget_OnFocusLost_Bindable m_OnFocusLost_Bindable;                    // 0x0330 (size: 0x10)
    void BindableButtonUserWidgetDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FButtonUserWidget_OnClick_Bindable m_OnClick_Bindable;                            // 0x0340 (size: 0x10)
    void BindableButtonUserWidgetClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FButtonUserWidget_OnInputActionPressed_Bindable m_OnInputActionPressed_Bindable;  // 0x0350 (size: 0x10)
    void BindableButtonUserWidgetInputActionDelegate(class UButtonUserWidget* _button, InputAction _eInput);
    FButtonUserWidget_OnNavigation_Bindable m_OnNavigation_Bindable;                  // 0x0360 (size: 0x10)
    void BindableNavigationDelegate(class UButtonUserWidget* _button, EUINavigation _eNavigation);
    FButtonUserWidget_OnHoldStarted_Bindable m_OnHoldStarted_Bindable;                // 0x0370 (size: 0x10)
    void BindableButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnHoldCanceled_Bindable m_OnHoldCanceled_Bindable;              // 0x0380 (size: 0x10)
    void BindableButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnHoldSuccess_Bindable m_OnHoldSuccess_Bindable;                // 0x0390 (size: 0x10)
    void BindableButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnFocusReceived m_OnFocusReceived;                              // 0x03A0 (size: 0x10)
    void ButtonUserWidgetDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FButtonUserWidget_OnFocusLost m_OnFocusLost;                                      // 0x03B0 (size: 0x10)
    void ButtonUserWidgetDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FButtonUserWidget_OnClick m_OnClick;                                              // 0x03C0 (size: 0x10)
    void ButtonUserWidgetClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FButtonUserWidget_OnRightClick m_OnRightClick;                                    // 0x03D0 (size: 0x10)
    void ButtonUserWidgetRightClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FButtonUserWidget_OnInputActionPressed m_OnInputActionPressed;                    // 0x03E0 (size: 0x10)
    void ButtonUserWidgetInputActionDelegate(class UButtonUserWidget* _button, InputAction _eInput);
    FButtonUserWidget_OnSelect m_OnSelect;                                            // 0x03F0 (size: 0x10)
    void ButtonUserWidgetSelectedDelegate(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    FButtonUserWidget_OnDeselect m_OnDeselect;                                        // 0x0400 (size: 0x10)
    void ButtonUserWidgetDeselectedDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnNavigation m_OnNavigation;                                    // 0x0410 (size: 0x10)
    void ButtonUserWidgetNavigationDelegate(class UButtonUserWidget* _button, EUINavigation _eNavigation);
    FButtonUserWidget_OnHoldStarted m_OnHoldStarted;                                  // 0x0420 (size: 0x10)
    void ButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnHoldCanceled m_OnHoldCanceled;                                // 0x0430 (size: 0x10)
    void ButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FButtonUserWidget_OnHoldSuccess m_OnHoldSuccess;                                  // 0x0440 (size: 0x10)
    void ButtonUserWidgetSimpleDelegate(class UButtonUserWidget* _button);
    FSlateBrush m_DefaultStateBrush;                                                  // 0x0450 (size: 0x88)
    FSlateBrush m_MouseOverStateBrush;                                                // 0x04D8 (size: 0x88)
    FSlateBrush m_MouseDownStateBrush;                                                // 0x0560 (size: 0x88)
    bool m_bUseFocusStateBrush;                                                       // 0x05E8 (size: 0x1)
    FSlateBrush m_FocusStateBrush;                                                    // 0x05F0 (size: 0x88)
    FSlateBrush m_CurrentStateBrush;                                                  // 0x0678 (size: 0x88)
    TEnumAsByte<EButtonClickMethod::Type> m_eClickMethod;                             // 0x0700 (size: 0x1)
    float m_fHoldDuration;                                                            // 0x0704 (size: 0x4)
    bool m_bFocusOnVisible;                                                           // 0x0708 (size: 0x1)
    bool m_bUseCustomNavigation;                                                      // 0x0709 (size: 0x1)
    FButtonAction m_Action1;                                                          // 0x0710 (size: 0x40)
    FButtonUserWidget_OnExecuteAction1 m_OnExecuteAction1;                            // 0x0750 (size: 0x10)
    void ButtonActionExecuteDelegate(class UButtonUserWidget* _button, const FButtonAction& _action);
    FButtonAction m_Action2;                                                          // 0x0760 (size: 0x40)
    FButtonUserWidget_OnExecuteAction2 m_OnExecuteAction2;                            // 0x07A0 (size: 0x10)
    void ButtonActionExecuteDelegate(class UButtonUserWidget* _button, const FButtonAction& _action);
    FButtonAction m_Action3;                                                          // 0x07B0 (size: 0x40)
    FButtonUserWidget_OnExecuteAction3 m_OnExecuteAction3;                            // 0x07F0 (size: 0x10)
    void ButtonActionExecuteDelegate(class UButtonUserWidget* _button, const FButtonAction& _action);
    bool m_bIsClickable;                                                              // 0x0808 (size: 0x1)
    bool m_bFocusOnMouseOver;                                                         // 0x0809 (size: 0x1)
    bool m_bLoseFocusOnMouseLeave;                                                    // 0x080A (size: 0x1)
    bool m_bSelectOnClick;                                                            // 0x080B (size: 0x1)
    bool m_bSelectOnNavigationFocus;                                                  // 0x080C (size: 0x1)
    ESlateVisibility m_eSelectedVisibility;                                           // 0x080D (size: 0x1)
    ESlateVisibility m_eDeselectedVisibility;                                         // 0x080E (size: 0x1)
    ESlateVisibility m_eMouseOverVisibility;                                          // 0x080F (size: 0x1)
    ESlateVisibility m_eMouseOutVisibility;                                           // 0x0810 (size: 0x1)
    bool m_bIsSelected;                                                               // 0x0811 (size: 0x1)
    bool m_bPlayClickSound;                                                           // 0x0812 (size: 0x1)
    bool m_bPlayRightClickSound;                                                      // 0x0813 (size: 0x1)
    bool m_bIsMouseOver;                                                              // 0x0814 (size: 0x1)
    bool m_bIsMouseDown;                                                              // 0x0815 (size: 0x1)

    void ButtonUserWidgetSimpleDelegate__DelegateSignature(class UButtonUserWidget* _button);
    void ButtonUserWidgetSelectedDelegate__DelegateSignature(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    void ButtonUserWidgetRightClickDelegate__DelegateSignature(class UButtonUserWidget* _button, bool _bWithMouse);
    void ButtonUserWidgetNavigationDelegate__DelegateSignature(class UButtonUserWidget* _button, EUINavigation _eNavigation);
    void ButtonUserWidgetInputActionDelegate__DelegateSignature(class UButtonUserWidget* _button, InputAction _eInput);
    void ButtonUserWidgetDeselectedDelegate__DelegateSignature(class UButtonUserWidget* _button);
    void ButtonUserWidgetDelegate__DelegateSignature(class UButtonUserWidget* _button, EFocusCause _eCause);
    void ButtonUserWidgetClickDelegate__DelegateSignature(class UButtonUserWidget* _button, bool _bWithMouse);
    void ButtonActionExecuteDelegate__DelegateSignature(class UButtonUserWidget* _button, const FButtonAction& _action);
    bool ButtonActionEnabledDelegate__DelegateSignature(const class UButtonUserWidget* _button, const FButtonAction& _action);
    void BPF_SetSelected(bool _bSelected, bool _bForce);
    bool BPF_IsActionEnabled(const FButtonAction& _action);
    bool BPF_GetIsSelected();
    float BPF_GetHoldProgress();
    void BPE_OnSelected();
    void BPE_OnRightClicked();
    void BPE_OnInputActionPressed(InputAction _eAction);
    void BPE_OnDeselected();
    void BPE_OnClicked();
    void BindableNavigationDelegate__DelegateSignature(class UButtonUserWidget* _button, EUINavigation _eNavigation);
    void BindableButtonUserWidgetSimpleDelegate__DelegateSignature(class UButtonUserWidget* _button);
    void BindableButtonUserWidgetInputActionDelegate__DelegateSignature(class UButtonUserWidget* _button, InputAction _eInput);
    void BindableButtonUserWidgetDelegate__DelegateSignature(class UButtonUserWidget* _button, EFocusCause _eCause);
    void BindableButtonUserWidgetClickDelegate__DelegateSignature(class UButtonUserWidget* _button, bool _bWithMouse);
}; // Size: 0x820

class UCDM_AnimDrivenSound : public UCameraDataModifier
{
    class UDeltaTransformAudioData* m_whooshAudio;                                    // 0x0028 (size: 0x8)

}; // Size: 0x30

class UCDM_Sound : public UCameraDataModifier
{
    class UAkAudioEvent* m_InAkEvent;                                                 // 0x0028 (size: 0x8)
    class UAkAudioEvent* m_OutAkEvent;                                                // 0x0030 (size: 0x8)

}; // Size: 0x38

class UCDM_SwitchCameraTrackingMode : public UCameraDataModifier
{
    ECameraTrackingMode m_eCameraTrackingModeTranslationIn;                           // 0x0028 (size: 0x1)

}; // Size: 0x30

class UCSCGameplayAbilityTargetDataLibrary : public UBlueprintFunctionLibrary
{

    FGameplayAbilityTargetDataHandle BP_AbilityTargetDataWithTarget(class AActor* _target);
}; // Size: 0x28

class UCTM_LookAt : public UCameraTransitionModule
{

    FVector BPE_GetPositionToLook(class UCameraComponentThird* _cameraComponent);
    bool BPE_CanLaunchLookAt(class UCameraComponentThird* _cameraComponent);
}; // Size: 0x28

class UCTM_PauseLookAt : public UCameraTransitionModule
{

    bool BPE_CanLaunchPauseLookAt(class UCameraComponentThird* _cameraComponent);
}; // Size: 0x28

class UCTM_SynchroMirrorMeleeService : public UCameraTransitionModule
{
}; // Size: 0x28

class UCameraBlendToOffsetRatioNotifyState : public UAnimNotifyState
{
    float m_fTargetRatio;                                                             // 0x0030 (size: 0x4)
    class UCurveFloat* m_BlendCurve;                                                  // 0x0038 (size: 0x8)

}; // Size: 0x40

class UCameraComponentThird : public UCameraComponent
{
    class UCameraLagStruct* m_sActualLagParameters;                                   // 0x07F8 (size: 0x8)
    FCameraComponentThirdOnLevelSequenceViewBlendStateChanged OnLevelSequenceViewBlendStateChanged; // 0x0800 (size: 0x10)
    void OnSequenceViewBlendChange(class USCLevelSequence* _levelSequence);
    FCameraComponentThirdOnCameraAnimDrivenStateChanged OnCameraAnimDrivenStateChanged; // 0x0810 (size: 0x10)
    void OnCameraAnimDrivenStateChanged(ECameraTransitionState _eNewState);
    class UCameraDB* m_CameraDB;                                                      // 0x0920 (size: 0x8)
    float m_fMouseYawScale;                                                           // 0x0F20 (size: 0x4)
    float m_fMousePitchScale;                                                         // 0x0F24 (size: 0x4)
    class UMaterialParameterCollection* m_MaterialParameterCollectionCameraDither;    // 0x0F28 (size: 0x8)
    FName m_CameraDistanceMPCParameterName;                                           // 0x0F30 (size: 0x8)
    float m_fDialogAspectRatio;                                                       // 0x0F38 (size: 0x4)
    float m_fDialogAspectRatioBlendDuration;                                          // 0x0F3C (size: 0x4)
    ESCBlendType m_eDialogAspectRatioBlendType;                                       // 0x0F40 (size: 0x1)
    FName m_CameraFadeMaterialParam;                                                  // 0x0F44 (size: 0x8)
    bool m_bCameraLDMode;                                                             // 0x0F64 (size: 0x1)

    void OnSequenceViewBlendChange__DelegateSignature(class USCLevelSequence* _levelSequence);
    void OnCameraAnimDrivenStateChanged__DelegateSignature(ECameraTransitionState _eNewState);
    void BPF_UpdateCachedTargets();
    void BPF_UnPauseLookAt(int32 _iHandle);
    void BPF_UnFreezeMirrorServices(int32 _iHandle);
    void BPF_UnFreezeLockService(int32 _iHandle);
    void BPF_UnFreezeHidingZoneRepulsion(int32 _iHandle);
    void BPF_UnFreezeCameraDeadZoneRepulsion(int32 _iHandle);
    FVector BPF_TransformInputVector(FVector2D _vInputVector);
    void BPF_SetSlowMotionFactor(float _fSlowMotionFactor);
    void BPF_SetMirrorCursorValue(float _fValue);
    void BPF_SetIsCameraLDMode(bool _bCameraLDMode, const class AActor* _replayCameraAnchor);
    void BPF_SetFramingAlgorithmOverrideTarget(bool _bOverride, FVector _vPosition3D, float _fDurationBlendingIn, class UCurveFloat* _dynamicCurveForBlendingIn, float _fDurationBlendingOut, class UCurveFloat* _dynamicCurveForBlendingOut);
    void BPF_SetDialogAspectRatio(bool _bInEnabled);
    void BPF_ResetLockManualCooldownToDefault();
    void BPF_ResetCameraRepulsionConfig();
    void BPF_ResetCameraDataToDefault(class UAbstractCameraData* _cameraDataToReset);
    void BPF_Reset1vNLockBehaviorToDefault();
    void BPF_Reset1v1LockBehaviorToDefault();
    void BPF_RemoveLookAt(int32 _iHandle);
    void BPF_RemoveAllLookAt();
    int32 BPF_PushRemoveDampingOnAlgorithms(FString _context);
    void BPF_PopRemoveDampingOnAlgorithms(int32 _iHandle);
    int32 BPF_PauseLookAtWithHandle(FString _contextString);
    void BPF_PauseLookAt(float _fDuration, FString _contextString);
    void BPF_OverrideLockManualCooldown(float _fNewCooldown);
    void BPF_OverrideCameraRepulsionConfig(const FCameraRepulsionConfig& _newConfig);
    void BPF_OverrideCameraData(class UAbstractCameraData* _cameraDataToOverride, class UAbstractCameraData* _newCameraDataToUse);
    void BPF_Override1vNLockBehavior(const FCameraLookAtServiceBehaviorTime& _timeConfig, const FCameraLookAtServiceBehaviorConfig& _behaviorConfig);
    void BPF_Override1v1LockBehavior(const FCameraLookAtServiceBehaviorTime& _timeConfig, const FCameraLookAtServiceBehaviorConfig& _behaviorConfig);
    void BPF_LaunchNewMirrorTarget(const FCameraMirrorManagementConfig& _newMirrorTarget);
    bool BPF_IsWorldLocationInFront(const FVector& _vLocation);
    bool BPF_IsSleepingFromManualInput();
    bool BPF_IsLookAtActive(int32 _iHandle);
    bool BPF_IsLockAlgoActiveAndRunning(ECameraLockAlgorithms _eAlgo);
    bool BPF_IsLockActiveAndRunning();
    bool BPF_IsInCinematic();
    bool BPF_IsDampingRemovedOnAlgorithm();
    bool BPF_IsCurrentCameraAllowingLookAtCollisionExtraction();
    bool BPF_IsCurrentCameraAllowingDodgeMirrorChange();
    bool BPF_IsColliding();
    bool BPF_IsAnimDrivenInMixerNode(bool _bAllowSearchInBlenderStartNode);
    bool BPF_IsAnimDriven();
    bool BPF_HasLookAt();
    void BPF_GetValidTarget(bool _bIncludeAllPotentialAlertedTarget, TArray<class AActor*>& _arrayOfTarget);
    float BPF_GetTimeSinceNoInput();
    int32 BPF_GetNumberOfValidTarget(bool _bIncludeAllPotentialAlertedTarget);
    FVector BPF_GetNearestColDirection();
    void BPF_GetMirrorFarTargettedPosition(TArray<FCameraTargetPosition>& _outTargetPosition);
    float BPF_GetMirrorCursorValue();
    float BPF_GetCurrentLookAtRatio();
    TArray<FDeadZone> BPF_GetCurrentDeadZones(EDeadZoneTypes _eDeadZoneTypes);
    ESCSequenceBlendViewState BPF_GetCurrentCinematicState();
    float BPF_GetCollisionMinDist();
    FTransform BPF_GetCameraTransform();
    float BPF_GetCameraShakeFactor();
    float BPF_GetCameraCollisionTargetRatio();
    float BPF_GetCameraCollisionRatio();
    class UBlackboardComponent* BPF_GetBlackBoardComponent();
    float BPF_GetBlackBarScreenRatio();
    void BPF_GetAngleDiffFromAnimDriven(float& _fOutYawDeg, float& _fOutPitchDeg);
    int32 BPF_FreezeMirrorServices(FString _contextString);
    int32 BPF_FreezeLockService(FString _contextString);
    int32 BPF_FreezeHidingZoneRepulsion(FString _contextString);
    int32 BPF_FreezeCameraDeadZoneRepulsion(FString _contextString);
    bool BPF_ComputeIsMirrorFromCharacterPosOnScreen();
    void BPF_AddLookAt(const FCameraLookAtServiceBehavior& _newLookAt, int32& _iHandle);
}; // Size: 0x1110

class UCameraCutNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UCameraDB : public UDataAsset
{
    class UBehaviorTree* m_BehaviorTreeAsset;                                         // 0x0030 (size: 0x8)
    class UAbstractCameraData* m_CameraDataDefault;                                   // 0x0038 (size: 0x8)
    float m_fUnlockOnPlaceCompensationTime;                                           // 0x0040 (size: 0x4)
    class UCurveFloat* m_OrientationDampingFromDistanceCurve;                         // 0x0048 (size: 0x8)
    class UCurveFloat* m_NearOrientationDampingFromDistanceCurve;                     // 0x0050 (size: 0x8)
    class UCurveFloat* m_OrientationDampingCurveRatioFromDist;                        // 0x0058 (size: 0x8)
    class UCurveFloat* m_PitchDampingFromDistanceCurve;                               // 0x0060 (size: 0x8)
    class UCurveFloat* m_PitchNearOrientationDampingFromDistanceCurve;                // 0x0068 (size: 0x8)
    class UCurveFloat* m_PitchOrientationDampingCurveRatioFromDist;                   // 0x0070 (size: 0x8)
    float m_fLockManualControlCooldownDuration;                                       // 0x0078 (size: 0x4)
    class UCurveFloat* m_weightFromDistCurve;                                         // 0x0080 (size: 0x8)
    float m_fLookAtDurationUnderneathSequence;                                        // 0x0088 (size: 0x4)
    FCameraLookAtServiceBehaviorTime m_lookAtBehaviorTimeRelated1V1;                  // 0x0090 (size: 0x20)
    FCameraLookAtServiceBehaviorConfig m_lookAtBehavior1V1;                           // 0x00B0 (size: 0xA8)
    FCameraLookAtServiceBehaviorTime m_lookAtBehaviorTimeRelated1VN;                  // 0x0158 (size: 0x20)
    FCameraLookAtServiceBehaviorConfig m_lookAtBehavior1VN;                           // 0x0178 (size: 0xA8)
    uint32 m_uiTargetableBehaviorMask;                                                // 0x0220 (size: 0x4)
    class UCurveFloat* m_LockFollowYawDampingFactorByAngleDelta;                      // 0x0228 (size: 0x8)
    class UCurveFloat* m_followingYawDampingFactorFromVelocity;                       // 0x0230 (size: 0x8)
    float m_fLockFollowingDampingInCollision;                                         // 0x0238 (size: 0x4)
    float m_fLockFollowingCollisionAngleOffset;                                       // 0x023C (size: 0x4)
    float m_fLockFollowingPitchMultiplier;                                            // 0x0240 (size: 0x4)
    float m_fLockFollowingPitchOffset;                                                // 0x0244 (size: 0x4)
    float m_fLockFollowingPitchDampingFactor;                                         // 0x0248 (size: 0x4)
    float m_fLockFollowingMaxAngleToResume;                                           // 0x024C (size: 0x4)
    float m_fLockFollowingMinDeltaCamPlayerToFreezeOrientation;                       // 0x0250 (size: 0x4)
    float m_fLockFollowingMinDeltaCamPlayerToFreezeOrientationNoInput;                // 0x0254 (size: 0x4)
    float m_fLockFollowingMinDeltaInputToUnfreezeOrientation;                         // 0x0258 (size: 0x4)
    float m_fLockFollowingRotationChangeThreshold;                                    // 0x025C (size: 0x4)
    bool m_bLockFollowingResumeIfNoInput;                                             // 0x0260 (size: 0x1)
    float m_fLockFollowingManualControlCooldownDuration;                              // 0x0264 (size: 0x4)
    float m_fLockFramingAimZOffset;                                                   // 0x0268 (size: 0x4)
    float m_fDurationAfterManualControlToGetBackToRegularPos;                         // 0x026C (size: 0x4)
    float m_fSpringSpeedFactorForCameraPosition;                                      // 0x0270 (size: 0x4)
    float m_fOffsetAngleToGetOutOfCollisionFromDeadZone;                              // 0x0274 (size: 0x4)
    uint8 m_uiCameraPoolNumber;                                                       // 0x0278 (size: 0x4)
    class UCameraTransitionInfo* m_DefaultTransition;                                 // 0x0280 (size: 0x8)
    float m_fCollisionDampingFactor;                                                  // 0x0288 (size: 0x4)
    float m_fCollisionSphereMarginFactor;                                             // 0x028C (size: 0x4)
    float m_fSoftCollisionDistanceAllowedInsideWall;                                  // 0x0290 (size: 0x4)
    float m_fCollisionDeadEndAngle;                                                   // 0x0294 (size: 0x4)
    int32 m_iDetectionRaycastCount;                                                   // 0x0298 (size: 0x4)
    float m_fCollisionDetectionDistance;                                              // 0x029C (size: 0x4)
    class UCurveFloat* m_maxRaycastDistCoeffByMinDist;                                // 0x02A0 (size: 0x8)
    float m_fRaycastStartZOffset;                                                     // 0x02A8 (size: 0x4)
    float m_fRaycastAngle;                                                            // 0x02AC (size: 0x4)
    float m_fFalsePositiveSafeZoneMaxAngle;                                           // 0x02B0 (size: 0x4)
    bool m_bUseSpringForReturningToFurtherCollision;                                  // 0x02B4 (size: 0x1)
    float m_fSpringSpeedForReturningToFurtherCollision;                               // 0x02B8 (size: 0x4)
    bool m_bEnableSafePoint;                                                          // 0x02BC (size: 0x1)
    class UCurveFloat* m_safePointRatioFromDeadZoneMinDist;                           // 0x02C0 (size: 0x8)
    float m_fSafePointDampingSpeed;                                                   // 0x02C8 (size: 0x4)
    float m_fSafePointBlendOutDuration;                                               // 0x02CC (size: 0x4)
    FCameraSafePointPlacement m_fSafePointDefaultPlacement;                           // 0x02D0 (size: 0x1C)
    TArray<FCameraSafePointConditionalPlacement> m_fSafePointConditionalPlacement;    // 0x02F0 (size: 0x10)
    FCameraRepulsionConfig m_RepulsionConfig1v1;                                      // 0x0300 (size: 0x30)
    FCameraRepulsionConfig m_RepulsionConfig1vN;                                      // 0x0330 (size: 0x30)
    float m_fRepulsionAngleDiffToBeConsideredInsideSafeZone;                          // 0x0360 (size: 0x4)
    float m_fRepulsionTargetAngleDiffMax;                                             // 0x0364 (size: 0x4)
    float m_fFulcrumOffsetDampingFactorEnabled;                                       // 0x0368 (size: 0x4)
    float m_fFulcrumOffsetDampingFactorDisabled;                                      // 0x036C (size: 0x4)
    class UCurveFloat* m_fFulcrumOffsetRatioToMaxDistByBissectorRatio;                // 0x0370 (size: 0x8)
    float m_fFulcrumOffsetDistanceRatioOutside;                                       // 0x0378 (size: 0x4)
    bool m_bFulcrumOffsetOrientateCamera;                                             // 0x037C (size: 0x1)
    float m_fFulcrumOffsetCameraOrientationBlendDuration;                             // 0x0380 (size: 0x4)
    float m_fFulcrumOffsetMaxDistance;                                                // 0x0384 (size: 0x4)
    float m_fFollowRotationChangeThreshold;                                           // 0x0388 (size: 0x4)
    class UCurveFloat* m_followingPitchMulitplierFromDeltaYaw;                        // 0x0390 (size: 0x8)
    float m_fMinDeltaCamPlayerToFreezeOrientation;                                    // 0x0398 (size: 0x4)
    float m_fMinDeltaInputToUnfreezeOrientation;                                      // 0x039C (size: 0x4)
    float m_fCooldownReturnToRestAfterLookAtWithPitch;                                // 0x03A0 (size: 0x4)
    class UCurveFloat* m_SideTraceDistRatioRemap;                                     // 0x03A8 (size: 0x8)
    class UCurveFloat* m_BothSideColRatioRemap;                                       // 0x03B0 (size: 0x8)
    float m_fSideTraceMirrorCursorAvoidRangeAroundMiddle;                             // 0x03B8 (size: 0x4)
    float m_fCollisionSideSpeedFactorGoingOpposite;                                   // 0x03BC (size: 0x4)
    float m_fCollisionSideSpeedFactorGoingOnTheSameSide;                              // 0x03C0 (size: 0x4)
    float m_fMaxTargetDistanceToBeConsideredByMirrorFar;                              // 0x03C4 (size: 0x4)
    float m_fTimeToMaintainTargetIfNotValid;                                          // 0x03C8 (size: 0x4)
    float m_fMirrorDistSideMax;                                                       // 0x03CC (size: 0x4)
    float m_fMirrorFarExtraDistanceInPushedState;                                     // 0x03D0 (size: 0x4)
    float m_fMirrorFarExtraDistanceInDownState;                                       // 0x03D4 (size: 0x4)
    float m_fMeleeAngleToUseCamForwardDirToTargetToChangeMirror;                      // 0x03D8 (size: 0x4)
    class UCurveFloat* m_AnimDrivenRotationWeightByMixerWeight;                       // 0x03E0 (size: 0x8)
    class UCurveFloat* m_AnimDrivenWeightForCollisionDistance;                        // 0x03E8 (size: 0x8)
    class UCurveFloat* m_AnimDrivenWeightFactorForAnimRatio;                          // 0x03F0 (size: 0x8)
    class UCurveFloat* m_AnimDrivenWeightByAngularDistance;                           // 0x03F8 (size: 0x8)
    float m_fAnimDrivenWeightRepartitionBetweenCollisionAndAngularDist;               // 0x0400 (size: 0x4)
    class UCurveFloat* m_AnimDrivenWeightByDistance;                                  // 0x0408 (size: 0x8)
    float m_fAnimDrivenWeightRepartitionBetweenCollisionAndDist;                      // 0x0410 (size: 0x4)
    TArray<class TSubclassOf<UAnimNotify>> m_ListOfPotentialNotifyClassesToStopCameraAnimDriven; // 0x0418 (size: 0x10)
    TEnumAsByte<ECollisionChannel> m_eAnimDrivenRootCheckCollisionChannel;            // 0x0428 (size: 0x1)
    FSCCollisionResponseBuilder m_AnimDrivenRootCheckCollisionResponseBuilder;        // 0x0430 (size: 0x18)
    FCollisionResponseContainer m_CameraAnimDrivenRootCheckCollisionResponseParam;    // 0x0448 (size: 0x20)

}; // Size: 0x468

class UCameraData : public UAbstractCameraData
{
    FCameraNodeStruct m_CameraNodeStruct;                                             // 0x0060 (size: 0x1C0)
    class UCameraData* m_ParentCamera;                                                // 0x0220 (size: 0x8)

}; // Size: 0x230

class UCameraDataModifier : public UObject
{

    void BPE_ReceiveOnStop(class UCameraComponentThird* _cameraComponent);
    void BPE_ReceiveOnStart(class UCameraComponentThird* _cameraComponent);
    void BPE_ReceiveOnProcess(class UCameraComponentThird* _cameraComponent, float _fDt);
}; // Size: 0x28

class UCameraLagStruct : public UDataAsset
{
    bool m_bEnableInputLag;                                                           // 0x0030 (size: 0x1)
    float m_fInputLagGlobalMultiplier;                                                // 0x0034 (size: 0x4)
    float m_fInputLagGlobalMultiplierMax;                                             // 0x0038 (size: 0x4)
    float m_fInputLagGlobalMultiplierMin;                                             // 0x003C (size: 0x4)
    float m_fInputLagMouseMultiplier;                                                 // 0x0040 (size: 0x4)
    FVector2D m_vInputLagProportionnalIncrementFadeIn;                                // 0x0044 (size: 0x8)
    FVector2D m_vInputLagConstantIncrementFadeIn;                                     // 0x004C (size: 0x8)
    FVector2D m_vInputLagProportionnalIncrementFadeOut;                               // 0x0054 (size: 0x8)
    FVector2D m_vInputLagConstantIncrementFadeOut;                                    // 0x005C (size: 0x8)

}; // Size: 0x68

class UCameraMixerBlender : public UObject
{

    float BPE_EvaluateBlendRatio(class UCameraComponentThird* _camera, float _fDt, float _fOldRatio, bool _bNoDamping);
}; // Size: 0x30

class UCameraMixerData : public UAbstractCameraData
{
    class UAbstractCameraData* m_StartCamera;                                         // 0x0060 (size: 0x8)
    class UAbstractCameraData* m_EndCamera;                                           // 0x0068 (size: 0x8)
    TSubclassOf<class UCameraMixerBlender> m_BlenderClass;                            // 0x0070 (size: 0x8)
    bool m_bUseEndCamForTransition;                                                   // 0x0078 (size: 0x1)

    void ImportTransitionsFromStartCam();
    void ImportTransitionsFromEndCam();
}; // Size: 0x80

class UCameraTransitionEvent : public UObject
{

    void ReceiveLaunchEvent(class UCameraComponentThird* _cameraComponent, float _fTimeElapsed, float _fBlendRatio);
}; // Size: 0x28

class UCameraTransitionInfo : public UDataAsset
{
    float m_fDuration;                                                                // 0x0030 (size: 0x4)
    class UCurveFloat* m_Curve;                                                       // 0x0038 (size: 0x8)
    class UCurveFloat* m_CurveForAngle;                                               // 0x0040 (size: 0x8)
    bool m_bFreezeUnderneathTransition;                                               // 0x0048 (size: 0x1)
    bool m_bWantUseAngleFromStartNode;                                                // 0x0049 (size: 0x1)
    EUpdateAngleMode m_eUpdateAngleMode;                                              // 0x004A (size: 0x1)
    TArray<class TSubclassOf<UCameraTransitionModule>> m_Modules;                     // 0x0050 (size: 0x10)
    TArray<FCameraTransitionEventStruct> m_events;                                    // 0x0060 (size: 0x10)

}; // Size: 0x70

class UCameraTransitionModule : public UObject
{

    void ReceiveOnStop(class UCameraComponentThird* _cameraComponent, float _fTimeElapsed);
    void ReceiveOnStart(class UCameraComponentThird* _cameraComponent, float _fDuration);
    void ReceiveOnProcess(class UCameraComponentThird* _cameraComponent, float _fTimeElapsed, float _fOldBlendRatio, float _fNewBlendRatio);
}; // Size: 0x28

class UCameraWeightComponent : public UActorComponent
{

    float BPE_GetWeight();
}; // Size: 0xC0

class UCameraZoneBlueprintHelper : public UBlueprintFunctionLibrary
{

    void BPF_GetSafeZoneListFromDeadZones(TArray<FDeadZone>& _outListOfSafeZones, const TArray<FDeadZone>& _inDeadZones);
    float BPF_GetMidAngle(const FDeadZone& _inDeadZone);
    bool BPF_GetDeadZoneContainingAngle(FDeadZone& _outDeadZone, const TArray<FDeadZone>& _inDeadZones, float _fAngleInDeg);
    bool BPF_GetClosestDeadZoneToAngle(FDeadZone& _outDeadZone, const TArray<FDeadZone>& _inDeadZones, float _fAngleInDeg, float _fAngleDiffMaxInDeg);
}; // Size: 0x28

class UCancelDB : public UDataAsset
{
    float m_fCancelReorientationDuration;                                             // 0x0030 (size: 0x4)
    class UCurveFloat* m_CancelReorientationCurve;                                    // 0x0038 (size: 0x8)
    class UCurveFloat* m_CancelDisplacementCurve;                                     // 0x0040 (size: 0x8)
    FCancelAnimContainerQuadrantArray m_AnimContainerArray;                           // 0x0048 (size: 0x60)
    float m_fCancelDuration;                                                          // 0x00A8 (size: 0x4)
    float m_fCancelGuardGaugeCost;                                                    // 0x00AC (size: 0x4)
    bool m_bCancelHasImpactOnGuardGauge;                                              // 0x00B0 (size: 0x1)
    float m_fCancelWindowDuration;                                                    // 0x00B4 (size: 0x4)
    class UAvailabilityLayerData* m_CancelInterruptibleReleaseLayer;                  // 0x00B8 (size: 0x8)
    int32 m_iFrameInterruptibleRelease;                                               // 0x00C0 (size: 0x4)

}; // Size: 0xC8

class UCapsuleHitDetectionDB : public UBaseShapeHitDetectionDB
{
    float m_fRadius;                                                                  // 0x0070 (size: 0x4)
    float m_fHalfHeight;                                                              // 0x0074 (size: 0x4)

}; // Size: 0x78

class UCaptureInputAction : public UBlueprintAsyncActionBase
{
    FCaptureInputActionOnSuccess OnSuccess;                                           // 0x0030 (size: 0x10)
    void CaptureDelegate(const FInputMappingData& _result, ECaptureInputStep _NewStep);
    FCaptureInputActionOnUpdate OnUpdate;                                             // 0x0040 (size: 0x10)
    void CaptureDelegate(const FInputMappingData& _result, ECaptureInputStep _NewStep);
    FCaptureInputActionOnStepStarted OnStepStarted;                                   // 0x0050 (size: 0x10)
    void CaptureDelegate(const FInputMappingData& _result, ECaptureInputStep _NewStep);
    FCaptureInputActionOnCancel OnCancel;                                             // 0x0060 (size: 0x10)
    void DynamicMulticast();
    class UInputMappingWidgetData* m_Data;                                            // 0x0108 (size: 0x8)

    void CaptureDelegate__DelegateSignature(const FInputMappingData& _result, ECaptureInputStep _NewStep);
    class UCaptureInputAction* BPF_CaptureInput(const class UInputMappingWidgetData* _data, const FMappingID& _item, FInputMappingData _baseInputData, int32 _iSlodID, bool _bCaptureAxis, float _fMouseAxisThreshold, int32 _iControllerTypes, bool _bBreakDependency, bool _bInverseMouseVerticalAxis);
}; // Size: 0x168

class UCarriedWeaponCondition : public UBaseActorCondition
{
    bool m_bInvertCondition;                                                          // 0x0028 (size: 0x1)
    TArray<class TSubclassOf<UBaseWeaponData>> m_WeaponList;                          // 0x0030 (size: 0x10)

}; // Size: 0x40

class UChangeCollisionNotify : public USCAnimNotify
{
    bool m_bEnableCollisions;                                                         // 0x0048 (size: 0x1)

}; // Size: 0x50

class UChangeMainFoot_Notify : public USCAnimNotify
{
}; // Size: 0x48

class UChangePhaseBTTask : public UBTTaskNode
{
}; // Size: 0x78

class UChangeWeaponBearer_Notify : public USCAnimNotify
{
    FName m_sBoneToAttachWeaponTo;                                                    // 0x0048 (size: 0x8)
    EWeaponOrientationConstraint m_eWeaponConstraint;                                 // 0x0050 (size: 0x1)
    bool m_bKeepAttachedOnImpostor;                                                   // 0x0051 (size: 0x1)
    FName m_sBoneToAttachWeaponToOnImpostor;                                          // 0x0054 (size: 0x8)

}; // Size: 0x60

class UCharacterBuildDB : public UDataAsset
{
    ECharacterGender m_eGender;                                                       // 0x0030 (size: 0x1)
    FCharacterStatsValues m_DefaultStats;                                             // 0x0038 (size: 0x50)
    FCharacterStatsValues m_DefaultStatsPerDifficulty;                                // 0x0088 (size: 0xF0)

}; // Size: 0x178

class UCharacterBuildListDB : public UDataAsset
{
    TArray<class UCharacterBuildDB*> m_CharacterBuilds;                               // 0x0030 (size: 0x10)

}; // Size: 0x40

class UCharacterContextualObjectCondition : public UBaseActorCondition
{
    bool m_bHasContextualObjectInRange;                                               // 0x0028 (size: 0x1)
    FBaseActorTargetConditionInstance m_ConditionOnObject;                            // 0x0030 (size: 0x10)
    TSubclassOf<class UInteractionObjectComponent> m_CheckType;                       // 0x0040 (size: 0x8)

}; // Size: 0x48

class UCharacterHealthComponent : public UHealthComponent
{
    bool m_bCanRecoverHealth;                                                         // 0x0150 (size: 0x1)
    FCharacterHealthComponentOnGhostDamageLost OnGhostDamageLost;                     // 0x0158 (size: 0x10)
    void GhostDamageLost();
    FCharacterHealthComponentOnDownStateChange OnDownStateChange;                     // 0x0168 (size: 0x10)
    void OnDownStateChanged(class UCharacterHealthComponent* _healhComponent, EDownState _state);
    float m_fMaxHealthMultiplier;                                                     // 0x0178 (size: 0xC)
    float m_fRecoveryRate;                                                            // 0x0184 (size: 0x4)
    float m_fRecoveryCooldownInit;                                                    // 0x0188 (size: 0x4)
    float m_fGhostDamageRecoveryRate;                                                 // 0x0194 (size: 0x4)
    float m_fGhostDamage;                                                             // 0x0198 (size: 0x4)
    bool m_bIsDown;                                                                   // 0x019C (size: 0x1)
    EDownState m_eDownState;                                                          // 0x019D (size: 0x1)
    int64 m_iTimeRespawnNoDown;                                                       // 0x01A0 (size: 0x8)
    bool m_bCanUnspawnCharacter;                                                      // 0x01A8 (size: 0x1)
    float m_RecoveryRateByDangerState;                                                // 0x01C0 (size: 0xC)

    void OnRepSetIsDown();
    void OnDownStateChanged__DelegateSignature(class UCharacterHealthComponent* _healhComponent, EDownState _state);
    void GhostDamageLost__DelegateSignature();
    void BPF_ResetRecoveryCooldownFromValue(const float _fNewCooldownValue);
    void BPF_ResetRecoveryCooldown();
    float BPF_GetGhostDamage();
}; // Size: 0x1E0

class UCharacterHitBoxComponent : public UHitBoxComponent
{
}; // Size: 0x610

class UCharacterProgressionDB : public UDataAsset
{
    FCharacterProgressionReward m_Rewards;                                            // 0x0030 (size: 0xC0)
    TArray<ECharacterProgressionRewardTypes> m_FightingStyleProgression;              // 0x00F0 (size: 0x10)
    FProgressionRewardArray m_AttackSlotProgression;                                  // 0x0100 (size: 0x40)
    TArray<float> m_SpecialAbilityXPOnSuccess;                                        // 0x0140 (size: 0x10)
    TArray<FProgressionDoorStruct> m_ProgressionDoors;                                // 0x0150 (size: 0x10)
    int32 m_uiAttackXPOnTargetted;                                                    // 0x0160 (size: 0x4)
    int32 m_uiAttackXPOnHit;                                                          // 0x0164 (size: 0x4)
    int32 m_uiAttackXPOnGuard;                                                        // 0x0168 (size: 0x4)
    int32 m_uiAttackXPOnDodge;                                                        // 0x016C (size: 0x4)
    int32 m_uiAttackXPOnParry;                                                        // 0x0170 (size: 0x4)
    int32 m_uiAttackXPOnAvoid;                                                        // 0x0174 (size: 0x4)
    int32 m_uiAttackXPOnAbsorb;                                                       // 0x0178 (size: 0x4)
    int32 m_uiOffenseAttackXPOnHit;                                                   // 0x017C (size: 0x4)
    int32 m_uiOffenseAttackXPOnGuarded;                                               // 0x0180 (size: 0x4)
    int32 m_uiOffenseAttackXPOnPerfectLink;                                           // 0x0184 (size: 0x4)
    int32 m_uiOffenseAttackXPOnAbsorb;                                                // 0x0188 (size: 0x4)
    int32 m_uiOffenseAttackXPOnGuardBreak;                                            // 0x018C (size: 0x4)
    int32 m_iCairnsToOpen;                                                            // 0x0190 (size: 0x4)
    TArray<FRetrieveLostItemStruct> m_RetrieveLostItems;                              // 0x0198 (size: 0x10)

    ECharacterProgressionRewardTypes BPF_GetProgressionRewardForSchoolLevel(int32 _iSchoolLevel);
    FCharacterProgressionReward BPF_GetProgressionReward(ECharacterProgressionRewardTypes _type);
    FProgressionDoorStruct BPF_GetProgressionDoorStructByQuestItem(class UQuestItemData* _questItemData);
    FProgressionDoorStruct BPF_GetProgressionDoorStructByDoorData(class UProgressionDoorData* _progressionDoorData);
    void BPF_GetNextProgressionRewards(ECharacterProgressionRewardConditions _condition, const int32& _iValue, TArray<FCharacterProgressionReward>& _result);
}; // Size: 0x1C0

class UCharacterProgressionUnlockDB : public UDataAsset
{
}; // Size: 0x30

class UCharacterProgressionUnlockPowerDB : public UCharacterProgressionUnlockDB
{
    int32 m_iCharacterBuildPowerIndex;                                                // 0x0030 (size: 0x4)
    FText m_NotificationText;                                                         // 0x0038 (size: 0x18)

}; // Size: 0x50

class UCharacterStatAttributeSet : public USCAttributeSet
{
    FGameplayAttributeData MaxHealth;                                                 // 0x0050 (size: 0x10)
    FGameplayAttributeData MaxStructure;                                              // 0x0060 (size: 0x10)
    FGameplayAttributeData FocusPoints;                                               // 0x0070 (size: 0x10)
    FGameplayAttributeData SkillPoints;                                               // 0x0080 (size: 0x10)
    FGameplayAttributeData Level;                                                     // 0x0090 (size: 0x10)
    FGameplayAttributeData Experience;                                                // 0x00A0 (size: 0x10)
    FGameplayAttributeData Age;                                                       // 0x00B0 (size: 0x10)
    FGameplayAttributeData DeathCounter;                                              // 0x00C0 (size: 0x10)
    FGameplayAttributeData PendantCharges;                                            // 0x00D0 (size: 0x10)
    FGameplayAttributeData PendantChargesRefill;                                      // 0x00E0 (size: 0x10)
    FGameplayAttributeData PendantChargesLimit;                                       // 0x00F0 (size: 0x10)
    FGameplayAttributeData XPMultiplier;                                              // 0x0100 (size: 0x10)
    FGameplayAttributeData DemoTrials;                                                // 0x0110 (size: 0x10)
    FGameplayAttributeData CurrentComboKills;                                         // 0x0120 (size: 0x10)
    FGameplayAttributeData MaxComboKills;                                             // 0x0130 (size: 0x10)
    FGameplayAttributeData CurrentComboXp;                                            // 0x0140 (size: 0x10)
    FGameplayAttributeData MaxComboXp;                                                // 0x0150 (size: 0x10)
    FGameplayAttributeData Score;                                                     // 0x0160 (size: 0x10)
    FGameplayAttributeData DeathCounterMax;                                           // 0x0170 (size: 0x10)
    FGameplayAttributeData GameDifficulty;                                            // 0x0180 (size: 0x10)
    FGameplayAttributeData CheatsUnlockPoints;                                        // 0x0190 (size: 0x10)

    void OnRep_DeathCounter();
    void OnRep_Age();
}; // Size: 0x1A0

class UCharacterStatsWidget : public USCUserWidget
{
    FString m_CharacterName;                                                          // 0x0310 (size: 0x10)
    FString m_CharacterClass;                                                         // 0x0320 (size: 0x10)
    FCombatDeckDetails m_CurrentWeaponCombatDeckDetails;                              // 0x0330 (size: 0x718)
    FCombatDeckDetails m_PreviewWeaponCombatDeckDetails;                              // 0x0A48 (size: 0x718)
    FCombatDeckDetails m_CurrentHandCombatDeckDetails;                                // 0x1160 (size: 0x718)
    FCombatDeckDetails m_PreviewHandCombatDeckDetails;                                // 0x1878 (size: 0x718)
    FCharacterStatsBindings m_CurrentCharacterStats;                                  // 0x1F90 (size: 0x300)

    void BPF_UpdateStats();
}; // Size: 0x2290

class UCharacterTextLipSync : public UTextLipSync
{

    void BPF_Speak(const FLipSync_TimedData& _phrase, const TArray<FLipSyncPhonemeInPhrase>& _phonemes, const TArray<FLipSyncEmotionData>& _emotions, class UAkAudioEvent* _audioEvent, TMap<float, float> _enveloppeValueByTime, bool _bUseImprovedTextToPhoneme);
}; // Size: 0x4F0

class UCheckTargetPerceptionDecorator : public USCBTDecorator
{
    FBlackboardKeySelector m_TargetKey;                                               // 0x0070 (size: 0x28)
    TArray<class TSubclassOf<UAISense>> m_Senses;                                     // 0x0098 (size: 0x10)

}; // Size: 0xA8

class UCheckTargetStateOrderService : public UOrderService
{
    bool m_bCheckOrder;                                                               // 0x0028 (size: 0x1)
    TArray<FEditableOrderType> m_StopOnInterruptedOnlyByOrders;                       // 0x0030 (size: 0x10)
    EOrderType m_eExpectedTargetCurrentOrder;                                         // 0x0040 (size: 0x1)
    FSCUserDefinedEnumHandler m_EpectedTargetCurrentBPOrder;                          // 0x0048 (size: 0x50)
    bool m_bCheckSnap;                                                                // 0x0098 (size: 0x1)
    EControllerNature m_eCheckSnapOnControllerNature;                                 // 0x0099 (size: 0x1)
    float m_fMaxDistFromSnap;                                                         // 0x009C (size: 0x4)
    bool m_bCheckState;                                                               // 0x00A0 (size: 0x1)
    bool m_bCheckDeath;                                                               // 0x00A1 (size: 0x1)
    bool m_bInverseStateCheck;                                                        // 0x00A2 (size: 0x1)
    EFightingActionState m_eExpectedState;                                            // 0x00A3 (size: 0x1)
    EInterruptionBehavior m_eInterruptionBehaviour;                                   // 0x00A4 (size: 0x4)
    bool m_bSwapAtCurrentTime;                                                        // 0x00A8 (size: 0x1)
    TArray<EFightingState> m_RecoveredFightingStates;                                 // 0x00B0 (size: 0x10)
    FAnimContainer m_SwapAnimation;                                                   // 0x00C0 (size: 0x18)
    FAnimContainer m_CustomFightingStateRecoveryAnim;                                 // 0x00D8 (size: 0x18)
    FHitBox m_Hit;                                                                    // 0x00F0 (size: 0x298)

}; // Size: 0x388

class UCinematicManager : public UObject
{
    float m_fFadeDuration;                                                            // 0x0064 (size: 0x4)

    void MovieStopped();
}; // Size: 0x68

class UCollisionNotifyState : public USCAnimNotifyState
{
    FString m_alName;                                                                 // 0x0048 (size: 0x10)
    bool m_bDisableCollisions;                                                        // 0x0058 (size: 0x1)

}; // Size: 0x60

class UColorComparisonProfile : public UDataAsset
{
    FSlateColor m_BonusTint;                                                          // 0x0030 (size: 0x28)
    FSlateColor m_MalusTint;                                                          // 0x0058 (size: 0x28)

}; // Size: 0x80

class UCombatPositionSettings : public UBaseCombatPositionSettings
{
    float m_fPositionEliminationAngle;                                                // 0x0088 (size: 0x4)

}; // Size: 0x90

class UCombinationInputData : public UGenericInputData
{
    bool m_bResetChildHoldToggleOnActivation;                                         // 0x00C0 (size: 0x1)
    TArray<FCombinationInput> m_IncludedInputs;                                       // 0x00C8 (size: 0x10)
    TArray<FCombinationInput> m_ExcludedInputs;                                       // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class UCombo : public UObject
{
    FSCUserDefinedEnumHandler m_DefaultStartState;                                    // 0x0028 (size: 0x50)
    TArray<FComboNode> m_Nodes;                                                       // 0x0078 (size: 0x10)
    TMap<class FName, class UAttackDB*> m_Attacks;                                    // 0x0088 (size: 0x50)
    TArray<FComboStartNode> m_ComboStartNodesContainer;                               // 0x00D8 (size: 0x10)
    FSCUserDefinedEnumHandler m_StartStatesEnum;                                      // 0x00E8 (size: 0x50)
    int32 m_DefaultAttacks;                                                           // 0x0138 (size: 0x54)

    FComboNode BPF_GetNode(int32 _ID);
}; // Size: 0x1E0

class UComboAIConditionCanPerformAction : public UAIComboCondition
{
    TSubclassOf<class USCAiAction> m_Action;                                          // 0x00E0 (size: 0x8)

}; // Size: 0xE8

class UComboAIConditionEnemyDistance : public UAIComboCondition
{
    FSCMathExpressionFloat m_condition;                                               // 0x00E0 (size: 0x20)

}; // Size: 0x100

class UComboAIConditionFindActorEnvQuery : public UComboAIConditionFindActorsEnvQuery
{
    FName m_StoreResultInBlackBoardKey;                                               // 0x0110 (size: 0x8)
    FName m_StoreResultInBlackBoardKeyVector;                                         // 0x0118 (size: 0x8)

}; // Size: 0x120

class UComboAIConditionFindActorsEnvQuery : public UAIComboCondition
{
    FComboAIConditionFindActorsEnvQueryOnEnvQueryFinished OnEnvQueryFinished;         // 0x00E0 (size: 0x10)
    void FindActorsEnvQueryDelegate(const TArray<FComboAIConditionFindActorsEnvQueryResult>& _result);
    class UEnvQuery* m_QueryTemplate;                                                 // 0x00F0 (size: 0x8)
    float m_fQueryResultLifetime;                                                     // 0x00F8 (size: 0x4)
    bool m_bResetResultsOnFailure;                                                    // 0x00FC (size: 0x1)
    TArray<FAIDynamicParam> m_QueryParameters;                                        // 0x0100 (size: 0x10)

    void FindActorsEnvQueryDelegate__DelegateSignature(const TArray<FComboAIConditionFindActorsEnvQueryResult>& _result);
    void BPE_FillQueryParameters(TArray<FAIDynamicParam>& _outParams);
}; // Size: 0x110

class UComboAIConditionFindProxyNearPlayer : public UAIComboCondition
{
    float m_fMinimumDistance;                                                         // 0x00E0 (size: 0x4)

}; // Size: 0xE8

class UComboAIConditionGameDifficulty : public UAIComboCondition
{
    uint32 m_uiGameDifficultyFlags;                                                   // 0x00E0 (size: 0x4)

}; // Size: 0xE8

class UComboAIConditionGroup : public UAIComboCondition
{
    EComboAIConditionGroupOperator m_eOperator;                                       // 0x00E0 (size: 0x1)
    bool m_bForceTestAllConditions;                                                   // 0x00E1 (size: 0x1)
    TArray<FAIConditionClassInstance> m_Conditions;                                   // 0x00E8 (size: 0x10)

}; // Size: 0xF8

class UComboAIConditionHasAttackTicket : public UAIComboCondition
{
    bool m_bInvert;                                                                   // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UComboAIConditionIsAttacking : public UAIComboCondition
{
    bool m_bInvert;                                                                   // 0x00E0 (size: 0x1)
    class UAttackDB* m_AttackToTest;                                                  // 0x00E8 (size: 0x8)

}; // Size: 0xF0

class UComboAIConditionIsCharacterOnScreen : public UAIComboCondition
{
    float m_fMinTimeOnScreen;                                                         // 0x00E0 (size: 0x4)

}; // Size: 0xE8

class UComboAIConditionIsCombatRole : public UAIComboCondition
{
    int32 m_eCombatRolesMask;                                                         // 0x00E0 (size: 0x4)

}; // Size: 0xE8

class UComboAIConditionIsFrozenBySanctuary : public UAIComboCondition
{
    bool m_bInvert;                                                                   // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UComboAIConditionIsInLastManPhaseScenario : public UAIComboCondition
{
}; // Size: 0xE0

class UComboAIConditionIsInPhaseScenario : public UAIComboCondition
{
    TArray<FAIPhaseNodeSoftLink> m_PhasesToTest;                                      // 0x00E0 (size: 0x10)
    TArray<FAIPhaseNodeSoftLinkByMCDomination> m_Phases;                              // 0x00F0 (size: 0x10)

}; // Size: 0x100

class UComboAIConditionIsInputActionAvailable : public UAIComboCondition
{
    InputAction m_eInput;                                                             // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UComboAIConditionIsTargetCarryingWeapon : public UAIComboCondition
{
}; // Size: 0xE0

class UComboAIConditionIsTargetFightingState : public UComboAIConditionOnState
{
    EComboAIConditionOnState m_eDesiredState;                                         // 0x00F0 (size: 0x1)
    EFightingState m_eFightingState;                                                  // 0x00F1 (size: 0x1)
    bool m_bOnlyHighestFightingState;                                                 // 0x00F2 (size: 0x1)
    bool m_bUseStateDuration;                                                         // 0x00F3 (size: 0x1)
    float m_fStateValidDuration;                                                      // 0x00F4 (size: 0x4)

}; // Size: 0xF8

class UComboAIConditionIsTargetOrderState : public UComboAIConditionOnState
{
    EAITargetOrderState m_eDesiredState;                                              // 0x00F0 (size: 0x1)
    EOrderType m_eOrder;                                                              // 0x00F1 (size: 0x1)
    bool m_bUseOrderDuration;                                                         // 0x00F2 (size: 0x1)
    float m_fStateValidDuration;                                                      // 0x00F4 (size: 0x4)

}; // Size: 0xF8

class UComboAIConditionMCDomination : public UAIComboCondition
{
    uint32 m_uiMCDominationFlags;                                                     // 0x00E0 (size: 0x4)
    int32 m_iSerializeVersion;                                                        // 0x00E4 (size: 0x4)

}; // Size: 0xE8

class UComboAIConditionNoAttackPosition : public UAIComboCondition
{
}; // Size: 0xE0

class UComboAIConditionOnState : public UAIComboCondition
{
    FFloatRange m_RandomDelay;                                                        // 0x00E0 (size: 0x10)

}; // Size: 0xF0

class UComboAIConditionRequestPassiveAttackTicket : public UAIComboCondition
{
    FSCAITicketEnum m_TicketNameEnumValue;                                            // 0x00E0 (size: 0x50)
    bool m_bReleaseTicketInstantly;                                                   // 0x0130 (size: 0x1)

}; // Size: 0x138

class UComboAIConditionTimedTargetDistance : public UAIComboCondition
{
    FSCMathExpressionFloat m_condition;                                               // 0x00E0 (size: 0x20)
    float m_fValidationTime;                                                          // 0x0100 (size: 0x4)

}; // Size: 0x108

class UComboAIConditionTraceCollision : public UAIComboCondition
{
    bool m_bShouldHit;                                                                // 0x00E0 (size: 0x1)
    EAIConditionTraceContext m_eFrom;                                                 // 0x00E1 (size: 0x1)
    EAIConditionTraceContext m_eTo;                                                   // 0x00E2 (size: 0x1)
    FAIConditionTraceOffset m_FromOffset;                                             // 0x00E4 (size: 0x10)
    FAIConditionTraceOffset m_ToOffset;                                               // 0x00F4 (size: 0x10)
    TEnumAsByte<ECollisionChannel> m_TraceChannel;                                    // 0x0104 (size: 0x1)
    FCollisionResponseContainer m_TraceCollision;                                     // 0x0105 (size: 0x20)
    TEnumAsByte<EEnvTraceShape::Type> m_eShape;                                       // 0x0125 (size: 0x1)
    FVector m_vShapeExtents;                                                          // 0x0128 (size: 0xC)
    EAIConditionTraceRotationContext m_ShapeRotationRelativeTo;                       // 0x0134 (size: 0x1)

    bool BPF_TestEQCondition(const class UAIFightingComponent* _aiComponent, const class AActor* _target);
}; // Size: 0x138

class UComboEvent : public UObject
{

    FString BPE_GetLog();
    void BPE_Execute(class AFightingCharacter* _character);
}; // Size: 0x28

class UComboEventAIGotoPhase : public UComboEvent
{
    FAIPhaseNodeSoftLink m_Link;                                                      // 0x0028 (size: 0x40)
    TArray<FSCAITicketEnum> m_ResetTickets;                                           // 0x0068 (size: 0x10)

}; // Size: 0x78

class UComboManager : public UObject
{
    FComboManager_OnEnded m_OnEnded;                                                  // 0x0028 (size: 0x10)
    void ComboEndedDelegate();
    class UCombo* m_Combo;                                                            // 0x0058 (size: 0x8)

}; // Size: 0x150

class UComboStartStateOrderService : public UOrderService
{
    FName m_ComboStartName;                                                           // 0x0028 (size: 0x8)
    FName m_ComboStartPostOrderName;                                                  // 0x0030 (size: 0x8)

}; // Size: 0x38

class UComboTransitionCondition : public UObject
{
    TMap<uint8, UComboTransitionCondition*> m_TargetConditions;                       // 0x0028 (size: 0x50)
    TMap<class FGuid, class FComboConditionValueToNodeMap> m_PerConditionValueToNodeMap; // 0x0078 (size: 0x50)
    FGuid m_ConditionID;                                                              // 0x00C8 (size: 0x10)

    bool BPF_TestConditionOfClass(TSubclassOf<class UComboTransitionCondition> _condition, const class AFightingCharacter* _owner);
    bool BPF_TestCondition(const class UComboTransitionCondition* _condition, const class AFightingCharacter* _owner);
    uint8 BPE_GetTargetNode(const class AFightingCharacter* _owner, const class AActor* _target);
    FString BPE_GetLog();
}; // Size: 0xD8

class UComboTransitionConditionAIAttackMemory : public UAIComboCondition
{
    FGameplayTagContainer m_AttackProperties;                                         // 0x00E0 (size: 0x20)
    bool m_bTestThrowAttack;                                                          // 0x0100 (size: 0x1)
    TSoftClassPtr<AThrowableActor> m_ThrowableClassToTest;                            // 0x0108 (size: 0x28)
    EAIMemoryAttackType m_eAttackOrigin;                                              // 0x0130 (size: 0x1)
    float m_fMemoryLimit;                                                             // 0x0134 (size: 0x4)
    uint8 m_uiHitsCount;                                                              // 0x0138 (size: 0x1)
    bool m_bSuccessive;                                                               // 0x0139 (size: 0x1)
    bool m_bWhiff;                                                                    // 0x013A (size: 0x1)
    uint8 m_HitTypes;                                                                 // 0x013B (size: 0x1)
    bool m_bDodged;                                                                   // 0x013C (size: 0x1)
    bool m_bAvoided;                                                                  // 0x013D (size: 0x1)

}; // Size: 0x140

class UComboTransitionConditionAICheckObstacles : public UComboTransitionCondition
{
}; // Size: 0xD8

class UComboTransitionConditionAILastAttackGuardType : public UComboTransitionCondition
{
    uint8 m_uiGuardType;                                                              // 0x00D8 (size: 0x1)
    bool m_bDodged;                                                                   // 0x00D9 (size: 0x1)
    bool m_bAvoided;                                                                  // 0x00DA (size: 0x1)

}; // Size: 0xE0

class UComboTransitionConditionAINavMesh : public UComboTransitionConditionAICheckObstacles
{
    TArray<FNavMeshFreeRange> m_FreeRanges;                                           // 0x00D8 (size: 0x10)
    TArray<FNavMeshFreeSquare> m_FreeSquares;                                         // 0x00E8 (size: 0x10)

}; // Size: 0xF8

class UComboTransitionConditionActionState : public UComboTransitionCondition
{
    EFightingActionState m_ActionState;                                               // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UComboTransitionConditionGeneric : public UComboTransitionCondition
{
    FBaseActorTargetConditionInstance m_condition;                                    // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class UComboTransitionConditionLastAttackDeflected : public UComboTransitionConditionAILastAttackGuardType
{
}; // Size: 0xE0

class UComboTransitionConditionLastAttackGuarded : public UComboTransitionConditionAILastAttackGuardType
{
}; // Size: 0xE0

class UComboTransitionConditionLastAttackHit : public UComboTransitionConditionAILastAttackGuardType
{
}; // Size: 0xE0

class UComboTransitionConditionLastAttackWhiff : public UComboTransitionConditionAILastAttackGuardType
{
}; // Size: 0xE0

class UComboTransitionConditionRandom : public UComboTransitionCondition
{
    float m_fTrueProbability;                                                         // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UComboTransitionConditionTargetDistance : public UComboTransitionCondition
{
    FSCMathExpressionFloat m_condition;                                               // 0x00D8 (size: 0x20)

}; // Size: 0xF8

class UComboTransitionHelper : public UBlueprintFunctionLibrary
{

    EComboTransition BPF_GetTransitionFromInput(InputAction _eInput);
    InputAction BPF_GetInputFromTransition(EComboTransition _eTransition);
}; // Size: 0x28

class UComboWidgetData : public UDataAsset
{
    FSlateColor m_RegularAttackNormalTint;                                            // 0x0030 (size: 0x28)
    FSlateColor m_RegularAttackNextTint;                                              // 0x0058 (size: 0x28)
    FSlateColor m_RegularAttackInactiveTint;                                          // 0x0080 (size: 0x28)
    FSlateColor m_RegularAttackCurrentTint;                                           // 0x00A8 (size: 0x28)
    FSlateColor m_AlternativeAttackNormalTint;                                        // 0x00D0 (size: 0x28)
    FSlateColor m_AlternativeAttackNextTint;                                          // 0x00F8 (size: 0x28)
    FSlateColor m_AlternativeAttackFinishedTint;                                      // 0x0120 (size: 0x28)
    FSlateColor m_BlackEnlighted;                                                     // 0x0148 (size: 0x28)
    FSlateColor m_BlackDarkened;                                                      // 0x0170 (size: 0x28)
    FSlateColor m_WhiteEnlighted;                                                     // 0x0198 (size: 0x28)
    FSlateColor m_WhiteDarkened;                                                      // 0x01C0 (size: 0x28)
    FSlateColor m_ErrorTint;                                                          // 0x01E8 (size: 0x28)
    class USpecialAttackData* m_SpecialAttackData;                                    // 0x0210 (size: 0x8)

}; // Size: 0x218

class UConditionTargetWeightEvaluation : public UBaseTargetWeightEvaluation
{
    EWeightBinaryOperator m_eOperator;                                                // 0x0028 (size: 0x1)
    TArray<FConditionOnTargetWeightEvaluation> m_BonusPerCondition;                   // 0x0030 (size: 0x10)

    FString GetEditorDesc(const FConditionOnTargetWeightEvaluation& _eval);
}; // Size: 0x40

class UConfrontationDialogAction : public UDialogActionBase
{
    FName m_ActorSentToConfrontation;                                                 // 0x0030 (size: 0x8)
    int32 m_iCircleIndex;                                                             // 0x0038 (size: 0x4)
    bool m_bPlayPrefightAnimations;                                                   // 0x003C (size: 0x1)

    TArray<FName> GetActorOptions();
}; // Size: 0x40

class UConsumStaminaNotify : public UStaminaNotify
{
}; // Size: 0x38

class UContextualDefenseInfluenceNode : public UAIInfluenceNode
{
    FGameplayTagContainer m_TagsToFlushOnSuccess;                                     // 0x0048 (size: 0x20)
    FGameplayTagContainer m_TagsToRaiseOnSuccess;                                     // 0x0068 (size: 0x20)
    bool m_bFlushThrowAttackMemory;                                                   // 0x0088 (size: 0x1)
    float m_fMemoryFlushLimit;                                                        // 0x008C (size: 0x4)
    bool m_bLaunchDefaultActions;                                                     // 0x0090 (size: 0x1)
    FName m_InfluenceNodeName;                                                        // 0x0094 (size: 0x8)
    TArray<class USCAITriggerableActions*> m_ActionsToTriggerOnValidation;            // 0x00A0 (size: 0x10)
    TArray<FAIConditionedAction> m_ActionsOnSuccess;                                  // 0x00B0 (size: 0x10)

}; // Size: 0xC0

class UControllerButtonWidget : public UButtonUserWidget
{
    int32 m_iInputSlotIndex;                                                          // 0x0820 (size: 0x4)
    FFloatRange m_AxisScaleRange;                                                     // 0x0824 (size: 0x10)
    InputContext m_eInputContext;                                                     // 0x0834 (size: 0x1)
    EControllerIconAxisTypes m_eAxisType;                                             // 0x0835 (size: 0x1)
    bool m_bUpdateOnControllerTypeChanged;                                            // 0x0836 (size: 0x1)
    TArray<class UGenericInputData*> m_InputDatas;                                    // 0x0838 (size: 0x10)
    EControllerIconStyles m_IconStyle;                                                // 0x0848 (size: 0x1)
    InputAction m_eAction;                                                            // 0x0849 (size: 0x1)
    FMappingID m_MappingID;                                                           // 0x0850 (size: 0x58)

    void BPF_SetMappingID(const FMappingID& _mappingID, bool _bRefresh);
    void BPF_SetInputSlotIndex(int32 _iSlotIndex);
    void BPF_SetInputDatas(TArray<class UGenericInputData*> _InputDatas);
    void BPF_SetInputData(class UGenericInputData* _InputData);
    void BPF_SetIconStyle(EControllerIconStyles _eIconStyle, bool _bRefresh);
    void BPF_SetAxisType(EControllerIconAxisTypes _eAxisType, bool _bRefresh);
    void BPF_SetAction(InputAction _eAction, bool _bRefresh);
    bool BPF_IsKeyboardInput();
    void BPF_GetUIKeyInfos(bool& _bOutFoundIcon, FInputMappingNode& _outNode, TSoftObjectPtr<UTexture2D>& _icon, FKey& _key, FText& _replacementText, bool& _bShowText, FString& _outSeparator);
    FText BPF_GetKeyDisplayName(const FKey& _key);
    void BPF_GetInputNode(FInputMappingNode& Node);
}; // Size: 0x8B8

class UControllerNatureCondition : public UBaseActorCondition
{
    EControllerNature m_eControllerNature;                                            // 0x0028 (size: 0x1)

}; // Size: 0x30

class UCreditsWidget : public UMenuWidget
{
    float m_fScrollFactor;                                                            // 0x03D8 (size: 0x4)
    int32 m_iScrollPixelPerSeconds;                                                   // 0x03DC (size: 0x4)
    float m_fSpeedFactorWithStick;                                                    // 0x03E0 (size: 0x4)
    float m_fScrollTime;                                                              // 0x03E4 (size: 0x4)
    TArray<FCreditCompanyStruct> m_Companies;                                         // 0x03E8 (size: 0x10)

}; // Size: 0x3F8

class UCurrentAttackTargetCondition : public UBaseActorTargetCondition
{
    float m_fMaxElapsedTimeSinceLastUpdate;                                           // 0x0028 (size: 0x4)

}; // Size: 0x30

class UCursorInputData : public UVectorInputData
{
    bool m_bNormalize;                                                                // 0x0180 (size: 0x1)
    float m_fNormalizeRegionRadius;                                                   // 0x0184 (size: 0x4)

}; // Size: 0x188

class UCustomBoundingBoxComponent : public UBoxComponent
{
    int32 m_UsableSides;                                                              // 0x04B8 (size: 0x4)

}; // Size: 0x4E0

class UCustomWidgetNavigation : public UObject
{
    FCustomWidgetNavigationData m_CustomNavigationConfig;                             // 0x0028 (size: 0x1)

    void BPF_RestoreNavigationConfig();
    bool BPF_IsAnalogNavigationEnabled();
    void BPF_ApplyNavigationConfig();
}; // Size: 0x40

class UDeathAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UDeathDB : public UInheritedDataAsset
{
    bool m_bFallOnSlopes;                                                             // 0x0038 (size: 0x1)
    FDeathRadialImpulse m_RadialImpulse;                                              // 0x0040 (size: 0x28)
    TMap<class FSCDeathAnimTypeEnum, class UAnimSequence*> m_DeathAnims;              // 0x0068 (size: 0x50)
    FDeathStandupAnimations m_StandUpAnims;                                           // 0x00B8 (size: 0x78)
    FAnimContainer m_DownBeforeStandupAnim;                                           // 0x0130 (size: 0x18)
    float m_fKnockBackDistance;                                                       // 0x0148 (size: 0xC)
    uint8 m_iNbFrameStuned;                                                           // 0x0154 (size: 0x3)
    class ULevelSequence* m_Sequence;                                                 // 0x0158 (size: 0x8)
    float m_fDelayBeforeSequence;                                                     // 0x0160 (size: 0x4)
    float m_fFloorCorrectionCoeff;                                                    // 0x0164 (size: 0x4)
    float m_fCollisionsFreeRadius;                                                    // 0x0168 (size: 0x4)
    bool m_bCameraTargetPelvis;                                                       // 0x016C (size: 0x1)

}; // Size: 0x170

class UDeathDetectionBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UDeathLevelSequence : public UWGLevelSequence
{

    void BPF_NotifyEvent(EDeathSequenceEvents _event);
}; // Size: 0x100

class UDeathMenu : public UMenuWidget
{

    void BPF_StandBackUp();
    void BPF_SetIsGameover(bool _bGameOver);
    void BPF_IncrementAge(int32 _iAgeIncrement);
}; // Size: 0x3F0

class UDeathPositionSettings : public UBaseCombatPositionSettings
{
    float m_fHeavySurpriseDistance;                                                   // 0x0088 (size: 0x4)
    float m_fLightSurpriseDistance;                                                   // 0x008C (size: 0x4)
    int32 m_iProbaToPlayLightSurprise;                                                // 0x0090 (size: 0x4)

}; // Size: 0x98

class UDebugMenu : public USCUserWidget
{
    FString m_CharacterBuildPath;                                                     // 0x0310 (size: 0x10)
    class UCharacterBuildDB* m_DummyCharcterBuild;                                    // 0x0320 (size: 0x8)
    class UCharacterBuildListDB* m_CharacterBuildList;                                // 0x0328 (size: 0x8)
    TSubclassOf<class ULoadSlot> m_LoadingButtonClass;                                // 0x0340 (size: 0x8)

    void BPF_ShowSaves(class UPanelWidget* _boxToFill);
    void BPF_SetVBoxInvisible();
    void BPF_LoadEquipmentSelection();
    void BPF_LoadBackup(FString _backupName);
    void BPF_LoadAndSetFirstSave(class ULoadSlot* _loadSlot);
    void BPF_DeleteBackup(FString _backupName);
    void BPF_CreateNewSave(FString _charaName);
    void BPF_CreateBackup(FString _backupName);
}; // Size: 0x348

class UDebugMenuAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UDefault__MappingEditorHelpers
{
}; // Size: 0x0

class UDefenseAnimRequest : public UObject
{

    void BPE_GetHitDefenseAnimation(const FHitDescription& _hitDescription, class AFightingCharacter* _grabber, FDefenderAnimInfos& _outDefenderAnims, FDefenseAnimInfos& _outDefendeeAnims);
    void BPE_GetDefaultThrowAnimation(FDefenseAnimInfos& _outGrabberAnims, FDefenseAnimInfos& _outGrabbedAnims);
}; // Size: 0x28

class UDefenseComponent : public UActorComponent
{
    FDefenseComponentBPE_GuardChanged BPE_GuardChanged;                               // 0x00C8 (size: 0x10)
    void GuardChanged(EGuardType _eGuardType);
    TArray<EOrderType> m_UninterruptibleOrderByGuard;                                 // 0x00D8 (size: 0x10)
    FDefenseComponentBPE_FightingStateChanged BPE_FightingStateChanged;               // 0x00E8 (size: 0x10)
    void FightingStateChanged(EFightingState _eFightingState, bool _bPush);
    FDefenseComponentBPE_AvoidWindowOpened BPE_AvoidWindowOpened;                     // 0x00F8 (size: 0x10)
    void AvoidWindowOpened();
    class UParryDB* m_ParryDB;                                                        // 0x0120 (size: 0x8)
    class UAvoidDB* m_AvoidDB;                                                        // 0x0128 (size: 0x8)
    float m_fCurrentGuard;                                                            // 0x0160 (size: 0x4)
    FDefenseComponentBPE_GuardBroken BPE_GuardBroken;                                 // 0x0168 (size: 0x10)
    void GuardBrokenDynamicDelegate();
    FDefenseComponentOnGuardGaugeChanged OnGuardGaugeChanged;                         // 0x0178 (size: 0x10)
    void GuardGaugeChangedDelegate(float NewValue);
    class UAvoidPropertyDB* m_AvoidPropertyDB;                                        // 0x01E8 (size: 0x8)
    FActionConditions m_CancelConditions;                                             // 0x01F0 (size: 0x2)
    FActionConditions m_AttackConditions;                                             // 0x01F2 (size: 0x2)
    FActionConditions m_DodgeConditions;                                              // 0x01F4 (size: 0x2)
    FActionConditions m_RushConditions;                                               // 0x01F6 (size: 0x2)
    class UGuardDB* m_DefaultGuardDB;                                                 // 0x0210 (size: 0x8)
    FGuardUpdateStruct m_GuardTargettedStruct;                                        // 0x0218 (size: 0x10)
    float m_fMaxGuard;                                                                // 0x0238 (size: 0x4)
    float m_MaxGuardMultiplier;                                                       // 0x023C (size: 0xC)
    float m_fGrabbableGuardRatio;                                                     // 0x0248 (size: 0x4)
    float m_fGuardBrokenGaugeCoolDownBeforeRecovery;                                  // 0x024C (size: 0x4)
    float m_fGuardRecoveryRate;                                                       // 0x0250 (size: 0x4)
    class UCurveFloat* m_GuardRecoveryRateByLife;                                     // 0x0258 (size: 0x8)
    class UCurveFloat* m_GuardRecoveryRateByLifePerDifficulty;                        // 0x0268 (size: 0x18)
    float m_fGuardBrokenRecoveryRate;                                                 // 0x0280 (size: 0x4)
    class UCurveFloat* m_GuardGaugeRecoveryRateOverWeightRatioCurve;                  // 0x0288 (size: 0x8)
    float m_fGuardRecoveryRateCoeffWhenGuarding;                                      // 0x0298 (size: 0x4)
    float m_fGuardBreakDuration;                                                      // 0x029C (size: 0x4)
    bool m_bCanDoActionIfGuardGaugeEmpty;                                             // 0x02A0 (size: 0x1)
    bool m_bGuardBlocksImpactsFromBack;                                               // 0x02A1 (size: 0x1)
    bool m_bIgnoreRecoveryBlockInGuardBroken;                                         // 0x02A2 (size: 0x1)
    EGuardType m_eGuardType;                                                          // 0x02A3 (size: 0x1)
    float m_fRangeOfDodgeForRefill;                                                   // 0x02EC (size: 0x4)
    float m_fDodgeRefillValue;                                                        // 0x02F4 (size: 0x4)
    float m_fDodgeGuardGaugeRefillValue;                                              // 0x02F8 (size: 0x4)
    float m_fBareHandsGuardCoeff;                                                     // 0x0300 (size: 0x4)
    float m_fBareHandsGuardSpecialCoeff;                                              // 0x0304 (size: 0x4)
    class UAbsorbDB* m_AbsorbDB;                                                      // 0x0388 (size: 0x8)
    bool m_bCanBeSuperDizzy;                                                          // 0x0390 (size: 0x1)
    FDefenseGauge m_SuperDizzyGauge;                                                  // 0x0394 (size: 0x18)
    float m_fSuperDizzyGaugeRatioAfterSuperDizzy;                                     // 0x03AC (size: 0x4)
    float m_fGuardGaugeRecoveryCooldown;                                              // 0x03C4 (size: 0x4)
    float m_GuardGaugeRecoveryCooldownPerDifficulty;                                  // 0x03C8 (size: 0xC)
    int32 m_iResilience;                                                              // 0x03D4 (size: 0x4)
    int32 m_iResilienceAttackBonus;                                                   // 0x03D8 (size: 0x4)
    class UAttackPropertiesResistanceDB* m_AttackPropertyResistanceDB;                // 0x0458 (size: 0x8)

    void ServerSetGuardValue(float _fGuard);
    void ServerRepSetGuardGaugeTarget(float _fPercentageTarget, int64 _iTimeToTarget);
    void PopFightingStates();
    void OnRep_GuardTargettedStruct();
    void OnMoveStatusChanged(class UFightingMovementComponent* _movementComponent);
    void OnHit(const FHitDescription& _hitDescription);
    void OnEffectAddedOrRemovedCallback(bool _bAdded, class UEffectData* _effectData);
    void OnDeath();
    void OnDamage(float _fAmount, class UHealthComponent* _healthComponent, bool _bApplied);
    void MultiCastSetGuardGaugeTarget(float _fPercentageTarget, int64 _iTimeToTarget);
    bool IsParryWindowOpen(bool _bPrediction);
    bool IsParryActive(bool _bPrediction);
    bool IsGuarding();
    bool IsAbsorbWindowOpened(bool _bInPrediction);
    void GuardGaugeChangedDelegate__DelegateSignature(float NewValue);
    void GuardChanged__DelegateSignature(EGuardType _eGuardType);
    void GuardBrokenDynamicDelegate__DelegateSignature();
    EGuardType GetGuardType();
    void FightingStateChanged__DelegateSignature(EFightingState _eFightingState, bool _bPush);
    void ClientNotifyIsTargettedByAttack(class AFightingCharacter* _attackInstigator, FName _attack);
    void BPF_SetPermanentFightingState(EFightingState _ePermanentFightingState);
    void BPF_SetIsSlapstickFight(const bool _bIsSlapstickFight);
    void BPF_SetIsOnePunchBreaker(const bool _bIsOnePunchBreaker);
    void BPF_SetIsForceStructureDamage(bool _bIsForceStructureDamage);
    void BPF_SetIsForceHealthDamage(bool _bIsForceHealthDamage);
    void BPF_SetIsAutoDeflect(bool _bIsAutoDeflect);
    void BPF_SetGuardType(EGuardType _eGuardType, bool _bInPrediction);
    void BPF_SetDisableGuard(bool _bValue);
    void BPF_SetBuildUpFramesMultiplicator(float _fMult);
    void BPF_SetAutoAvoid(bool _bAutoAvoid);
    void BPF_RestoreIncreaseGuardGauge();
    void BPF_ResetGuardDBToDefault();
    void BPF_PushVitalPointsDbOverride(FName _overrideName, class UVitalPointDB* _db);
    void BPF_PushAttackPropertiesResistanceDBOverride(FName _name, class UAttackPropertiesResistanceDB* _resistanceDB);
    void BPF_PopVitalPointsDbOverride(FName _overrideName);
    void BPF_PopAttackPropertiesResistanceDBOverride(FName _name);
    void BPF_OverrideGuardDB(class UGuardDB* _guardDB);
    void BPF_NotifyVitalPointsChanged();
    bool BPF_IsSlapstickFight();
    bool BPF_IsGuardBroken();
    bool BPF_IsForceStructureDamage();
    bool BPF_IsForceHealthDamage();
    bool BPF_IsFightingStateActive(EFightingState _eFightingState);
    bool BPF_IsAutoAvoid();
    void BPF_IncreaseGuardGauge(float _fAmount);
    class UVitalPointDB* BPF_GetVitalPointsDb();
    int32 BPF_GetResilienceBonusFromAttack();
    int32 BPF_GetResilience();
    float BPF_GetMaxGuardGauge();
    float BPF_GetGuardRatio();
    class UGuardDB* BPF_GetGuardDB();
    float BPF_GetGrabbableGuardRatio();
    float BPF_GetFightingStateTimeLeft(EFightingState _eFightingState, bool& _bOutActive, bool& _bOutInfinite);
    bool BPF_GetFightingStateInfos(EFightingState _eFightingState, FFightingStateElement& _outInfos);
    float BPF_GetBaseMaxGuard();
    class UAttackPropertiesResistanceDB* BPF_GetAttackPropertiesResistanceDB();
    void BPF_DecreaseGuardGaugeOverTime(float _fAmount, float _fDelay);
    void BPF_DecreaseGuardGauge(float _fAmount);
    void AvoidWindowOpened__DelegateSignature();
    uint8 AbsorbStacksLeft(bool _bInPrediction);
}; // Size: 0x520

class UDefenseInfluenceNodeAttackAsDefense : public UContextualDefenseInfluenceNode
{
    float m_fTimeBeforeTagetAttackHit;                                                // 0x00C0 (size: 0x4)
    FName m_ComboTrigger;                                                             // 0x00C4 (size: 0x8)
    FSCAITicketEnum m_AttackTicket;                                                   // 0x00D0 (size: 0x50)

}; // Size: 0x120

class UDefenseInfluenceNodeAvoid : public UContextualDefenseInfluenceNode
{
}; // Size: 0xC0

class UDefenseInfluenceNodeDodge : public UContextualDefenseInfluenceNode
{
    bool m_bOverrideDirection;                                                        // 0x00C0 (size: 0x1)
    EDodgeDirectionType m_eDirectionTypeOverride;                                     // 0x00C1 (size: 0x1)

}; // Size: 0xC8

class UDefenseInfluenceNodeGotoPhase : public UContextualDefenseInfluenceNode
{
    FAIPhaseNodeHardLink m_phaseHardLink;                                             // 0x00C0 (size: 0x20)

}; // Size: 0xE0

class UDefenseInfluenceNodeGotoPhaseDynamic : public UContextualDefenseInfluenceNode
{
    FAIPhaseNodeSoftLink m_phaseSoftLink;                                             // 0x00C0 (size: 0x40)

}; // Size: 0x100

class UDefenseInfluenceNodeGuard : public UContextualDefenseInfluenceNode
{
}; // Size: 0xC0

class UDefenseInfluenceNodeInvalid : public UContextualDefenseInfluenceNode
{
}; // Size: 0xC0

class UDefenseInfluenceNodeParryDeflect : public UContextualDefenseInfluenceNode
{
}; // Size: 0xC0

class UDefenseInfluenceNodeTraversalEvasion : public UContextualDefenseInfluenceNode
{
}; // Size: 0xC0

class UDefenseNotifyState : public USCAnimNotifyState
{
    FString m_alName;                                                                 // 0x0048 (size: 0x10)

    void BPE_OnHitDefense(const FHitResult& _hitResult, FImpactResult& _Impact, const FHitRequest& _hitRequest, bool& _bShouldDismiss);
}; // Size: 0x58

class UDefenseTacticUseCondition : public UBaseUseCondition
{

    EDefenseTactics BPE_SelectBestDefenseTactic(bool& _bOutTriggerCounter);
}; // Size: 0x58

class UDefenseTagsOrderService : public UOrderService
{
    FGameplayTagContainer m_SetHitBoxRequiredTags;                                    // 0x0028 (size: 0x20)

}; // Size: 0x48

class UDeflectImpactDB : public UObject
{
    FDeflectImpact m_DeflectImpact;                                                   // 0x0028 (size: 0x48)

}; // Size: 0x70

class UDeflectImpactHelpers : public UBlueprintFunctionLibrary
{

    FAppliedHitImpact BPF_MakeAppliedHitImpact(const FHitImpact& _hitImpact, const class AFightingCharacter* _defender);
    FAppliedDeflectImpact BPF_MakeAppliedDeflectImpact(const FDeflectImpact& _hitImpact, const class AFightingCharacter* _defender, bool _bParriable);
}; // Size: 0x28

class UDeltaTransformAudioData : public UDataAsset
{
    class UAkAudioEvent* m_defaultAkEvent;                                            // 0x0030 (size: 0x8)
    TArray<FDeltaTransformAudioStep> m_Steps;                                         // 0x0038 (size: 0x10)

    class UAkAudioEvent* GetAudioEvent(FTransform _from, FTransform _to);
}; // Size: 0x48

class UDemoPreStartMenu : public UBaseStartMenu
{

    void OnRetryLoadProfile();
    void OnContinueWithoutSaving();
    void OnConfirmGeneric();
    void OnConfirmCancel();
    void OnAudioLanguageSetup();
}; // Size: 0x408

class UDespawnComponent : public UActorComponent
{

    void OnAiBehaviorChanged(EGlobalBehaviors _eNewBehavior, bool _fromDialog);
}; // Size: 0xE0

class UDetailedMoveTransitionDB : public UDataAsset
{
    TArray<FDetailedMoveTransition> m_TransitionList;                                 // 0x0030 (size: 0x10)
    TMap<class ETransitionGlobalType, class EMoveStatus> m_NeededMoveStatusMap;       // 0x0040 (size: 0x50)

}; // Size: 0x1090

class UDetectEnemyBehindTraversalsBTService : public UBTService
{
    float m_fDetectionDistance;                                                       // 0x0070 (size: 0x4)

}; // Size: 0x78

class UDetectFallOrderService : public UOrderService
{
    bool m_IgnoreWhenDead;                                                            // 0x0028 (size: 0x1)
    bool m_bProjectVelocityOnDirection;                                               // 0x0029 (size: 0x1)
    FFloatRange m_VelocityFallRange;                                                  // 0x002C (size: 0x10)
    ESlopeReaction m_eReactionOnStart;                                                // 0x003C (size: 0x4)
    ESlopeReaction m_eSlopeReactionWhenStartsOnSlope;                                 // 0x0040 (size: 0x4)
    float m_fEnterLeaveSlopeHitActivationDelay;                                       // 0x0044 (size: 0x4)
    bool m_bHasHitOnEnterSlope;                                                       // 0x0048 (size: 0x1)
    FHitBox m_HitOnEnterSlope;                                                        // 0x0050 (size: 0x298)
    bool m_bHasHitOnLeaveSlope;                                                       // 0x02E8 (size: 0x1)
    FHitBox m_HitOnLeaveSlope;                                                        // 0x02F0 (size: 0x298)
    ESlopeReaction m_eSlopeReaction;                                                  // 0x0588 (size: 0x4)
    float m_fSteepSlopeAngleThreshold;                                                // 0x058C (size: 0x4)
    ESlopeReaction m_eSteepSlopeReaction;                                             // 0x0590 (size: 0x4)
    float m_fFarSlopeHAngleMinDegree;                                                 // 0x0594 (size: 0x4)
    ESlopeReaction m_eFarSlopeHAngleReaction;                                         // 0x0598 (size: 0x4)
    FAnimContainer m_CustomFallAnimOnSlope;                                           // 0x05A0 (size: 0x18)

    FVector BPE_GetDirection(const FBPOrderServiceInstance& _instance);
}; // Size: 0x5B8

class UDifficultyInfluenceTest : public UFloatInfluenceTest
{
}; // Size: 0x60

class UDisableCamFadeOnOwnerOrderService : public UOrderService
{
}; // Size: 0x28

class UDisableCollisionOrderService : public UOrderService
{
    bool m_bWithTargetOnly;                                                           // 0x0028 (size: 0x1)
    bool m_bCollisionWithStaticMeshOn;                                                // 0x0029 (size: 0x1)
    bool m_bBlockTargettedAttacks;                                                    // 0x002A (size: 0x1)
    bool m_bEnableCollisionsOnLastThreat;                                             // 0x002B (size: 0x1)

}; // Size: 0x30

class UDisableExpulseOrderService : public UOrderService
{
}; // Size: 0x28

class UDisableTargetTrackingNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UDisableTraversalInvulnerabilityNotify : public USCAnimNotify
{
}; // Size: 0x48

class UDisableWalkOffLedgesOrderService : public UOrderService
{
}; // Size: 0x28

class UDistFromFloorOrderService : public UOrderService
{
    float m_fMinFloorDist;                                                            // 0x0028 (size: 0x4)
    float m_fMaxFloorDist;                                                            // 0x002C (size: 0x4)

}; // Size: 0x30

class UDistanceInfluenceTest : public UFloatInfluenceTest
{
}; // Size: 0x60

class UDistanceTargetWeightEvaluation : public UBaseTargetWeightEvaluation
{
    FRuntimeFloatCurve m_DistanceCurve;                                               // 0x0028 (size: 0x88)

}; // Size: 0xB0

class UDistributionStatCompareWidget : public UUserWidget
{
    class UPreviewData* m_PreviewData;                                                // 0x0268 (size: 0x8)

    class UStatsComponent* BPF_GetStatsComponent();
    class UPreviewData* BPF_GetPreviewData();
}; // Size: 0x270

class UDizzyReductionAbility : public USCGameplayAbility
{
    class UCurveFloat* m_TimeReductionAsPercentCurve;                                 // 0x0568 (size: 0x8)

    void BPE_OnDizzyReduction(const FSCGameplayAbilityActorInfo& _infos, float _fTimeLeft, float _fTimeReduced);
}; // Size: 0x570

class UDodgeAbility : public USCGameplayAbility
{
}; // Size: 0x5B0

class UDodgeAnimRequest : public UObject
{

    void BPE_GetDodgeAnimations(TArray<FAnimContainer>& _outAnimContainer, TArray<FAnimContainer>& _outWeaponAnimContainer, bool& _bMirror, ESCCardinalPoints& _eOutCardinalPoint, class AFightingCharacter* _owner, EQuadrantTypes _eQuadrant, ESCCardinalPoints _eCardinalPoint, const class AFightingCharacter* _attacker, const FHitBox& _nextHit, bool _bAttackMirror, float _fHitDelay, const FNetOrderStructDodge& _dodgeStruct);
}; // Size: 0x28

class UDodgeBTTask : public UAIDefenseBTTask
{
}; // Size: 0x90

class UDodgeDB : public UDataAsset
{
    float m_fMaxDodgeRetargettingDistance;                                            // 0x0030 (size: 0x4)
    FDodgeConfigStruct m_dodgeConfigs;                                                // 0x0038 (size: 0xF0)
    bool m_bWantDodgeLock;                                                            // 0x0128 (size: 0x1)
    float m_fDodgeOpponentAttackRangeTolerance;                                       // 0x012C (size: 0x4)
    bool m_bDefaultDodgeQuadrantSwitchActivated;                                      // 0x0130 (size: 0x1)
    bool m_bInvertRedirectOnBackQuadrant;                                             // 0x0131 (size: 0x1)
    class UCurveFloat* m_GuardGaugeCostOverWeightRatio;                               // 0x0138 (size: 0x8)
    bool m_bSmoothedOrderDodgeNotifyStartDT;                                          // 0x0140 (size: 0x1)
    TSubclassOf<class UDodgeAnimRequest> m_animRequest;                               // 0x0148 (size: 0x8)

}; // Size: 0x150

class UDodgeTypeUseCaseMatrix : public UObject
{

    EDodgeDirectionType BPE_GetDodgeToUseFromHitbox(const FHitBox& _hitbox, const class UArchetypeAsset* _archetype);
}; // Size: 0x28

class UDropWeaponNotify : public USCAnimNotify
{
    FVector m_vImpulse;                                                               // 0x0048 (size: 0xC)
    bool m_bImpulseInLocalSocketSpace;                                                // 0x0054 (size: 0x1)
    ECoordinateSystem m_eImpulseCharacterSpace;                                       // 0x0055 (size: 0x1)
    EDropNotifyApplyMode m_ApplyMode;                                                 // 0x0056 (size: 0x1)
    EDropReason m_eDropReason;                                                        // 0x0057 (size: 0x1)

}; // Size: 0x58

class UDropWeaponOrderService : public UOrderService
{
    FVector m_vDropImpulse;                                                           // 0x0028 (size: 0xC)
    EDropReason m_eDropReason;                                                        // 0x0034 (size: 0x1)

}; // Size: 0x38

class UEQContext_Enemy : public UEnvQueryContext
{
}; // Size: 0x28

class UETS_NextHitHelper : public UBlueprintFunctionLibrary
{

    bool BPF_GetNextHitTargetExtraInfos(class AFightingCharacter* _character, const FTargetResult& _targetInfos, FETS_NextHitExtraInfos& _infos);
}; // Size: 0x28

class UEarlyBlendOutNotify : public UAnimNotify
{
    TArray<EFightingState> m_FightingStateActiveConditions;                           // 0x0038 (size: 0x10)

}; // Size: 0x48

class UEditorPreviewPostProcessAnimInstance : public UPostProcessAnimInstance
{
    FName m_DebugIKDummySubInstanceTag;                                               // 0x0638 (size: 0x8)
    FName m_DebugIKMasterSubInstanceTag;                                              // 0x0640 (size: 0x8)
    EPostProcessAnimDebugRole m_eDebugRole;                                           // 0x0648 (size: 0x1)
    float m_fDebugFloorHeight;                                                        // 0x064C (size: 0x4)
    FVector m_vLocationDelta;                                                         // 0x0650 (size: 0xC)
    FVector m_vExpectedLocation;                                                      // 0x065C (size: 0xC)
    TWeakObjectPtr<class UAnimSequence> m_DummyAnim;                                  // 0x0668 (size: 0x8)
    float m_fDummyAnimTime;                                                           // 0x0670 (size: 0x4)
    bool m_bDummyAnimMirror;                                                          // 0x0674 (size: 0x1)

}; // Size: 0x680

class UEffectData : public UDataAsset
{
    float m_fDuration;                                                                // 0x0030 (size: 0x4)
    bool m_bHitInteruptible;                                                          // 0x0034 (size: 0x1)
    bool m_bInfinite;                                                                 // 0x0035 (size: 0x1)
    bool m_bKeepAfterDeath;                                                           // 0x0036 (size: 0x1)
    float m_fStaminaRefillCoeff;                                                      // 0x0038 (size: 0x4)
    float m_fStaminaActionsCostCoeff;                                                 // 0x003C (size: 0x4)
    float m_fStaminaRushCostCoeff;                                                    // 0x0040 (size: 0x4)
    float m_fStaminaHitOnGuardCostCoeff;                                              // 0x0044 (size: 0x4)
    float m_fKnockbackCoeff;                                                          // 0x0048 (size: 0x4)
    float m_fBluntProtectionValueAdded;                                               // 0x004C (size: 0x4)
    float m_fCutProtectionValueAdded;                                                 // 0x0050 (size: 0x4)
    float m_fWeightAdded;                                                             // 0x0054 (size: 0x4)
    float m_fHealthRegenRateAdded;                                                    // 0x0058 (size: 0x4)
    float m_fInstantHealthRecovery;                                                   // 0x005C (size: 0x4)
    float m_fInflictedDamageConversionCoeff;                                          // 0x0060 (size: 0x4)
    bool m_bHealIsCapped;                                                             // 0x0064 (size: 0x1)
    float m_fGhostDamageBonus;                                                        // 0x0068 (size: 0x4)
    float m_fAttackDamageMultiplier;                                                  // 0x006C (size: 0x4)
    float m_fDamageReceivedMultiplier;                                                // 0x0070 (size: 0x4)
    float m_fBarehandSpecialDamageRatio;                                              // 0x0074 (size: 0x4)
    int8 m_iResilienceBonus;                                                          // 0x0078 (size: 0x1)
    float m_fImpactOnWeaponDurabilityMultiplier;                                      // 0x007C (size: 0x4)

}; // Size: 0x80

class UEnvQueryGenerator_ActorClassFromManager : public UEnvQueryGenerator
{
    FAIDataProviderBoolValue m_GenerateOnlyActorsInRadius;                            // 0x0050 (size: 0x38)
    FAIDataProviderFloatValue m_SearchRadius;                                         // 0x0088 (size: 0x38)
    TSubclassOf<class UEnvQueryContext> m_SearchCenter;                               // 0x00C0 (size: 0x8)
    TSubclassOf<class AActor> m_ActorClass;                                           // 0x00C8 (size: 0x8)

}; // Size: 0xD0

class UEnvQueryGenerator_FightingCharacters : public UEnvQueryGenerator_ActorClassFromManager
{
}; // Size: 0xD0

class UEnvQueryGenerator_WallJumps : public UEnvQueryGenerator
{
    TSubclassOf<class UActorComponent> m_RequiredComponentClass;                      // 0x0050 (size: 0x8)
    TSubclassOf<class AActor> m_SearchedActorClass;                                   // 0x0058 (size: 0x8)
    FAIDataProviderBoolValue m_GenerateOnlyActorsInRadius;                            // 0x0060 (size: 0x38)
    TSubclassOf<class UEnvQueryContext> m_SearchCenter;                               // 0x0098 (size: 0x8)
    FAIDataProviderFloatValue m_SearchRadius;                                         // 0x00A0 (size: 0x38)
    FAIDataProviderFloatValue m_MinAngle;                                             // 0x00D8 (size: 0x38)
    FAIDataProviderFloatValue m_MaxAngle;                                             // 0x0110 (size: 0x38)
    FAIDataProviderFloatValue m_MinAngleForwardToWall;                                // 0x0148 (size: 0x38)
    FAIDataProviderFloatValue m_MaxAngleForwardToWall;                                // 0x0180 (size: 0x38)
    FAIDataProviderFloatValue m_MinSelfToWallJumpDist;                                // 0x01B8 (size: 0x38)
    FAIDataProviderFloatValue m_MaxSelfToWallJumpDist;                                // 0x01F0 (size: 0x38)
    FAIDataProviderFloatValue m_MinTargetToWallJumpDist;                              // 0x0228 (size: 0x38)
    FAIDataProviderFloatValue m_MaxTargetToWallJumpDist;                              // 0x0260 (size: 0x38)

}; // Size: 0x298

class UEnvQueryItemType_WallJump : public UEnvQueryItemType_ActorBase
{
}; // Size: 0x30

class UEnvQueryTest_ActorsRelativeSideToBox : public UEnvQueryTest
{
    EGetActorsRelativeSideToBox m_eTest;                                              // 0x01F8 (size: 0x1)
    float m_fMaxDistanceToBox;                                                        // 0x01FC (size: 0x4)
    TSubclassOf<class UEnvQueryContext> m_ActorA;                                     // 0x0200 (size: 0x8)
    TSubclassOf<class UEnvQueryContext> m_ActorB;                                     // 0x0208 (size: 0x8)
    ETestAxis2D m_eTestAxis;                                                          // 0x0210 (size: 0x1)

}; // Size: 0x218

class UEnvQueryTest_AngleBetween : public UEnvQueryTest
{
    FEnvDirection LineA;                                                              // 0x01F8 (size: 0x20)
    FEnvDirection LineB;                                                              // 0x0218 (size: 0x20)
    ESCTestAngle TestMode;                                                            // 0x0238 (size: 0x1)
    bool m_bInDegree;                                                                 // 0x0239 (size: 0x1)
    TSubclassOf<class UEnvQueryContext> ThreatsToEvaluate;                            // 0x0240 (size: 0x8)

}; // Size: 0x248

class UEnvQueryTest_CanNavigateAroundBox : public UEnvQueryTest
{
    int32 m_iTestsPerBoxSide;                                                         // 0x01F8 (size: 0x4)

}; // Size: 0x200

class UEnvQueryTest_DistanceFromBounding : public UEnvQueryTest
{
    ESCTestDistance TestMode;                                                         // 0x01F8 (size: 0x1)
    TSubclassOf<class UEnvQueryContext> DistanceTo;                                   // 0x0200 (size: 0x8)

}; // Size: 0x208

class UEnvQueryTest_HasComponent : public UEnvQueryTest
{
    TSubclassOf<class UActorComponent> m_ComponentClass;                              // 0x01F8 (size: 0x8)

}; // Size: 0x200

class UEnvQueryTest_IsInNextAttackRange : public UEnvQueryTest
{
    TSubclassOf<class UEnvQueryContext> m_Target;                                     // 0x01F8 (size: 0x8)
    float m_fTolerance;                                                               // 0x0200 (size: 0x4)

}; // Size: 0x208

class UEnvQueryTest_IsThrowableUsable : public UEnvQueryTest
{
    TSubclassOf<class UEnvQueryContext> m_Target;                                     // 0x01F8 (size: 0x8)

}; // Size: 0x200

class UEnvQueryTest_Targetable : public UEnvQueryTest
{
    TSubclassOf<class UEnvQueryContext> m_TargetTo;                                   // 0x01F8 (size: 0x8)
    float m_fTargetRange;                                                             // 0x0200 (size: 0x4)

}; // Size: 0x208

class UEnvQueryTest_TargettingQueryer : public UEnvQueryTest
{
    TSubclassOf<class UEnvQueryContext> m_TargetTo;                                   // 0x01F8 (size: 0x8)

}; // Size: 0x200

class UEnvironmentalAttackDetectionDB : public UDataAsset
{
    TSubclassOf<class UTakedownAnimRequest> m_DefaultAnimRequest;                     // 0x0030 (size: 0x8)
    TSubclassOf<class UTakedownAnimRequest> m_WallAnimRequest;                        // 0x0038 (size: 0x8)
    float m_fDetectionRadius;                                                         // 0x0040 (size: 0x4)
    TEnumAsByte<ECollisionChannel> m_eCollisionChannel;                               // 0x0044 (size: 0x1)

}; // Size: 0x48

class UEnvironmentalImpactComponent : public UActorComponent
{

    void BPE_OnImpact(class AActor* _Instigator, uint8 _uiImpactType, const FHitResult& _hit);
}; // Size: 0xC0

class UEquipmentSelectionButton : public USCButton
{

    void OnButtonClicked();
}; // Size: 0x478

class UEquipmentSelectionData : public UDataAsset
{
    int8 m_EquipmentMaterials;                                                        // 0x0030 (size: 0x9)
    class UBaseWeaponData* m_Weapon;                                                  // 0x0040 (size: 0x8)
    class USkeletalMesh* m_CharacterMesh;                                             // 0x0048 (size: 0x8)
    uint8 m_uiSkinToneIndex;                                                          // 0x0050 (size: 0x1)

}; // Size: 0x58

class UEvaluateTargetCondition : public UObject
{
    bool m_bInverseCondition;                                                         // 0x0028 (size: 0x1)

}; // Size: 0x30

class UFOpponentAttackXPHelper : public UBlueprintFunctionLibrary
{

    int32 BPF_GetXPValueByType(const FPendingAttackXP& _XP, EPendingttackXPType _eType);
}; // Size: 0x28

class UFactionsManager : public UObject
{
    FTargetableFactions m_FactionsTargetTable;                                        // 0x0028 (size: 0x24)

}; // Size: 0x50

class UFakePhysicComponent : public UActorComponent
{
    float m_fZImpulse;                                                                // 0x00C0 (size: 0x4)
    float m_fImpulseReduc;                                                            // 0x00C4 (size: 0x4)
    FVector m_vAngularImpulse;                                                        // 0x00C8 (size: 0xC)
    class UPrimitiveComponent* m_OverlappingComponent;                                // 0x00D8 (size: 0x8)

    void NotifyBeginOverlap(class UPrimitiveComponent* _OverlappedComp, class AActor* _Other, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const FHitResult& _OverlapInfo);
    void BPF_SetOverlappingComponent(class UPrimitiveComponent* _primComp);
}; // Size: 0xE0

class UFallHitActionLauncher : public UHitActionLauncher
{
    bool m_bMCIsInstigator;                                                           // 0x0038 (size: 0x1)
    bool m_bHitOnInstigator;                                                          // 0x0039 (size: 0x1)
    FHitBox m_HitOnInstigator;                                                        // 0x0040 (size: 0x298)

    void BPE_GetDirection(class AActor* _Instigator, class AActor* _victim, FVector& _vOutStartDirection, FVector& _vOutTargetDirection, bool& _bOutForceStartDirection);
}; // Size: 0x2D8

class UFallHitRequest : public UObject
{

    void BPE_GetFallHitOnSlope(const class AFightingCharacter* _character, const FHitResult& _hitResult, FHitBox& _outHitbox);
    void BPE_GetFallHitOnPhysicAnimImpact(const class AFightingCharacter* _character, const FHitResult& _hitResult, float _fImpulseSize, FHitBox& _outHitbox);
    void BPE_GetFallHit(const class AFightingCharacter* _character, const FHitResult& _hitResult, EFallHitOrigin _eFallHitOrigin, float _fHeight, FHitBox& _outHitbox);
}; // Size: 0x28

class UFallInterruptAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UFidgetDB : public UDataAsset
{
    FFloatRange m_fTimerRange;                                                        // 0x0030 (size: 0x10)
    TArray<FSCConditionnalGestureAndBlendProfile> m_Anims;                            // 0x0040 (size: 0x10)
    FSCUserDefinedEnumHandler m_VariableWeightLayer;                                  // 0x0050 (size: 0x50)
    bool m_bAllowSyncFidgetMirrorWithQuadrant;                                        // 0x00A0 (size: 0x1)

    FSCGestureAndBlendProfile BPF_GetGestureContainer(class AActor* _requester);
    FSCConditionnalGestureAndBlendProfile BPF_GetConditionnalGestureContainer(class AActor* _requester);
    float BPF_ComputeTimer();
}; // Size: 0xB8

class UFidgetPlayerBTService : public UBTService
{
    EAIFidgetTypes m_eFidgetType;                                                     // 0x0070 (size: 0x1)
    bool m_bRestoreTypeOnCeaseRelevant;                                               // 0x0071 (size: 0x1)

}; // Size: 0x78

class UFidgetVariableWeightOrderService : public UOrderService
{
    FSCUserDefinedEnumHandler m_EnumLayer;                                            // 0x0028 (size: 0x50)
    class UBlendProfile* m_DefaultBoneMask;                                           // 0x0078 (size: 0x8)
    FEditableOrderType m_OrderType;                                                   // 0x0080 (size: 0x58)
    ESpeedState m_eRefSpeedState;                                                     // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UFightingAIDialogComponent : public USCDialogComponent
{
}; // Size: 0x1F8

class UFightingActionStateCondition : public UBaseActorCondition
{
    EFightingActionState m_eActionState;                                              // 0x0028 (size: 0x1)

}; // Size: 0x30

class UFightingCameraWeightComponent : public UFixedCameraWeightComponent
{
    bool m_bClampAdditiveWeight;                                                      // 0x00D0 (size: 0x1)
    float m_fMaxAbsAdditiveWeight;                                                    // 0x00D4 (size: 0x4)
    FStateWeight m_fightingStateWeights;                                              // 0x00D8 (size: 0x90)
    float m_fDialogInvolvedAdditiveWeight;                                            // 0x0168 (size: 0x4)
    float m_fDialogSpeakerAdditiveWeight;                                             // 0x016C (size: 0x4)

    void OnGlobalBehaviorChanged(EGlobalBehaviors _eNewBehavior, const bool _bFromDialog);
}; // Size: 0x198

class UFightingCharAnimRepComponent : public UAnimInstanceReplicationComponent
{
}; // Size: 0x150

class UFightingCharacterHelpers : public UBlueprintFunctionLibrary
{

    int32 BPF_PickRandomAnimSequence(TArray<class UAnimSequence*>& _inOutAnimHistory, const TArray<class UAnimSequence*>& _animSelection, bool _bAddToHistory);
    int32 BPF_PickRandomAnimation(TArray<class UAnimSequence*>& _inOutAnimHistory, const TArray<FAnimContainer>& _animSelection, bool _bAddToHistory);
}; // Size: 0x28

class UFightingMovementComponent : public UCharacterMovementComponent
{
    float m_fPenetrationExpulsionSpeed;                                               // 0x0C28 (size: 0x4)
    FFightingMovementComponent_OnTraversalHintUsable m_OnTraversalHintUsable;         // 0x0C70 (size: 0x10)
    void TraversalHintUsable(const FTraversalInfo& currentTraversalInfo, bool bUsable);
    FVector m_vVelocity;                                                              // 0x0CD8 (size: 0xC)
    EMoveStatus m_eMoveStatus;                                                        // 0x0CFC (size: 0x1)
    class UBaseMovementDB* m_BaseMovementDB;                                          // 0x0D18 (size: 0x8)
    bool m_bOverlapOnRemoveCollision;                                                 // 0x0D30 (size: 0x1)
    uint8 m_bPushForceScaledToMassInNavWalking;                                       // 0x0D31 (size: 0x1)
    float m_fInitialPushForceFactorInNavWalking;                                      // 0x0D34 (size: 0x4)
    float m_fPushForceFactorInNavWalking;                                             // 0x0D38 (size: 0x4)
    float m_fFlyModeSpeed;                                                            // 0x13FC (size: 0x4)
    float m_fFlyModeRushSpeed;                                                        // 0x1400 (size: 0x4)
    TSubclassOf<class UTraversalDB> m_TraversalInfosDB;                               // 0x1500 (size: 0x8)
    TArray<class UAnimSequence*> m_LastDodgeAnims;                                    // 0x1508 (size: 0x10)

    void TraversalHintUsable__DelegateSignature(const FTraversalInfo& currentTraversalInfo, bool bUsable);
    void ServerPopDesyncFromServer(uint8 _uiResyncID);
    void OnEffectAddedOrRemovedCallback(bool _bAdded, class UEffectData* _effectData);
    FVector GetRealVelocity();
    float GetRealSpeed();
    FVector GetRealHorizontalVelocity();
    float GetRealHorizontalSpeed();
    void BPF_SetMoveStatus(EMoveStatus _eMoveStatus);
    void BPF_ResetBaseMovementDBToDefault();
    void BPF_PushBlockV2(class AActor* _blocker);
    void BPF_PopBlockV2(class AActor* _blocker);
    void BPF_OverrideBaseMovementDB(class UBaseMovementDB* _newBaseMovementDB);
    bool BPF_IsRushing();
    FVector BPF_GetTraversalHintPosition();
    FVector BPF_GetLastWantedDir();
    float BPF_GetFreeMoveSpeed(const FVector& _vLocalDir, const float _fGlobalIntensity, const ESpeedState& _eSpeedState);
    float BPF_GetFreeMoveOverallAnimSpeed(ESpeedState _eSpeedState);
    float BPF_GetFreeMoveMinSpeed(ESpeedState _eSpeedState);
    float BPF_GetFreeMoveMaxSpeed(ESpeedState _eSpeedState);
    float BPF_GetFreeMoveAnimSpeed(ESpeedState _eSpeedState);
    EFallLevel BPF_GetFallLevel();
    ETraversalPhase BPF_GetCurrentTraversalPhase();
    ESpeedState BPF_GetCurrentSpeedState();
}; // Size: 0x15C0

class UFightingOrderComponent : public UOrderComponent
{
}; // Size: 0x3F8

class UFightingStateCondition : public UBaseActorCondition
{
    EFightingState m_eFightingState;                                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

class UFightingStateInfluenceTest : public UAIInfluenceTest
{
    EFightingState m_eFightingState;                                                  // 0x0050 (size: 0x1)

}; // Size: 0x58

class UFightingStatePushedBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UFilterNewPresetEntryDB : public UDataAsset
{
    FFilterPresetData m_Data;                                                         // 0x0030 (size: 0x580)

}; // Size: 0x5B0

class UFilterPresetDB : public UDataAsset
{
    TArray<class UFilterPresetEntitlementDB*> m_DBs;                                  // 0x0030 (size: 0x10)

    void BPF_GetFilters(class ASCPlayerController* _controller, FFilterPresetCache& _outCache);
}; // Size: 0x40

class UFilterPresetEntitlementDB : public UDataAsset
{
    TArray<FName> m_AvailableForEntitlements;                                         // 0x0030 (size: 0x10)
    TArray<class UFilterPresetEntryDB*> m_Filters;                                    // 0x0040 (size: 0x10)

}; // Size: 0x50

class UFilterPresetEntryDB : public UDataAsset
{
    FFilterPresetData m_Data;                                                         // 0x0030 (size: 0x580)

}; // Size: 0x5B0

class UFilterPresetOLDDB : public UDataAsset
{
    TArray<class UFilterPresetEntryDB*> m_Filters;                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

class UFixedCameraWeightComponent : public UCameraWeightComponent
{
    float m_fFixedWeight;                                                             // 0x00C0 (size: 0x4)

}; // Size: 0xC8

class UFloatInfluenceTest : public UAIInfluenceTest
{
    EAIInfluenceTest m_eTestType;                                                     // 0x0050 (size: 0x1)
    float m_fValueMin;                                                                // 0x0054 (size: 0x4)
    float m_fValueMax;                                                                // 0x0058 (size: 0x4)

}; // Size: 0x60

class UFloatStatTextBlock : public UTextBlock
{
    float Stat;                                                                       // 0x02A8 (size: 0x4)
    FFloatStatTextBlockStatDelegate StatDelegate;                                     // 0x02AC (size: 0x10)
    float GetFloat();
    float CompareStat;                                                                // 0x02BC (size: 0x4)
    FFloatStatTextBlockCompareStatDelegate CompareStatDelegate;                       // 0x02C0 (size: 0x10)
    float GetFloat();
    class UColorComparisonProfile* m_ColorComparisonProfile;                          // 0x02D0 (size: 0x8)
    bool m_bHightIsBetter;                                                            // 0x02D8 (size: 0x1)
    FText m_EmptyText;                                                                // 0x02E0 (size: 0x18)
    FText m_Format;                                                                   // 0x02F8 (size: 0x18)
    float m_fMultiply;                                                                // 0x0310 (size: 0x4)
    bool m_bIsAttributeScale;                                                         // 0x0314 (size: 0x1)
    bool m_bUseGrouping;                                                              // 0x0316 (size: 0x1)
    int32 m_iMinimumIntegralDigits;                                                   // 0x0318 (size: 0x4)
    int32 m_iMaximumIntegralDigits;                                                   // 0x031C (size: 0x4)
    int32 m_iMinimumFractionalDigits;                                                 // 0x0320 (size: 0x4)
    int32 m_iMaximumFractionalDigits;                                                 // 0x0324 (size: 0x4)
    bool m_bCanBeNegative;                                                            // 0x0328 (size: 0x1)

}; // Size: 0x368

class UFlyModeAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UFocusDB : public UDataAsset
{
    FSCUserDefinedEnumHandler m_FocusTargetSlot;                                      // 0x0030 (size: 0x50)
    TSubclassOf<class AAimingBillboardActor> m_ClassOfBillBoardToSpawn;               // 0x0080 (size: 0x8)
    FName m_BoneToAttachBillboard;                                                    // 0x0088 (size: 0x8)
    TSubclassOf<class AVitalPointActor> m_ClassOfVitalPointToSpawn;                   // 0x0090 (size: 0x8)
    FSCCollisionResponseTemplate m_collisionTemplate;                                 // 0x0098 (size: 0x23)
    TEnumAsByte<ECollisionChannel> m_eFocusTraceType;                                 // 0x00BB (size: 0x1)
    float m_fTimeDuration;                                                            // 0x00BC (size: 0x4)
    float m_fMaxDist;                                                                 // 0x00C0 (size: 0x4)
    FStateWeight m_BonusStateWeightOnCameraWhenExitFocus;                             // 0x00C4 (size: 0x10)
    FAnimContainer m_PrepFocusAnimContainer;                                          // 0x00D8 (size: 0x18)
    float m_fSlowMotionFactor;                                                        // 0x00F0 (size: 0x4)
    float m_fCameraSlowMotionFactor;                                                  // 0x00F4 (size: 0x4)
    float m_fAnimationSlowMotionFactor;                                               // 0x00F8 (size: 0x4)
    float m_fDelayBeforeFocusExecution;                                               // 0x00FC (size: 0x4)
    float m_fSlowMoFactorBeforeFocusExecution;                                        // 0x0100 (size: 0x4)
    FSCUserDefinedEnumHandler m_WidgetPoolEnumEntry;                                  // 0x0108 (size: 0x50)
    float m_fPostProcessFadeInDuration;                                               // 0x0158 (size: 0x4)
    float m_fPostProcessFadeOutDuration;                                              // 0x015C (size: 0x4)
    float m_fVitalPointsFXFadeInDuration;                                             // 0x0160 (size: 0x4)

}; // Size: 0x168

class UFocusExecutionAbility : public USCGameplayAbility
{
    FEditableOrderType m_InstigatorOrderType;                                         // 0x0568 (size: 0x58)
    FEditableOrderType m_VictimOrderType;                                             // 0x05C0 (size: 0x58)

}; // Size: 0x638

class UFocusPointCondition : public UBaseActorCondition
{
    int32 m_iValue;                                                                   // 0x0028 (size: 0x4)

}; // Size: 0x30

class UFocusPrepAbility : public USCGameplayAbility
{
    float m_fDeactivationDuration;                                                    // 0x0568 (size: 0x4)
    float m_fMinFocusPointsToActivate;                                                // 0x056C (size: 0x4)

}; // Size: 0x580

class UFootIkAnimInstance : public USCFootIkAnimInstance
{
    TArray<EFightingActionState> m_eHandledActionStates;                              // 0x0AD0 (size: 0x10)
    bool m_bExcludeActionStates;                                                      // 0x0AE0 (size: 0x1)
    TArray<EFightingActionState> m_eHipsHandledActionStates;                          // 0x0AE8 (size: 0x10)
    bool m_bExcludeHipsActionStates;                                                  // 0x0AF8 (size: 0x1)
    ESCSignificanceBuckets m_eMinSignificanceRequired;                                // 0x0AF9 (size: 0x1)
    TArray<ESCSignificanceBuckets> m_ePerServiceMinSignificanceRequired;              // 0x0B00 (size: 0x10)

}; // Size: 0xB10

class UFootStepAnimNotify : public UAnimNotify
{
    FName m_Foot;                                                                     // 0x0038 (size: 0x8)
    TEnumAsByte<ECollisionChannel> m_eChannel;                                        // 0x0040 (size: 0x1)
    bool m_bTraceComplex;                                                             // 0x0041 (size: 0x1)
    float m_fRaycastOffsetUp;                                                         // 0x0044 (size: 0x4)
    float m_fRaycastOffsetDown;                                                       // 0x0048 (size: 0x4)
    ESCSignificanceBuckets m_eMinSignifiance;                                         // 0x004C (size: 0x1)

    void BPF_SetFoot(FName _Foot);
    void BPE_NotifyFootStep(class USkeletalMeshComponent* _meshComp, uint8 _surface, FName _footName, FHitResult _hitResult);
}; // Size: 0x50

class UForceFightingStateOrderService : public UOrderService
{
    EFightingState m_eFightingState;                                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

class UForceGlobalBehaviorBTTask : public USCBTTaskNode
{
    EGlobalBehaviors m_Behavior;                                                      // 0x0070 (size: 0x1)

}; // Size: 0x78

class UForceQuadrantOrderService : public UOrderService
{
    bool m_bForceBackFrontOnly;                                                       // 0x0028 (size: 0x1)
    bool m_bForceFront;                                                               // 0x0029 (size: 0x1)
    EQuadrantTypes m_eQuadrantToTarget;                                               // 0x002A (size: 0x1)

}; // Size: 0x30

class UForceSpeedStateOrderService : public UOrderService
{
    ESpeedState m_eForcedSpeedState;                                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

class UFragmentEcononyDB : public UDataAsset
{
    TMap<class EEquipmentSlot, class FSlotEquipmentValues> m_SlotEquipmentsValues;    // 0x0030 (size: 0x50)
    int32 m_iPrestigePointValue;                                                      // 0x0080 (size: 0x4)
    TMap<ELootBoxType, int32> m_LootBoxesValues;                                      // 0x0088 (size: 0x50)
    int32 m_iApperacenChangeCost;                                                     // 0x00D8 (size: 0x4)

    int32 BPF_GetRepairCost(EEquipmentSlot _eSlot, EGearRarity _eRarity);
    int32 BPF_GetFragmentValue(EEquipmentSlot _eSlot, bool _bIsDirty, EGearRarity _eRarity);
    int32 BPF_GetDyeCost(EEquipmentSlot _eSlot, EGearRarity _eRarity);
}; // Size: 0xE0

class UGPStateInfluenceTest : public UAIInfluenceTest
{
    EAIGameplayStates m_eState;                                                       // 0x0050 (size: 0x1)

}; // Size: 0x58

class UGameDifficultyInfluenceTest : public UAIInfluenceTest
{
    uint32 m_uiGameDifficultyFlags;                                                   // 0x0050 (size: 0x4)

}; // Size: 0x58

class UGameMathTools : public USCMathTools
{

    EQuadrantTypes GetQuadrantTowardTarget(class AFightingCharacter* _originChar, class AActor* _target);
    EQuadrantTypes GetQuadrantFromStick(const FVector2D& _vStick);
    ESCRotationWay GetBaseHipsRotationWayFromQuadrant(EQuadrantTypes _eStartQuadrant, EQuadrantTypes _eEndQuadrant);
    float GetBaseHipsAngleFromQuadrant(EQuadrantTypes _eQuadrant);
    FVector GetBaseFakePelvisDirection(EQuadrantTypes _eQuadrant, FVector _vRefDir);
    void GetAnimQuadrantAndMirror(EQuadrantTypes _eActorQuadrant, EQuadrantTypes _eActionQuadrant, bool& _bOutAnimMirror, EQuadrantTypes& _outAnimQuadrant);
    EQuadrantTypes ComputeQuadrantFromDirectionVectors(const FVector& _vRefDir, const FVector& _vOtherVector);
    ESCRotationWay ComputeBlendWay(const EQuadrantTypes _eStartQuadrant, const EQuadrantTypes _eEndQuadrant, const float _fStartAngle, const float _fEndAngle);
}; // Size: 0x28

class UGameOptionTypeHelper : public UBlueprintFunctionLibrary
{

    void BPF_SetUserSettingValue(EGameOptionTypes _eSetting, float _fValue);
    bool BPF_RestoreGameOptionOverrides(TArray<FGameOptionOverride>& _inOutGameOptionOverrides, bool _bResetOptionOverridesOnRestore);
    bool BPF_RestoreGameOption(FGameOptionOverride& _inOutGameOptionOverride, bool _bResetOptionOverrideOnRestore);
    bool BPF_OverrideGameOptions(TArray<FGameOptionOverride>& _outGameOptionOverrides);
    bool BPF_OverrideGameOption(FGameOptionOverride& _outGameOptionOverride);
    float BPF_GetValueFromRatio(EGameOptionTypes _eInOption, float _fInRatio);
    float BPF_GetValueClamped(EGameOptionTypes _eInOption, float _fInValueToClamp);
    int32 BPF_GetValueAsInt(EGameOptionTypes _eInOption);
    bool BPF_GetValueAsBool(EGameOptionTypes _eInOption);
    float BPF_GetValue(EGameOptionTypes _eInOption);
    float BPF_GetUserSettingValueByOptionType(EGameOptionTypes _eOption);
    float BPF_GetRatioFromValue(EGameOptionTypes _eInOption, float _fInValue);
    float BPF_GetRatio(EGameOptionTypes _eInOption);
    void BPF_GetRange(EGameOptionTypes _eInOption, float& _fOutMin, float& _fOutMax);
    float BPF_GetDefaultValue(EGameOptionTypes _eInOption);
}; // Size: 0x28

class UGameplayOptionsMenu : public UMenuWidget
{

    void BPF_SetGameOptionValue(EGameOptionTypes _eOptionType, float _fOptionValue);
    void BPF_SetGameOptionRatio(EGameOptionTypes _eOptionType, float _fOptionRatio);
    void BPF_RestoreOptionDefaultValue(EGameOptionTypes _eOptionType);
    bool BPF_IsModificationHasBeenMade();
    void BPF_Default();
    void BPF_Cancel();
    void BPF_ApplyCurrentOptionsToDefault();
    TArray<EGameOptionTypes> BPE_GetHandledOptionTypes();
}; // Size: 0x870

class UGameplayTagsCondition : public UBaseActorCondition
{
    FGameplayTagContainer m_RequiredTags;                                             // 0x0028 (size: 0x20)

}; // Size: 0x48

class UGameplayTagsOrderService : public UOrderService
{
    FGameplayTagContainer m_SetTags;                                                  // 0x0028 (size: 0x20)
    bool m_bOnHitComponent;                                                           // 0x0048 (size: 0x1)
    bool m_bOnAbilityComponent;                                                       // 0x0049 (size: 0x1)

}; // Size: 0x50

class UGauge : public UHUDUserWidget
{
    float m_fPercentage;                                                              // 0x0398 (size: 0x4)
    FGauge_fPercentageDelegate m_fPercentageDelegate;                                 // 0x03B0 (size: 0x10)
    float GetPercentageDelegate();

}; // Size: 0x3C0

class UGenderCondition : public UBaseActorCondition
{
    ECharacterGender m_eGender;                                                       // 0x0028 (size: 0x1)

}; // Size: 0x30

class UGenerateImpactOrderService : public UOrderService
{
    FHitBox m_HitGenerated;                                                           // 0x0028 (size: 0x298)

}; // Size: 0x2C0

class UGenericActivationCondition : public UOrderServiceActivationConditions
{
    EOrderServiceConditionUpdateFrequency m_eUpdateFrequency;                         // 0x0028 (size: 0x1)
    EOrderServiceDeactivationMethod m_eDeactivationMethd;                             // 0x0029 (size: 0x1)
    FBaseActorTargetConditionInstance m_GenericCondition;                             // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGenericAvailabilityLayerDB : public UDataAsset
{
    class UAvailabilityLayerData* m_availabilityLayerData;                            // 0x0030 (size: 0x8)
    EALBinaryOperation m_eALBinaryOperation;                                          // 0x0038 (size: 0x1)

}; // Size: 0x40

class UGenericEnvironmentalInteractionComponent : public UBaseEnvironmentalInteractionComponent
{
    bool m_bIgnoreNavMesh;                                                            // 0x00E0 (size: 0x1)
    EWallSide m_eWallSide;                                                            // 0x00E1 (size: 0x1)
    TArray<class USplineComponent*> m_Splines;                                        // 0x00E8 (size: 0x10)
    TSubclassOf<class UWallEnvironmentalAttackSettings> m_Settings;                   // 0x00F8 (size: 0x8)
    FSCUserDefinedEnumHandler m_EnvType;                                              // 0x0100 (size: 0x50)

}; // Size: 0x150

class UGenericErrorPopupWidget : public USCUserWidget
{

    class UPopupWidget* BPE_GetPopupWidget();
}; // Size: 0x318

class UGenericInputData : public UDataAsset
{
    bool m_bIsStackable;                                                              // 0x0030 (size: 0x1)
    bool m_bIsToggleable;                                                             // 0x0031 (size: 0x1)
    bool m_bResetToggleOnActivation;                                                  // 0x0032 (size: 0x1)
    bool m_bResetToggleOnAnyStackedAction;                                            // 0x0033 (size: 0x1)
    FString m_UISeparator;                                                            // 0x0038 (size: 0x10)
    int32 m_uiUIKeyIndex;                                                             // 0x0048 (size: 0x4)
    float m_fLifeSpan;                                                                // 0x004C (size: 0x4)
    TArray<InputAction> m_StackSiblings;                                              // 0x0050 (size: 0x10)
    TArray<InputAction> m_StackResetSiblings;                                         // 0x0060 (size: 0x10)
    TArray<InputAction> m_ResetOnEnterStack;                                          // 0x0070 (size: 0x10)
    TArray<InputAction> m_ConsumeOnEnterStack;                                        // 0x0080 (size: 0x10)
    InputAction m_Action;                                                             // 0x0090 (size: 0x1)
    bool m_bOnlyFallbackToKeyWithBestPrio;                                            // 0x0091 (size: 0x1)
    bool m_bAlwaysCollideWithOtherInputs;                                             // 0x0092 (size: 0x1)
    bool m_bResetOnAnyActionStacked;                                                  // 0x0093 (size: 0x1)
    bool m_bResetWhenFilteredByFallback;                                              // 0x0094 (size: 0x1)
    TArray<FInputMappingKeySlotContainer> m_BaseMappingSlots;                         // 0x0098 (size: 0x10)
    TArray<class UGenericInputData*> m_Fallbacks;                                     // 0x00A8 (size: 0x10)
    class UGenericInputUIData* m_UIData;                                              // 0x00B8 (size: 0x8)

}; // Size: 0xC0

class UGenericInputUIData : public UObject
{
}; // Size: 0x28

class UGenericStickTargetWeightEvaluation : public UBaseDirectionalTargetWeightEvaluation
{
    EWeightBinaryOperator m_eOperator;                                                // 0x0028 (size: 0x1)
    TArray<class UBaseTargetWeightEvaluation*> m_Evaluations;                         // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGenericTargetWeightEvaluation : public UBaseTargetWeightEvaluation
{
    EWeightBinaryOperator m_eOperator;                                                // 0x0028 (size: 0x1)
    TArray<class UBaseTargetWeightEvaluation*> m_Evaluations;                         // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGhostAnimInstance : public UAnimInstance
{
    TWeakObjectPtr<class UAnimationAsset> m_MasterAnim;                               // 0x0360 (size: 0x8)
    float m_fMasterAnimCurrentCursor;                                                 // 0x0368 (size: 0x4)
    bool m_bMasterAnimMirror;                                                         // 0x036C (size: 0x1)

}; // Size: 0x370

class UGlobalAISettings : public UObject
{
    int32 m_iSerializeVersion;                                                        // 0x0028 (size: 0x4)
    float m_fDelayBeforeInvestigation;                                                // 0x002C (size: 0x4)
    float m_fOnPlayerDeathDifficultyRatio;                                            // 0x0030 (size: 0x4)
    float m_fMaxDistToTriggerSuspicious;                                              // 0x0034 (size: 0x4)
    float m_fInvestigationDistance;                                                   // 0x0038 (size: 0x4)
    float m_fSightMaxVerticalAngle;                                                   // 0x003C (size: 0x4)
    float m_fFallSoundDistance;                                                       // 0x0040 (size: 0x4)
    float m_fEnemyUpdateDelay;                                                        // 0x0044 (size: 0x4)
    float m_fDelayBetween2SurprisedDialogSegemnt;                                     // 0x0048 (size: 0x4)
    FFloatRange m_fSurprisedPlayRateRange;                                            // 0x004C (size: 0x10)
    float m_fMaxGlobalDifficultyValue;                                                // 0x005C (size: 0x4)
    TMap<EAIGameplayStates, float> m_RecordedStateDelay;                              // 0x0060 (size: 0x50)
    TSubclassOf<class UDodgeTypeUseCaseMatrix> m_DodgeTypeUseCaseMatrixClass;         // 0x00B0 (size: 0x8)
    float m_fAttackPositionRadius;                                                    // 0x00B8 (size: 0x4)
    float m_fDirectOponentAttackPositionRadius;                                       // 0x00BC (size: 0x4)
    bool m_bEnableJiggleWithMove;                                                     // 0x00C0 (size: 0x1)
    bool m_bEnableJiggleWithAnimation;                                                // 0x00C1 (size: 0x1)
    float m_fJiggleTolerance;                                                         // 0x00C4 (size: 0x4)
    float m_fJiggleMinDist;                                                           // 0x00C8 (size: 0x4)
    TArray<FEditableOrderType> m_NoPhaseTransitionOrders;                             // 0x00D0 (size: 0x10)
    ESpeedState m_eJiggleSpeedState;                                                  // 0x00E0 (size: 0x1)
    float m_TraceTargetCapsuleRadius;                                                 // 0x00E4 (size: 0x4)
    float m_TraceTargetCapsuleHalfHeight;                                             // 0x00E8 (size: 0x4)
    float m_fTraceTargetForObstacleFrequency;                                         // 0x00EC (size: 0x4)
    TEnumAsByte<ECollisionChannel> m_TraceTargetForObstacleChannel;                   // 0x00F0 (size: 0x1)
    FCollisionResponseContainer m_TraceTargetForObstacleCollision;                    // 0x00F1 (size: 0x20)
    FAIAttackHitDetectionVolume m_AttackHitDetectionVolume;                           // 0x0118 (size: 0x10)
    bool m_bUseCapsuleRadiusToDetectFriendlyFire;                                     // 0x0128 (size: 0x1)
    int32 m_iMaxComboStreak;                                                          // 0x012C (size: 0x4)
    bool m_bAlwaysLogComboEvaluationStack;                                            // 0x0130 (size: 0x1)
    float m_fCombatPositionPathCostLimit;                                             // 0x0134 (size: 0x4)
    TArray<EAIPositioningOption> m_DefaultPositioningOptions;                         // 0x0138 (size: 0x10)
    int32 m_AttackTicketJokerComboAttackCount;                                        // 0x0148 (size: 0x10)
    float m_fSpawningTimePerFrame;                                                    // 0x0158 (size: 0x4)
    TSubclassOf<class UNavArea> m_TraversalNavArea;                                   // 0x0160 (size: 0x8)
    TArray<FNavAreaPerRange> m_ClimbNavArea;                                          // 0x0168 (size: 0x10)
    TArray<FNavAreaPerRange> m_DropDownNavAreas;                                      // 0x0178 (size: 0x10)
    TSoftClassPtr<UTraversalDB> m_TraversalDb;                                        // 0x0188 (size: 0x28)
    float m_fTraversalLockTimer;                                                      // 0x01B0 (size: 0x4)
    bool m_bIsTraversalLockTimerUniversal;                                            // 0x01B4 (size: 0x1)
    float m_fDefaultNavLinkCooldown;                                                  // 0x01B8 (size: 0x4)
    float m_fPatrolAcceptanceRadius;                                                  // 0x01BC (size: 0x4)
    float m_fTraversalZNavExtent;                                                     // 0x01C0 (size: 0x4)
    float m_fStopPredictionRequiredDistance;                                          // 0x01C4 (size: 0x10)
    bool m_bCanSlowDownSpeedStateOnPathChanged;                                       // 0x01D4 (size: 0x1)
    bool m_bStopLockOnEnemyIfFarFromEnemy;                                            // 0x01D5 (size: 0x1)
    float m_fDifficultyUpdateRate;                                                    // 0x01D8 (size: 0x4)
    FAIDominationGaugeSteps m_DominationGaugeStepsPerDifficulty;                      // 0x01DC (size: 0x30)
    float m_DominationGaugeSteps;                                                     // 0x020C (size: 0x10)
    int32 m_MaxIndirectOponentPerDominationGauge;                                     // 0x021C (size: 0x10)
    float m_fTauntDifficultyBonus;                                                    // 0x022C (size: 0x4)
    int32 m_iTauntTicketBehaviorMask;                                                 // 0x0230 (size: 0x4)
    TMap<class ESCAICombatRoles, class FTimerAndOffset> m_CombatRolesReactionTimes;   // 0x0238 (size: 0x50)
    TMap<EAIWuguanTicketEvaluation, float> m_fCombatRolesTestScoreFactors;            // 0x0288 (size: 0x50)
    TMap<EAIChangeToIndirectRoleStates, float> m_fSwtichToIndirectOnStateTimers;      // 0x02D8 (size: 0x50)
    TArray<EOrderType> m_ForbiddenOrdersForDirectOpponent;                            // 0x0328 (size: 0x10)
    float m_fCombatRolesRedistributionFallHeight;                                     // 0x0338 (size: 0x4)
    float m_fCombatRoleRedistributionRushInitialDelay;                                // 0x033C (size: 0x4)
    float m_fCombatRoleRedistributionRushUpdateDelay;                                 // 0x0340 (size: 0x4)
    TMap<EAIWuguanTicketEvaluation, float> m_fSuspiciousTestScoreFactors;             // 0x0348 (size: 0x50)
    bool m_bActivateCancelDamagesOnWeaponsForAI;                                      // 0x0398 (size: 0x1)
    float m_fAIweaponDropImpulseMultiplier;                                           // 0x039C (size: 0x4)
    int32 m_DefenseVsThrowableWindowFrameNb;                                          // 0x03A0 (size: 0x4)
    int32 m_DefenseVsThrowableStartWindowAnticipationFrameNb;                         // 0x03A4 (size: 0x4)
    TMap<EDefenseTactics, float> m_DefenseTriggerWindowMaxDuration;                   // 0x03A8 (size: 0x50)
    float m_fPrefightStructureBrokenLastChanceDuration;                               // 0x03F8 (size: 0x4)
    int32 m_iAvoidWindowMultiHitDelayFramesOffset;                                    // 0x03FC (size: 0x4)
    int32 m_iAvoidWindowEndMultiHitFramesOffset;                                      // 0x0400 (size: 0x4)
    uint32 m_uiThreateningActionsMask;                                                // 0x0404 (size: 0x4)
    TArray<EOrderType> m_eThreateningAttackOrders;                                    // 0x0408 (size: 0x10)
    float m_fFleeMinDist;                                                             // 0x0418 (size: 0x4)
    float m_fTooCloseMaxDist;                                                         // 0x041C (size: 0x4)
    bool m_bTriggerTooCloseOnlyDuringDialog;                                          // 0x0420 (size: 0x1)
    bool m_bTriggerTooCloseOnlyOnJoinDialogActors;                                    // 0x0421 (size: 0x1)
    TSubclassOf<class UAIMasterArchetype> m_MasterArchetype;                          // 0x0428 (size: 0x8)
    float m_fTicketManagerMaxIterationTime;                                           // 0x0430 (size: 0x4)
    bool m_bTimeSliceTicketManagers;                                                  // 0x0434 (size: 0x1)
    bool m_bRunTicketManagerDuringSlate;                                              // 0x0435 (size: 0x1)
    float m_fBehaviorChangedMaxRandomDelays;                                          // 0x0438 (size: 0x18)
    float m_fFidgetNearDeathMaxRatio;                                                 // 0x0450 (size: 0x4)
    int32 m_iLastManBonusPerDomination;                                               // 0x0454 (size: 0x10)
    TSoftObjectPtr<UCurveFloat> m_LastManBonusPerCharges;                             // 0x0468 (size: 0x28)
    TSoftObjectPtr<UCurveFloat> m_LastManBonusPerDeathCounter;                        // 0x0490 (size: 0x28)
    FInt32Range m_iLastManValueDeviation;                                             // 0x04B8 (size: 0x10)
    TSoftClassPtr<UNavigationQueryFilter> m_NothingQueryFilter;                       // 0x04C8 (size: 0x28)
    FFloatRange m_fSanctuaryFirstBarkTriggerWindow;                                   // 0x04F0 (size: 0x10)
    FFloatRange m_fSanctuaryFollowingBarkTriggerWindow;                               // 0x0500 (size: 0x10)
    TSoftClassPtr<AAIDirectorActor> m_AIDirectorClass;                                // 0x0510 (size: 0x28)
    int32 m_iArenaMaxAICharactersPerPool;                                             // 0x0538 (size: 0x4)

}; // Size: 0x540

class UGotoPhaseBTTask : public UBTTaskNode
{
    FAIPhaseNodeSoftLink m_phaseSoftLink;                                             // 0x0070 (size: 0x40)

}; // Size: 0xB0

class UGrabHitActionLauncher : public UHitActionLauncher
{
    TSubclassOf<class UDefenseAnimRequest> m_overridenDefenseRequest;                 // 0x0038 (size: 0x8)

}; // Size: 0x40

class UGraphOptionsMenu : public UGameplayOptionsMenu
{
    int32 m_iCurrentResIndex;                                                         // 0x0870 (size: 0x4)
    TArray<FString> m_ResList;                                                        // 0x0878 (size: 0x10)
    bool m_bSetCameraInStartIdlePosition;                                             // 0x0890 (size: 0x1)

    void OnRequestUIChange();
    void BPF_ResolutionChanged(int32 _iIndex);
    int32 BPF_GetCurrentDisplayMode();
    void BPF_AutoDetectSettings();
    void BPF_AcceptSetting();
}; // Size: 0x898

class UGravityCheatData : public UCheatData
{
    bool m_bIsGravityEnabled;                                                         // 0x0038 (size: 0x1)
    float m_fWantedGravityScale;                                                      // 0x003C (size: 0x4)

}; // Size: 0x48

class UGroupActivationCondition : public UOrderServiceActivationConditions
{
    EConditionGroupOperators m_eOperator;                                             // 0x0028 (size: 0x1)
    TArray<class UOrderServiceActivationConditions*> m_Conditions;                    // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGroupCondition : public UBaseActorCondition
{
    EConditionGroupOperators m_eOperator;                                             // 0x0028 (size: 0x1)
    TArray<FBaseActorConditionInstance> m_Conditions;                                 // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGroupTargetCondition : public UBaseActorTargetCondition
{
    EConditionGroupOperators m_eOperator;                                             // 0x0028 (size: 0x1)
    TArray<FBaseActorTargetConditionInstance> m_Conditions;                           // 0x0030 (size: 0x10)

}; // Size: 0x40

class UGuardAbility : public USCGameplayAbility
{
    FHitBox m_StructureBrokenHit;                                                     // 0x0568 (size: 0x298)
    FHitBox m_ParryDizzyHit;                                                          // 0x0800 (size: 0x298)
    FGameplayTagContainer m_TakedownTags;                                             // 0x0A98 (size: 0x20)
    bool m_bEnableNewGuard;                                                           // 0x0AB8 (size: 0x1)
    bool m_bEnableDeflectInterruptOnDeflectNonInterrupt;                              // 0x0AB9 (size: 0x1)
    bool m_bAlwaysShowParry;                                                          // 0x0ABA (size: 0x1)
    EALBinaryOperation m_eForceGuardALBinaryOperation;                                // 0x0ABB (size: 0x1)
    int32 m_iForceGuardALBinaryPriority;                                              // 0x0ABC (size: 0x4)
    FGameplayTagContainer m_ParryGrabRequiredTags;                                    // 0x0AC0 (size: 0x20)
    FGameplayTagContainer m_ParryPickupRequiredTags;                                  // 0x0AE0 (size: 0x20)
    TArray<InputAction> m_HoldToggleResetOnGuardLost;                                 // 0x0B00 (size: 0x10)

    bool BPF_CanActivateTakedown(class AFightingCharacter* _owner);
    bool BPF_CanActivateParryGrab(class AFightingCharacter* _owner);
    void BPE_OnSlowmoActivable(bool _bActivable);
    void BPE_OnParryPickup(const FSCGameplayAbilityActivationInfo& _activationInfos, const FHitResult& _hit, const FHitRequest& _request);
    void BPE_OnGuardInputPressChange(bool _bPressed);
    void BPE_OnDefense(const FSCGameplayAbilityActivationInfo& _activationInfos, const FHitResult& _hit, const FImpactResult& _Impact, const FHitRequest& _request);
}; // Size: 0xB50

class UGuardDB : public UInheritedDataAsset
{
    class UAnimSequence* m_aGuardAnimations;                                          // 0x0038 (size: 0x20)
    bool m_bGuardMirrorFrontRightBackLeft;                                            // 0x0058 (size: 0x1)
    FAnimByHeight m_aGuardPrepAnimations;                                             // 0x0060 (size: 0x60)
    FAnimByCardinalThenHeight m_aHittedGuardAnimations;                               // 0x00C0 (size: 0x180)
    FAnimByCardinalThenHeight m_aHittedDeflectAnimations;                             // 0x0240 (size: 0x180)
    class UAnimSequence* m_aGuardAnimationsWeapon;                                    // 0x03C0 (size: 0x20)
    FAnimByHeight m_aGuardPrepAnimationsWeapon;                                       // 0x03E0 (size: 0x60)
    FAnimByCardinalThenHeight m_aHittedGuardAnimationsWeapon;                         // 0x0440 (size: 0x180)
    FAnimByCardinalThenHeight m_aHittedDeflectAnimationsWeapon;                       // 0x05C0 (size: 0x180)
    float m_fGuardAngleRootToHips;                                                    // 0x0740 (size: 0x4)
    float m_fGuardAngleHipsToRoot;                                                    // 0x0744 (size: 0x4)
    bool m_bGuardReorientBackToFront;                                                 // 0x0748 (size: 0x1)
    bool m_bPrepEnabled;                                                              // 0x0749 (size: 0x1)
    class UCurveFloat* m_DynamicEnteringPrep;                                         // 0x0750 (size: 0x8)
    float m_fEnteringPrepDuration;                                                    // 0x0758 (size: 0x4)
    class UCurveFloat* m_DynamicExitingPrep;                                          // 0x0760 (size: 0x8)
    float m_fExitingPrepDuration;                                                     // 0x0768 (size: 0x4)
    float m_fPrepRange;                                                               // 0x076C (size: 0x4)
    bool m_bPrepForbidMove;                                                           // 0x0770 (size: 0x1)
    float m_fKnockbackCoeff;                                                          // 0x0774 (size: 0x4)
    FHitBox m_ParryHit;                                                               // 0x0778 (size: 0x298)
    float m_fParryStructureRecovery;                                                  // 0x0A10 (size: 0x4)
    float m_fParryFreezeFrames;                                                       // 0x0A14 (size: 0x4)
    float m_fParrySBFreezeFrames;                                                     // 0x0A18 (size: 0x4)
    float m_ParryAttackerStructureDamage;                                             // 0x0A1C (size: 0x4)
    float m_ParryAttackerSuperDizzyDamage;                                            // 0x0A20 (size: 0x4)
    bool m_bApplyDamagesOnGuardBroken;                                                // 0x0A24 (size: 0x1)
    FDeflectImpact m_DefaultDeflectImpact;                                            // 0x0A28 (size: 0x48)
    FHitImpact m_DefaultHitImpact;                                                    // 0x0A70 (size: 0x30)
    FHitImpact m_DefaultGuardImpact;                                                  // 0x0AA0 (size: 0x30)
    float m_fDeflectedDuration;                                                       // 0x0AD0 (size: 0x4)
    class UCurveFloat* m_DeflectedAttackScaleCurves;                                  // 0x0AD8 (size: 0x8)
    EAvoidLaunchMethod m_eDeflectedLaunchMethodOnHit;                                 // 0x0AE0 (size: 0x1)
    bool m_bTmpEnableDeflectedOrder;                                                  // 0x0AE1 (size: 0x1)
    float m_fParryAnimDuration;                                                       // 0x0AE4 (size: 0x4)
    float m_fGrabDuration;                                                            // 0x0AE8 (size: 0x4)
    FFloatRange m_ParryWindow;                                                        // 0x0AEC (size: 0x10)
    float m_fForcedGuardDuration;                                                     // 0x0AFC (size: 0x4)
    class UAvailabilityLayerData* m_ForcedGuardAvailabilityLayer;                     // 0x0B00 (size: 0x8)
    TSubclassOf<class UDefenseAnimRequest> m_DefenseAnimRequest;                      // 0x0B08 (size: 0x8)
    TSubclassOf<class UParryAnimRequest> m_ParryAnimRequest;                          // 0x0B10 (size: 0x8)
    FSCUserDefinedEnumHandler m_BPPickupOnParryOrderID;                               // 0x0B18 (size: 0x50)

    void BPF_GetPickupOnParryAnim(const FHitRequest& _request, class AFightingCharacter* _character, FAnimContainer& _outAnim);
    class UAnimSequence* BPF_GetHittedGuardAnimWeapon(EQuadrantTypes _eQuadrant, ESCCardinalPoints _eCardinalPoint, EHeight _eHeight);
    class UAnimSequence* BPF_GetHittedGuardAnim(EQuadrantTypes _eQuadrant, ESCCardinalPoints _eCardinalPoint, EHeight _eHeight);
    class UAnimSequence* BPF_GetHittedDeflectAnimWeapon(EQuadrantTypes _eQuadrant, ESCCardinalPoints _eCardinalPoint, EHeight _eHeight);
    class UAnimSequence* BPF_GetHittedDeflectAnim(EQuadrantTypes _eQuadrant, ESCCardinalPoints _eCardinalPoint, EHeight _eHeight);
}; // Size: 0xB68

class UHUDUserWidget : public USCUserWidget
{
    bool m_bVisibleWithMenus;                                                         // 0x0310 (size: 0x1)
    TArray<EMenuEnum> m_HideWithMenus;                                                // 0x0318 (size: 0x10)
    bool m_bSearchMenusInStack;                                                       // 0x0328 (size: 0x1)
    bool m_bVisibleInTraining;                                                        // 0x0329 (size: 0x1)
    bool m_bVisibleInTrainingOnly;                                                    // 0x032A (size: 0x1)
    TArray<class UWidget*> m_WidgetsToOffset;                                         // 0x0330 (size: 0x10)

    void BPF_UpdateHUDOffset();
    void BPE_VisibilityChangedFromMenu(ESlateVisibility _eNewVibility);
}; // Size: 0x398

class UHUDWidget : public USCUserWidget
{
    EQuadrantTypes m_eCurrentQuadrant;                                                // 0x0310 (size: 0x1)

    void OnRegularAttack(EQuadrantTypes _eStartQuadrant, EQuadrantTypes _eEndQuadrant, uint8 _uiNewIndex);
    void OnComboEnd(EQuadrantTypes _eNewQuadrant);
    void OnComboChangeQuadrant(EQuadrantTypes _eNewQuadrant);
    void OnComboChangeNextImg(EQuadrantTypes _eNewQuadrant);
    void OnChangeQuadrantState(EQuadrantTypes _eNewQuadrant);
    void OnAltAttack(EQuadrantTypes _eNewQuadrant, uint8 _uiCurrentComboIndex);
    bool BPF_IsAttacking();
    void BPE_ResetFillingsFromQuadrant(EQuadrantTypes _eQuadrant);
    void BPE_RegularAttack(EQuadrantTypes _eAttackStartQuadrant, EQuadrantTypes _eAttackEndQuadrant, uint8 _uiAttackIndex, bool _bFromEditor);
    void BPE_RefreshQuadrantError(EQuadrantTypes _eQuadrant, bool _bError);
    void BPE_OnRebuild();
    void BPE_ComboStart(EQuadrantTypes _eNewQuadrant);
    void BPE_ComboEnds(EQuadrantTypes _eNewQuadrant);
    void BPE_ChangeQuadrant(EQuadrantTypes _eNewQuadrant);
    void BPE_AttackEndsInOtherQuadrant(EQuadrantTypes _eNewQuadrant);
    void BPE_AlternativeAttack(EQuadrantTypes _eAttackStartQuadrant, EQuadrantTypes _eAttackEndQuadrant, bool _bFromEditor);
}; // Size: 0x328

class UHandPoseDB : public UDataAsset
{
    FHandPoseBlendStruct m_BlendInStruct;                                             // 0x0030 (size: 0x20)
    FHandPoseBlendStruct m_BlendOutStruct;                                            // 0x0050 (size: 0x50)
    class UAnimSequence* m_Anims;                                                     // 0x00A0 (size: 0x20)

}; // Size: 0xC0

class UHandWeaponData : public UBaseWeaponData
{
    float m_fHandRadius;                                                              // 0x0190 (size: 0x4)

}; // Size: 0x198

class UHandleLDCollisionOrderService : public UOrderService
{
    bool m_bHandleHittedByEnvironment;                                                // 0x0028 (size: 0x1)
    FSCUserDefinedEnumHandler m_EnvironementImpactType;                               // 0x0030 (size: 0x50)
    bool m_bWallHitMinAngleDegUseCurve;                                               // 0x0080 (size: 0x1)
    FRuntimeFloatCurve m_WallHitMinAngleDegOverTime;                                  // 0x0088 (size: 0x88)
    float m_fWallHitMinAngleDeg;                                                      // 0x0110 (size: 0x4)
    float m_fWallHitMinVelocity;                                                      // 0x0114 (size: 0x4)
    bool m_bInverseOrientationOnHit;                                                  // 0x0118 (size: 0x1)
    bool m_bUseCustomWallHit;                                                         // 0x0119 (size: 0x1)
    bool m_bBlockedByTarget;                                                          // 0x011A (size: 0x1)
    FHitBox m_CustomWallHit;                                                          // 0x0120 (size: 0x298)
    bool m_bActivateHitbox;                                                           // 0x03B8 (size: 0x1)
    bool m_bIgnoreHitOnTarget;                                                        // 0x03B9 (size: 0x1)
    bool m_bUseCustomHitbox;                                                          // 0x03BA (size: 0x1)
    float m_fActivateHitboxMinVelocity;                                               // 0x03BC (size: 0x4)
    FHitBox m_CustomHitBox;                                                           // 0x03C0 (size: 0x298)
    FHitBox m_SelfHitOnCollisionWithCharacter;                                        // 0x0658 (size: 0x298)
    bool m_bDetectTraversal;                                                          // 0x08F0 (size: 0x1)
    float m_fDetectTraversalDuration;                                                 // 0x08F4 (size: 0x4)
    float m_fTraversalDetectionDistance;                                              // 0x08F8 (size: 0x4)
    ESCCardinalPoints m_eTraversalCardinal;                                           // 0x08FC (size: 0x1)
    ESpeedState m_eTraversalSpeedState;                                               // 0x08FD (size: 0x1)
    bool m_bSetTargetAsOwningChar;                                                    // 0x08FE (size: 0x1)

    void GetHitboxDelegateTest__DelegateSignature(const FBPOrderServiceInstance& _orderServiceInstance);
    void GetHitboxDelegate__DelegateSignature(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox);
    void BPE_OnCollisionWithCharacter(const FBPOrderServiceInstance& _orderServiceInstance, class ACharacter* _otherChara);
    void BPE_GetWallHitBox(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox);
    FHittedAnimContainer BPE_GetHittedAnimContainer(const FBPOrderServiceInstance& _orderServiceInstance);
    void BPE_GetHitBox(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox);
    void BPE_GetDirection(const FBPOrderServiceInstance& _orderServiceInstance, FVector& _vOutDir);
}; // Size: 0x900

class UHandleSlopeOrderService : public UOrderService
{
    FName m_SelfBoneName;                                                             // 0x0028 (size: 0x8)
    float m_fProjectionMinAxisSize;                                                   // 0x0030 (size: 0x4)
    float m_fMinSlopeAngle;                                                           // 0x0034 (size: 0x4)
    float m_fMaxSlopeAngle;                                                           // 0x0038 (size: 0x4)
    int32 m_iNumProjectionIteration;                                                  // 0x003C (size: 0x4)
    float m_fInterpSpeed;                                                             // 0x0040 (size: 0x4)

}; // Size: 0x48

class UHardpointAreaActorVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class UHasStunOrdersDecorator : public USCBTDecorator
{
}; // Size: 0x70

class UHaveCloseEnemiesCondition : public UBaseActorCondition
{
    bool m_bTestMaxDist;                                                              // 0x0028 (size: 0x1)
    float m_fMaxDist;                                                                 // 0x002C (size: 0x4)

}; // Size: 0x30

class UHealthComponent : public UActorComponent
{
    FHealthComponent_OnDamage m_OnDamage;                                             // 0x00C8 (size: 0x10)
    void OnDamageDelegate(float _fAmount, class UHealthComponent* _healthComponent, bool _bApplied);
    FHealthComponent_OnLifeStockLostDyn m_OnLifeStockLostDyn;                         // 0x00F0 (size: 0x10)
    void HeathComponentDelegateDynamic(class UHealthComponent* _healhComponent);
    FHealthComponent_OnDeathDismissed m_OnDeathDismissed;                             // 0x0118 (size: 0x10)
    void HeathComponentDelegateDynamic(class UHealthComponent* _healhComponent);
    FHealthComponent_OnDeath m_OnDeath;                                               // 0x0128 (size: 0x10)
    void DeathComponentDelegate();
    float m_fHealth;                                                                  // 0x0138 (size: 0x4)
    float m_fMaxHealth;                                                               // 0x0140 (size: 0x4)
    int32 m_iLifeStock;                                                               // 0x0144 (size: 0x4)

    void ServerHackSetHealth(float _fHealth);
    void OnDamageDelegate__DelegateSignature(float _fAmount, class UHealthComponent* _healthComponent, bool _bApplied);
    void HeathComponentDelegateDynamic__DelegateSignature(class UHealthComponent* _healhComponent);
    void GhostDamageLost__DelegateSignature();
    void DeathComponentDelegate__DelegateSignature();
    void BPF_SetCanDieByDamage(bool _bValue);
    void BPF_SetCanBeDamaged(bool _bValue);
    void BPF_SetCanAddHealth(bool _bValue);
    void BPF_ServerSetHealth(float _fHealth);
    void BPF_ServerAddHealth(float _fHealth);
    float BPF_GetMaxHealth();
    float BPF_GetBaseMaxHealth();
    void BPF_ApplyDamageOnAvoid(class AActor* _Instigator);
    void BPF_ApplyDamage(float _fDamage);
}; // Size: 0x150

class UHealthCondition : public UBaseActorCondition
{
    EOperationType m_eOperation;                                                      // 0x0028 (size: 0x1)
    float m_fValue;                                                                   // 0x002C (size: 0x4)

}; // Size: 0x30

class UHeightDifferenceWithActorCondition : public UBaseActorTargetCondition
{
    class UCurveFloat* m_HeightDiffCurve;                                             // 0x0028 (size: 0x8)

}; // Size: 0x30

class UHitAchievementUnlockCondition : public UWGAchievementUnlockCondition
{

    void BPE_OnMCHit(class AFightingCharacter* _fightingCharHitted, const FHitDescription& _hitDescription);
    void BPE_OnAIHit(class AFightingCharacter* _fightingCharHitted, const FHitDescription& _hitDescription);
}; // Size: 0x1D0

class UHitActionLauncher : public UObject
{
    FBaseActorTargetConditionInstance m_hitActionCondition;                           // 0x0028 (size: 0x10)

}; // Size: 0x38

class UHitAnimRequest : public UObject
{

    bool BPF_FindCustomHitAnimation(const FHitAnimsPerDataTableContainer& _data, const FHitRequest& _request, const FImpactResult& _Impact, FHittedAnimContainer& _result);
    TArray<class UAnimSequence*> BPE_GetHitDeathAnimations();
    void BPE_GetHitAnimation(const FHitRequest& _request, const FImpactResult& _Impact, class AFightingCharacter* _defender, FHittedAnimContainer& _result, FAnimContainer& _weaponResult);
}; // Size: 0x28

class UHitBoxComponent : public USceneComponent
{
    FHitBoxComponent_OnHit m_OnHit;                                                   // 0x0208 (size: 0x10)
    void OnHit(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FImpactResult& _Impact);
    FHitBoxComponent_OnAnyHit m_OnAnyHit;                                             // 0x0230 (size: 0x10)
    void OnAnyHit();
    float m_fMinVelocity;                                                             // 0x0240 (size: 0x4)
    bool m_bRecoveryAfterDelay;                                                       // 0x0244 (size: 0x1)
    float m_fRecoveryAfterDelay;                                                      // 0x0248 (size: 0x4)
    bool m_bRecoveryOnLeaveZone;                                                      // 0x024C (size: 0x1)
    FHitBox m_HitBox;                                                                 // 0x0250 (size: 0x298)
    TMap<TWeakObjectPtr<AActor>, float> m_Recoveries;                                 // 0x05A8 (size: 0x50)

    void OnHit__DelegateSignature(const FHitResult& _hitResult, const FHitRequest& _hitRequest, const FImpactResult& _Impact);
    void OnAnyHit__DelegateSignature();
    void BPF_SetOwningCharacter(class AFightingCharacter* _owningCharacter);
}; // Size: 0x600

class UHitBoxCondition : public UObject
{
}; // Size: 0x28

class UHitBoxGenericCondition : public UHitBoxCondition
{
    FBaseActorTargetConditionInstance m_condition;                                    // 0x0028 (size: 0x10)

}; // Size: 0x38

class UHitBoxMetaData : public UObject
{
}; // Size: 0x28

class UHitComponent : public UActorComponent
{
    FHitComponentOnHitDetection OnHitDetection;                                       // 0x00E0 (size: 0x10)
    void HittedDynamicDelegate(const FHitDescription& HitDescription);
    class UCurveFloat* m_Curve;                                                       // 0x0120 (size: 0x8)
    float m_fHitStrength;                                                             // 0x0128 (size: 0x4)
    FGameplayTagContainer m_Tags;                                                     // 0x0138 (size: 0x20)
    FGameplayTagContainer m_RequiredHitBoxTags;                                       // 0x0158 (size: 0x20)
    FGameplayTagContainer m_IgnoreHitBoxTags;                                         // 0x0178 (size: 0x20)
    bool m_bCriticalHitEvenOnResilience;                                              // 0x0198 (size: 0x1)
    float m_fDamageMultiplierCriticalHit;                                             // 0x019C (size: 0x4)
    float m_fGuardDamageMultiplierCriticalHit;                                        // 0x01A0 (size: 0x4)
    float m_fStunTimeMultiplierCriticalHit;                                           // 0x01A4 (size: 0x4)
    int32 m_iAdditionnalFreezeFramesCriticalHit;                                      // 0x01A8 (size: 0x4)
    int32 m_iFreezeFramesLethalHit;                                                   // 0x01AC (size: 0x4)
    class UCurveFloat* m_DefaultKnockBackDynamic;                                     // 0x01B0 (size: 0x8)
    float m_fHittedTrackingDuration;                                                  // 0x01B8 (size: 0x4)
    float m_fHittedTrackingMaxAngleFromTarget;                                        // 0x01BC (size: 0x4)
    float m_fHittedFrozenPlayRate;                                                    // 0x01C0 (size: 0x4)
    float m_fHittedFrontQuadrant;                                                     // 0x01C4 (size: 0x4)
    float m_fLowHeightDiffCapsuleHalfHeightFactorThresold;                            // 0x01C8 (size: 0x4)
    float m_fHighHeightDiffCapsuleHalfHeightFactorThresold;                           // 0x01CC (size: 0x4)
    class UHittedDB* m_HittedDB;                                                      // 0x01D0 (size: 0x8)
    float m_fBrokenGuardDisarmCoef;                                                   // 0x01E8 (size: 0x4)
    float m_fDisarmGaugeRegenRate;                                                    // 0x01EC (size: 0x4)
    float m_fDisarmGaugeRegenRateWhileHoldingWeapon;                                  // 0x01F0 (size: 0x4)

    void OnDangerStateChangedCallback(EDangerStates _ePreviousDangerState, EDangerStates _eNewDangerState);
    void HittedDynamicDelegate__DelegateSignature(const FHitDescription& HitDescription);
    void BPF_ToggleInfiniteDamageOnHit(bool _bActivate);
    void BPF_SetStructureOnly(bool _bUseStructureOnly);
    void BPF_ResetHitAnimRequestToDefault();
    void BPF_OverrideHitAnimRequest(TSubclassOf<class UHitAnimRequest> _hitAnimRequest);
    FGameplayTagContainer BPF_GetTags();
    class UHittedDB* BPF_GetHittedDB();
    class UHitAnimRequest* BPF_GetHitAnimRequest();
    void BPF_GenerateFakeImpact(const FHitResult& _hitResult, const FHitRequest& _inHitRequest);
    bool BPE_ValidateHit(const FHitResult& _hitResult, const FHitRequest& _inHitRequest);
    void BPE_OnHit(const FHitDescription& _description);
}; // Size: 0x258

class UHitDefenseResultHelpers : public UBlueprintFunctionLibrary
{

    EAvoidType BPF_GetAvoidType(const FHitDefenseResult& _defenseResult);
    class UAvoidPropertyDB* BPF_GetAvoidDB(const FHitDefenseResult& _defenseResult);
}; // Size: 0x28

class UHitOrderService : public UOrderService
{
    FHitBox m_Hit;                                                                    // 0x0028 (size: 0x298)
    bool m_bFreezeInstigator;                                                         // 0x02C0 (size: 0x1)
    bool m_bIgnoreOwner;                                                              // 0x02C1 (size: 0x1)
    bool m_bOrderTargetIsInstigator;                                                  // 0x02C2 (size: 0x1)
    bool m_bIgnoreTarget;                                                             // 0x02C3 (size: 0x1)
    bool m_bPersistIgnoredActorsFromPreviousOrderService;                             // 0x02C4 (size: 0x1)
    bool m_bUseBoneLocationFromAnim;                                                  // 0x02C5 (size: 0x1)
    bool m_bUpdateHitboxVelocity;                                                     // 0x02C6 (size: 0x1)

    void HitIgnoredActors__DelegateSignature(TArray<class AActor*>& _ignoredActors);
    class AActor* BPE_GetInstigator(const FBPOrderServiceInstance& _orderServiceInstance);
    void BPE_GetIgnoredActors(const FBPOrderServiceInstance& _orderServiceInstance, TArray<class AActor*>& _actors);
    void BPE_GetHitBoxWithLocation(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox, FHitResult& _envLocation, FVector& _location);
    void BPE_GetHitBox(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox, FHitResult& _envLocation);
}; // Size: 0x2C8

class UHitboxHelper : public UBlueprintFunctionLibrary
{

    void BPF_SetHitboxStructureDamage(const FHitBox& _hitbox, FHitBox& _outHitbox, float _fDamage);
    void BPF_SetHitboxRow(FHitBox& _outHitbox, const FHitboxDataRow& _dataRow);
    void BPF_SetHitboxDamageOnRef(FHitBox& _hitbox, float _fDamage);
    void BPF_SetHitboxDamage(const FHitBox& _hitbox, FHitBox& _outHitbox, float _fDamage);
    void BPF_MirrorAvoidDefenseMatrix(int32 _iDefenseMatrix, int32& _iOutResult, bool _bMirror);
    class UHitBoxMetaData* BPF_GetHitboxMetaDataInstance(const FHitBoxMetaDataClassInstance& _instance);
    FHitboxDataRow BPF_GetHitboxDataRow(const FHitBox& _hitbox);
}; // Size: 0x28

class UHittedAnimHelper : public UBlueprintFunctionLibrary
{

    void BPF_MakeGenericHitAnimWithOrderType(FHittedAnimContainer& _animContainer, FAnimContainer _fightingStateLoopAnim, const FAnimContainer& _anim, const FOrderType& _OrderType);
    void BPF_MakeGenericHitAnim(FHittedAnimContainer& _animContainer, FAnimContainer _fightingStateLoopAnim, const FAnimContainer& _anim, TSubclassOf<class UOrderHittedGenericDB> _order);
    float BPF_GetHitAnimDuration(const FHittedAnimContainer& _animContainer, const FImpactResult& _Impact);
}; // Size: 0x28

class UHittedBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UHittedDB : public UInheritedDataAsset
{
    float m_fLowDistanceFromRoot;                                                     // 0x0038 (size: 0x4)
    float m_fHighDistanceFromRoot;                                                    // 0x003C (size: 0x4)
    float m_fHalfAngleSouth;                                                          // 0x0040 (size: 0x4)
    float m_fItemHalfAngleSouth;                                                      // 0x0044 (size: 0x4)
    float m_fAutoKillTimeMax;                                                         // 0x0048 (size: 0x4)
    float m_fAutoKillHeightMax;                                                       // 0x004C (size: 0x4)
    float m_fMediumFallHeightThreshold;                                               // 0x0050 (size: 0x4)
    float m_fHeavyFallHeightThreshold;                                                // 0x0054 (size: 0x4)
    float m_fFallMaxHeight;                                                           // 0x0058 (size: 0x4)
    float m_fDamagePercentAssistDetectionThreshold;                                   // 0x005C (size: 0x4)
    float m_fDamagePercentKillDetectionThreshold;                                     // 0x0060 (size: 0x4)
    float m_fDamageHistoryNotInFightTimeOut;                                          // 0x0064 (size: 0x4)
    float m_fDamageHistoryOutOfRangeTimeOut;                                          // 0x0068 (size: 0x4)
    float m_fDamageHistoryDeadTimeOut;                                                // 0x006C (size: 0x4)
    float m_fDamageHistoryInvalidTimeOut;                                             // 0x0070 (size: 0x4)
    bool m_bTimeSinceLastHitPrevails;                                                 // 0x0074 (size: 0x1)
    bool m_bLongestStunPrevailsBetweenHits;                                           // 0x0075 (size: 0x1)
    bool m_bKnockbackDurationBoundToAnimation;                                        // 0x0076 (size: 0x1)
    bool m_bHitDamagesDetailsDebugActivated;                                          // 0x0077 (size: 0x1)
    class UAvailabilityLayerData* m_HitRecoveryAvailability;                          // 0x0078 (size: 0x8)
    TSubclassOf<class UHitAnimRequest> m_HitAnimationRequest;                         // 0x0080 (size: 0x8)
    TSubclassOf<class UFallHitRequest> m_FallHitRequest;                              // 0x0088 (size: 0x8)
    FAnimContainer m_FallAnim;                                                        // 0x0090 (size: 0x18)

}; // Size: 0xA8

class UHittedDeathNotify : public UAnimNotify
{
    class UAnimSequence* m_DeathAnimation;                                            // 0x0038 (size: 0x8)
    FSCUserDefinedEnumHandler m_DeathAnimType;                                        // 0x0040 (size: 0x50)
    bool m_bMirrorDeathAnimation;                                                     // 0x0090 (size: 0x1)
    bool m_bUnspawnNow;                                                               // 0x0091 (size: 0x1)
    uint32 m_uiDeathTriggeredConditionMask;                                           // 0x0094 (size: 0x4)

}; // Size: 0x98

class UHittedDeathOrderService : public UOrderService
{
    class UAnimSequence* m_DeathAnimation;                                            // 0x0028 (size: 0x8)
    FSCUserDefinedEnumHandler m_DeathAnimType;                                        // 0x0030 (size: 0x50)
    bool m_bMirrorDeathAnimation;                                                     // 0x0080 (size: 0x1)
    bool m_bUnspawnNow;                                                               // 0x0081 (size: 0x1)
    uint32 m_uiDeathTriggeredConditionMask;                                           // 0x0084 (size: 0x4)

}; // Size: 0x88

class UHittedOrderService : public UOrderService
{
    FHittedServiceInfos m_Infos;                                                      // 0x0030 (size: 0x1E8)
    FHitBox m_Hit;                                                                    // 0x0218 (size: 0x298)
    bool m_bFreezeInstigator;                                                         // 0x04B0 (size: 0x1)
    EOrderType m_eInstigatorOrderType;                                                // 0x04B1 (size: 0x1)

    class UAttackPropertiesResistanceDB* BPE_GetSpecialResistanceDB(const FBPOrderServiceInstance& _orderServiceInstance);
    FHittedAnimContainer BPE_GetLethalHittedAnim(const FBPOrderServiceInstance& _orderServiceInstance);
    void BPE_GetHitRequest(const FBPOrderServiceInstance& _orderServiceInstance, FHitRequest& _hitRequest, FHitResult& _hitResult);
    void BPE_GetHitBox(const FBPOrderServiceInstance& _orderServiceInstance, FHitBox& _hitbox, FHitResult& _envLocation);
    FAnimContainer BPE_GetFightingStateRecoveryAnim(const FBPOrderServiceInstance& _orderServiceInstance);
    FAnimContainer BPE_GetFightingStateLoopAnim(const FBPOrderServiceInstance& _orderServiceInstance);
}; // Size: 0x4B8

class UHittedOrderServiceNotifyState : public UOrderServiceNotifyState
{
    FHittedServiceInfos m_Infos;                                                      // 0x0070 (size: 0x1E8)

}; // Size: 0x258

class UHoldLockMove : public USCAnimNotifyState
{
}; // Size: 0x48

class UIKAnimOnSelfNotifyState : public UIKProfileAnimNotifyState
{
}; // Size: 0x150

class UIKProfileAnimNotifyState : public USCAnimNotifyState
{
    FSCUserDefinedEnumHandler m_Profile;                                              // 0x0050 (size: 0x50)
    FSCUserDefinedEnumHandler m_CrossFadeOutWithProfile;                              // 0x00A0 (size: 0x50)
    FIKProfileBlendInfos m_BoneLocationBlend;                                         // 0x00F0 (size: 0x1C)
    FIKProfileBlendInfos m_LimbRotationBlend;                                         // 0x010C (size: 0x1C)
    FFloatRange m_ImpactTime;                                                         // 0x0128 (size: 0x10)
    FBoneReference m_TargetBoneReference;                                             // 0x0138 (size: 0x10)
    bool m_bResetIKAlphaOnStop;                                                       // 0x0148 (size: 0x1)
    bool m_bRotateImpactOrientation;                                                  // 0x0149 (size: 0x1)
    bool m_bForceBoneRotation;                                                        // 0x014A (size: 0x1)
    float m_fForceBoneRotationBlendDuration;                                          // 0x014C (size: 0x4)

}; // Size: 0x150

class UIKSubAnimInstance : public USCAnimInstance
{
    FName m_SlopeCurveName;                                                           // 0x0628 (size: 0x8)
    FRotator m_FloorAngleToTarget;                                                    // 0x0630 (size: 0xC)

    void BPF_BindRepartitionProperty(FPropertyFloorBoneRepartition& _property);
    void BPF_BindProperty(FIKPropertyEvaluation& _fProperty, uint8 _uiEnum);
}; // Size: 0x730

class UIdleDB : public UDataAsset
{
    float m_fReorientationTime;                                                       // 0x0030 (size: 0x4)
    float m_fReorientationTimeForEarlyBlendOutFromAttack;                             // 0x0034 (size: 0x4)

}; // Size: 0x38

class UInGameMenuAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UInGameNotification : public UHUDUserWidget
{
    TArray<class UBaseNotification*> m_NotificationStack;                             // 0x0398 (size: 0x10)

    void OnMenuChanged(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    void BPF_ShowNextNotification();
    void BPF_PushNotification(class UBaseNotification* _notification);
    void BPF_PopNotification();
    void BPF_EnableOpenMenu();
    void BPF_DisableOpenMenu();
    void BPF_ClearPendingNotificationOfTypes(TArray<class UClass*> _NotificationTypes);
    void BPE_HideCurrentNotification();
    void BPE_HandleProgressionRewardNotification(const class UProgressionRewardNotification* _rewardNotification);
    void BPE_HandleProgressionDoorNotification(const class UProgressionDoorNotification* _progressionDoorNotification);
    void BPE_HandleNotification(const class UBaseNotification* _messageNotification);
    void BPE_HandleMessageNotification(const class UMessageNotification* _messageNotification);
    void BPE_HandleLevelUpNotification(const class ULevelUpNotification* _levelUpNotification);
    void BPE_HandleAttackProgressNotification(const class UAttackProgressNotification* _attackProgressNotification);
    class UAttackProgressNotification* BPE_FindOrCreateAttackProgressNotification(const FName& _attackName);
}; // Size: 0x3A8

class UInGameSequenceReplication : public UReplayReplicationComponentBase
{
    TArray<FInGameSequenceReplicationInfo> m_InGameSequenceReplicationInfo;           // 0x0128 (size: 0x10)

    void OnRep_InGameSequenceReplicationInfo();
    void BPF_RecordInGameSequence(const class UObject* _worldContextObject, class ULevelSequence* _sequence, FMovieSceneSequencePlaybackParams _playbackParams, ESequenceState _eState);
}; // Size: 0x150

class UInputAvailabilityUserWidget : public USCUserWidget
{
    InputAction m_eInputAction;                                                       // 0x0310 (size: 0x1)

    void BPF_SetInputAvailabilityOverride(FBPF_SetInputAvailabilityOverrideDelegate _delegate);
    void BPE_OnAvailabilityUpdated(bool _bAvailable);
}; // Size: 0x338

class UInputContextData : public UDataAsset
{
    InputContext m_contextType;                                                       // 0x0030 (size: 0x1)
    bool m_disableOther;                                                              // 0x0031 (size: 0x1)
    bool m_bPauseOther;                                                               // 0x0032 (size: 0x1)
    TMap<class InputAction, class FInputActionData> m_InputActionSettings;            // 0x0038 (size: 0x50)
    TArray<class UGenericInputData*> m_inputActions;                                  // 0x0088 (size: 0x10)
    TArray<FInputMappingGroup> m_DefaultGamepadMapping;                               // 0x0098 (size: 0x10)
    TArray<FInputMappingGroup> m_DefaultKeyboadMapping;                               // 0x00A8 (size: 0x10)

    void CreateOwners();
    void ClearUnUsedInputs();
    void Clear();
    void Build();
}; // Size: 0xB8

class UInputData : public UGenericInputData
{
    FName m_unrealAction;                                                             // 0x00C0 (size: 0x8)
    FInputBehaviourStruct m_BehaviourStruct;                                          // 0x00C8 (size: 0xC)

}; // Size: 0xD8

class UInputHelpers : public UBlueprintFunctionLibrary
{

    float BPF_GetInputActionPressedDurationNormalized(class ASCPlayerController* _playerController, InputAction _eInputAction);
}; // Size: 0x28

class UInputManager : public UObject
{
    class UInputsDB* m_inputsDB;                                                      // 0x0028 (size: 0x8)
    TArray<class UInputPad*> m_pads;                                                  // 0x0090 (size: 0x10)

    void BPF_ResetAction(class UObject* _requester, const class ASCPlayerController* _playerController, InputAction _eInputAction);
    void BPF_FlushAction(class UObject* _requester, const class ASCPlayerController* _playerController, InputAction _eInputAction);
    void BPF_ConsumeAction(class UObject* _requester, const class ASCPlayerController* _playerController, InputAction _eInputAction);
}; // Size: 0xA8

class UInputManagerHelpers : public UBlueprintFunctionLibrary
{

    class UInputPad* BPF_GetControllerInputPad(class ASCPlayerController* _playerController);
    FVector2D BPF_GetActionVectorValue(class ASCPlayerController* _player, InputAction _eAction, bool _bRaw);
    float BPF_GetActionValue(const class ASCPlayerController* _player, InputAction _eAction, bool _bRaw);
}; // Size: 0x28

class UInputMappingHelpers : public UBlueprintFunctionLibrary
{

    bool ValidateMappingForPreset(const FInputMappingProfileData& _mappingContext, const FInputMappingGroup& _context, const FInputPresetsEnumHandler& _preset, InputContext _eContext, const FInputMappingData& _mapping, TArray<FMappingValidationError>& _outErrors, bool _bDetectCollisions);
    bool EqualEqual_MappingID(const FMappingID& _ID1, const FMappingID& _ID2);
    bool EqualEqual_MappingData(const FInputMappingData& _data1, const FInputMappingData& _data2);
    FText Conv_MappingIDToText(const FMappingID& _ID);
    FMappingID Conv_InputPresetsEnumHandlerToMappingID(const FInputPresetsEnumHandler& _handler, InputContext _eContext);
    FMappingID Conv_InputActionToMappingID(InputAction _action, InputContext _eContext);
    FInputMappingProfileEnumHandler Conv_EnumToProfileID(const FSCUserDefinedEnumHandler& _ID);
    bool BPF_ValidateMapping(const FInputMappingProfileData& _mappingContext, const FMappingID& _item, const FInputMappingData& _mapping, TArray<FMappingValidationError>& _outErrors, bool _bDetectCollisions);
    bool BPF_ValidateCompleteMapping(const FInputMappingProfileData& _mapping, TArray<FMappingValidationError>& _outErrors);
    bool BPF_SetMapping(FInputMappingProfileData& _inOutMappingContext, const FMappingID& _item, const FInputMappingData& _mapping);
    void BPF_SetHoldToggleEnabled(bool _bActivated);
    void BPF_SetCurrentMappingProfile(class ASCPlayerController* _controller, const FInputMappingProfileEnumHandler& _profile, bool _bGamePad);
    void BPF_SaveCustomInputMapping(class ASCPlayerController* _controller, FInputMappingProfileData& _mappingContext, bool _bGamePad);
    void BPF_ResolveConflicts(FInputMappingProfileData& _inOutMappingContext, const FMappingID& _item, TArray<FMappingID>& _outResettedItems);
    FMappingID BPF_MakeMappingID(const FInputPresetsEnumHandler& _PresetID, InputAction _eAction, InputContext _eContext);
    bool BPF_IsValid(const FInputMappingData& _data, const FInputMappingProfileData& _mappingContext);
    bool BPF_IsEmpty(const FInputMappingData& _data, const FInputMappingProfileData& _mappingContext);
    bool BPF_IsDependencyBrokenWithPreset(const FInputMappingProfileData& _inOutRemapping, const FMappingID& _ID);
    void BPF_GetMappingResult(const FInputMappingProfileData& _mappingContext, const FMappingID& _ID, FInputMappingNode& _outResultNode);
    void BPF_GetMappingProfiles(TMap<class FInputMappingProfileEnumHandler, class UInputMappingProfileDB*>& _outResult, bool _bGamePad);
    class UInputMappingProfileDB* BPF_GetMappingProfileDB(const FInputMappingProfileEnumHandler& _profileID);
    void BPF_GetMapping(const FInputMappingProfileData& _mappingContext, const FMappingID& _ID, FInputMappingData& _outMapping);
    EKeyboardLayout BPF_GetKeyboardLayout();
    bool BPF_GetHoldToggleEnabled();
    void BPF_GetDefaultMapping(const class ASCPlayerController* _controller, FInputMappingProfileData& _mappingContext, bool _bGamePad);
    void BPF_GetDefaultInputMapping(class ASCPlayerController* _controller, const FMappingID& _ID, FInputMappingData& _outMapping, bool _bGamePad);
    FInputMappingProfileEnumHandler BPF_GetCurrentMappingProfile(bool _bGamePad);
    void BPF_GetCurrentMapping(FInputMappingProfileData& _outMappingContext, bool _bGamePad);
    void BPF_GetAvailableInputDatas(const FInputMappingProfileData& _mappingContext, bool _bGamePad, const FMappingID& _mappingID, const FInputMappingData& _mappingData, TArray<class UGenericInputData*>& _outAvailableInputData);
    FInt32Range BPF_GetAuthorizedCombinationCount(const FMappingID& _mappingID, bool _bGamePad);
    bool BPF_CreateMappingFromSlots(const FInputMappingProfileData& _inMappingContext, const FMappingID& _item, const TArray<FInputMappingKeySlotContainer>& _slots, FInputMappingData& _outMapping, bool _bBreakDependencies, bool _bGamePad);
    void BPF_BuildContextFromProfile(FInputMappingProfileData& _outMappingContext, FInputMappingProfileEnumHandler _profile);
    void BPF_BreakMappingID(const FMappingID& _mappingID, bool& _bOutUsePreset, InputAction& _eOutAction, FInputPresetsEnumHandler& _eOutPreset);
    FInputMappingData BPF_BreakDependencyWithPreset(const FInputMappingProfileData& _inOutMappingContext, const FInputMappingData& _mapping);
    void BPF_ApplyInputRemapping(class ASCPlayerController* _controller, const FInputMappingProfileData& _mappingContext);
    void BPF_ApplyCurrentInputMapping(class ASCPlayerController* _controller);
}; // Size: 0x28

class UInputMappingPresets : public UDataAsset
{
    TMap<class FInputPresetsEnumHandler, class FInputMappingData> m_Presets;          // 0x0030 (size: 0x50)

}; // Size: 0x80

class UInputMappingProfileContextDB : public UDataAsset
{
    TArray<FInputMappingGroup> m_MappingGroups;                                       // 0x0030 (size: 0x10)

    FString BPF_GetInputMappingDesc(const FInputMapping& _mapping);
}; // Size: 0x40

class UInputMappingProfileDB : public UDataAsset
{
    bool m_bGamepadMapping;                                                           // 0x0030 (size: 0x1)
    class UInputMappingPresets* m_PresetDB;                                           // 0x0038 (size: 0x8)
    class UInputMappingProfileUIData* m_UIData;                                       // 0x0040 (size: 0x8)
    TMap<class InputContext, class UInputMappingProfileContextDB*> m_MappingPerContext; // 0x0048 (size: 0x50)

}; // Size: 0x140

class UInputMappingProfileUIData : public UObject
{
}; // Size: 0x28

class UInputMappingWidget : public USCUserWidget
{
    FInputMappingWidget_OnWaitingForRemappingInput m_OnWaitingForRemappingInput;      // 0x0310 (size: 0x10)
    void OnInteractionWithRemappingFieldDelegate(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    FInputMappingWidget_OnFocusReceived m_OnFocusReceived;                            // 0x0320 (size: 0x10)
    void OnInteractionWithRemappingFieldDelegate(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    FInputMappingWidget_OnFocusLost m_OnFocusLost;                                    // 0x0330 (size: 0x10)
    void OnInteractionWithRemappingFieldDelegate(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    FString m_MappingStringName;                                                      // 0x0340 (size: 0x10)
    FString m_MappingNameStringNegativeScale;                                         // 0x0350 (size: 0x10)
    FString m_MappedKeyName;                                                          // 0x0360 (size: 0x10)
    FString m_MappedKeyNameNegativeScale;                                             // 0x0370 (size: 0x10)
    FAsyncTextureStruct m_KeyInputTexture;                                            // 0x0380 (size: 0x28)
    FAsyncTextureStruct m_KeyInputTextureNegativeScale;                               // 0x03A8 (size: 0x28)
    bool m_bIsMappingFieldForAxis;                                                    // 0x03D0 (size: 0x1)
    bool m_bForceDisplayAsSingleField;                                                // 0x03D1 (size: 0x1)
    bool m_bCheckDuplicateKey;                                                        // 0x03D2 (size: 0x1)
    EMappableFieldScaleTypes m_eSelectedFieldScaleType;                               // 0x03D3 (size: 0x1)
    EMappableFieldScaleTypes m_eFocusedFieldScaleType;                                // 0x03D4 (size: 0x1)
    ERemappingAllowedInputTypes m_eRemappingAllowedType;                              // 0x03D5 (size: 0x1)

    void OnInteractionWithRemappingFieldDelegate__DelegateSignature(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    void BPF_WaitingKeyInput(EMappableFieldScaleTypes _eScaleType);
    void BPF_SetRemappingButton(class UButtonUserWidget* _remappingButton, EMappableFieldScaleTypes _eScaleType);
    void BPF_OnRemappingFieldGettingFocusLost(EMappableFieldScaleTypes _eScaleType);
    void BPF_OnRemappingFieldGettingFocused(EMappableFieldScaleTypes _eScaleType);
    FName BPF_GetActionName();
    void BPE_ShouldDisplayTextureKeyRatherThanTextKeyForKeyboard(bool _bUseTexture, EMappableFieldScaleTypes _eScaleType);
    void BPE_OnRemappingStarted(bool _bIsKeyboardRemapping);
    void BPE_OnRemappingFinished(bool _bIsKeyboardRemapping, FKey _newMappingKey);
}; // Size: 0x3F0

class UInputMappingWidgetData : public UWidgetData
{
    FInputMappingProfileData m_InputContext;                                          // 0x0048 (size: 0xA8)
    EInputMappingForceController m_eControllerType;                                   // 0x00F0 (size: 0x1)

}; // Size: 0xF8

class UInputPad : public UObject
{

    class UGenericInputData* BPF_GetInputDataForAction(InputAction _eAction);
}; // Size: 0x840

class UInputSequenceData : public UGenericInputData
{
    TArray<FInputSequenceStep> m_Sequence;                                            // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class UInputsDB : public UDataAsset
{
    class UInputContextData* m_contexts;                                              // 0x0030 (size: 0x60)
    float m_fStartStabilizationDuration;                                              // 0x0090 (size: 0x4)
    float m_fStopStabilizationDuration;                                               // 0x0094 (size: 0x4)
    float m_fThresholdInputDiffForStabilisation;                                      // 0x0098 (size: 0x4)
    float m_fStickThresholdBetweenV1V2;                                               // 0x009C (size: 0x4)

}; // Size: 0xA0

class UInputsMappingMenu : public UMenuWidget
{
    class UMappableInputsDB* m_MappableInputsDB;                                      // 0x03D8 (size: 0x8)
    TSubclassOf<class UInputMappingWidget> m_InputMappingWidgetClass;                 // 0x03E0 (size: 0x8)
    FMargin m_sectionTitleMargin;                                                     // 0x03E8 (size: 0x10)
    FSlateFontInfo m_sectionTitleFont;                                                // 0x03F8 (size: 0x58)
    FLinearColor m_sectionTitleColorAndOpacity;                                       // 0x0450 (size: 0x10)
    FSlateBrush m_sectionTitleBrush;                                                  // 0x0460 (size: 0x88)
    bool m_bIsRemappingOccured;                                                       // 0x04E8 (size: 0x1)

    void OnRemappingStarted(FName _ActionName, EMappableFieldScaleTypes _eScaleType);
    void OnRemappingFieldFocusLost(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    void OnRemappingFieldFocused(FName _ActionName, EMappableFieldScaleTypes _ScaleType);
    void OnGamepadControllerTypeChanged(FName _gamepadControllerType);
    void BPF_UpdateRemappingKeyList();
    void BPF_UpdateMappingListKeyIcons();
    void BPF_RestoreDefaultMapping();
    bool BPF_RemoveMapping(FName _ActionName);
    bool BPF_PerformKeyRemapping(FName _ActionName, FInputKeyMappingHandler _NewKeyMapping);
    bool BPF_IsWaitingInputForRemapping();
    FText BPF_GetRemappingFailMessage(ERemappingFinishedStates _finishState);
    void BPF_FillRemappingKeyList(class UPanelWidget* _KeyContainer, ERemappingAllowedInputTypes _eRemappingAllowedInputTypes, class UButtonUserWidget* _LastRemappingFieldNextButton);
    void BPF_Cancel();
    void BPF_BuildRemappingListOuterNavigation(class UButtonUserWidget* _LastRemappingFieldNextButton);
    void BPF_BuildRemappingFieldsListExplicitNavigation(class UButtonUserWidget* _LastRemappingFieldNextButton);
    void BPF_ApplyMapping(ERemappingAllowedInputTypes _eRemappingInputTypeToApply);
    void BPE_OnRemappingSucceed();
    void BPE_OnRemappingStarted();
    void BPE_OnRemappingFieldLostFocus(class UInputMappingWidget* _focusedRemappingWidget, EMappableFieldScaleTypes _eScaleType);
    void BPE_OnRemappingFieldFocused(class UInputMappingWidget* _focusedRemappingWidget, EMappableFieldScaleTypes _eScaleType);
    void BPE_OnRemappingFailed(ERemappingFinishedStates _eRemappingStates, FKey _keyPressed);
    void BPE_OnKeyPressedForRemapping(FName _ActionName, FInputKeyMappingHandler _NewKeyMapping, bool _bIsKeyboardRemapping);
}; // Size: 0x618

class UIntStatTextBlock : public UTextBlock
{
    int32 Stat;                                                                       // 0x02A8 (size: 0x4)
    int32 StatIncrement;                                                              // 0x02AC (size: 0x4)
    FIntStatTextBlockStatDelegate StatDelegate;                                       // 0x02B0 (size: 0x10)
    int32 GetInt32();
    int32 CompareStat;                                                                // 0x02C0 (size: 0x4)
    FIntStatTextBlockCompareStatDelegate CompareStatDelegate;                         // 0x02C4 (size: 0x10)
    int32 GetInt32();
    class UColorComparisonProfile* m_ColorComparisonProfile;                          // 0x02D8 (size: 0x8)
    bool m_bHightIsBetter;                                                            // 0x02E0 (size: 0x1)
    bool m_bCanBeNegative;                                                            // 0x02E1 (size: 0x1)

}; // Size: 0x320

class UInteractionDetectionComponent : public UActorComponent
{
    FBaseActorTargetConditionInstance m_CandidateObjectCondition;                     // 0x00D0 (size: 0x10)
    float m_fAngleThresholdWalking;                                                   // 0x00E0 (size: 0x4)
    float m_fAngleThresholdRunning;                                                   // 0x00E4 (size: 0x4)
    float m_fCatchFrontRangeWalking;                                                  // 0x00E8 (size: 0x4)
    float m_fCatchBackRangeWalking;                                                   // 0x00EC (size: 0x4)
    float m_fCatchFrontRangeRunning;                                                  // 0x00F0 (size: 0x4)
    float m_fCatchBackRangeRunning;                                                   // 0x00F4 (size: 0x4)
    float m_fInteractionHintDist;                                                     // 0x0108 (size: 0x4)
    bool m_bShowOnlyVisibleHint;                                                      // 0x010C (size: 0x1)
    bool m_bShowOnlyUsableHint;                                                       // 0x010D (size: 0x1)
    TArray<class UInteractionObjectComponent*> m_interactionHintToShow;               // 0x0118 (size: 0x10)
    TMap<class UInteractionObjectComponent*, class FInteractionHintInfo> m_interactionHintInfos; // 0x0128 (size: 0x50)

    TMap<class UInteractionObjectComponent*, class FInteractionHintInfo> BPF_GetInteractionHintInfos();
    TArray<class UInteractionObjectComponent*> BPF_GetInteractionHintComponent();
    class AActor* BPF_GetCurrentInteractiveObject();
    class UInteractionObjectComponent* BPF_GetCurrentInteractiveComponent();
    void BPF_DisableInteractionWithObjects(TSubclassOf<class AActor> _actorToDisable);
    void BPF_AllowInteractionWithObjects(TSubclassOf<class AActor> _actorToEnable);
}; // Size: 0x190

class UInteractionObjectComponent : public UActorComponent
{
    FInteractionObjectComponentOnUseInteractionObject OnUseInteractionObject;         // 0x00C8 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    FInteractionObjectComponentOnUseInteractionObjectFailed OnUseInteractionObjectFailed; // 0x00D8 (size: 0x10)
    void FailedUseObject(class APlayerController* PlayerController, FText FailReason);
    FInteractionObjectComponentOnBecomeCurrentInteractionObject OnBecomeCurrentInteractionObject; // 0x00E8 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    FInteractionObjectComponentOnNoLongerCurrentInteractionObject OnNoLongerCurrentInteractionObject; // 0x00F8 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    FInteractionObjectComponentOnTextChanged OnTextChanged;                           // 0x0108 (size: 0x10)
    void OnTextStructChanged();
    FInteractionObjectComponentOnUsableChanged OnUsableChanged;                       // 0x0118 (size: 0x10)
    void OnUsableChanged();
    bool m_bUseCustomWalkInteractionDist;                                             // 0x0128 (size: 0x1)
    float m_fCustomWalkInteractionDist;                                               // 0x012C (size: 0x4)
    bool m_bUseCustomRunInteractionDist;                                              // 0x0130 (size: 0x1)
    float m_fCustomRunInteractionDist;                                                // 0x0134 (size: 0x4)
    FInteractionObjectComponentOnDestroyComponent OnDestroyComponent;                 // 0x0138 (size: 0x10)
    void DestroyComponent(class UInteractionObjectComponent* _component);
    FCollisionProfileName m_InteractionTraceResponse;                                 // 0x014C (size: 0x8)
    bool m_bIgnoreOwnerOnHint;                                                        // 0x0154 (size: 0x1)
    bool m_bIgnoreChildActorsOnTrace;                                                 // 0x0155 (size: 0x1)
    class UOrderParams* m_orderParams;                                                // 0x0158 (size: 0x8)
    bool m_bVisibleOnlyWhenUsable;                                                    // 0x0160 (size: 0x1)
    bool m_bIsUsable;                                                                 // 0x0161 (size: 0x1)
    FInteractionTextStruct m_InteractionTextStruct;                                   // 0x0168 (size: 0x38)
    bool m_bUseLockedText;                                                            // 0x01A0 (size: 0x1)
    FText m_LockedText;                                                               // 0x01A8 (size: 0x18)
    bool m_bUseGenericUI;                                                             // 0x01C0 (size: 0x1)
    int32 m_iPriority;                                                                // 0x01C4 (size: 0x4)
    bool m_bUseInteractionHint;                                                       // 0x01C8 (size: 0x1)
    bool m_bOverrideInteractionHintDistance;                                          // 0x01C9 (size: 0x1)
    float m_fInteractionHintDistanceOverride;                                         // 0x01CC (size: 0x4)
    bool m_bConstraintToViewport;                                                     // 0x01D0 (size: 0x1)
    FVector2D m_vViewportConstraint;                                                  // 0x01D4 (size: 0x8)

    void UseObject__DelegateSignature(class APlayerController* PlayerController);
    void OnUsableChanged__DelegateSignature();
    void OnTextStructChanged__DelegateSignature();
    void ForceUse();
    void FailedUseObject__DelegateSignature(class APlayerController* PlayerController, FText FailReason);
    void DestroyComponent__DelegateSignature(class UInteractionObjectComponent* _component);
    void BPF_SetVisualComponent(class USceneComponent* _component);
    void BPF_SetMainDetectionPrimitive(class UPrimitiveComponent* _component);
    void BPF_SetIsUsable(bool _bCanUse);
    void BPF_SetInteractionTextStruct(const FInteractionTextStruct& _struct);
    bool BPF_IsUsingLockedText();
    bool BPF_IsUsable();
    class USceneComponent* BPF_GetVisualComponent();
    FText BPF_GetLockedText();
    FInteractionTextStruct BPF_GetInteractionTextStruct();
}; // Size: 0x1F0

class UInteractiveCamMenuWidget : public UMenuWidget
{
    class AInteractiveMenu* m_menuHandler;                                            // 0x03D8 (size: 0x8)

}; // Size: 0x3E0

class UInteractiveDestructionComponent : public UHealthComponent
{
    FInteractiveDestructionComponentOnStateChanged OnStateChanged;                    // 0x0168 (size: 0x10)
    void OnStateChanged(int32 _iNewState);
    int32 m_iHitByCharaDamage;                                                        // 0x0178 (size: 0x4)
    int32 m_iHitByObjectDamage;                                                       // 0x017C (size: 0x4)
    TArray<FDestructibleStateInfo> m_DestructibleStateInfo;                           // 0x0190 (size: 0x10)
    TArray<class UMeshComponent*> m_aOwnerMeshToSwap;                                 // 0x01A0 (size: 0x10)
    class UStaticMesh* m_DestroyedStaticMesh;                                         // 0x01B0 (size: 0x8)
    class USkeletalMesh* m_DestroyedSkeletalMesh;                                     // 0x01B8 (size: 0x8)
    FFXInfo m_ImpactParticleSystem;                                                   // 0x01C0 (size: 0x18)
    FFXInfo m_BreakParticleSystem;                                                    // 0x01D8 (size: 0x18)
    TArray<class UStaticMeshComponent*> m_SimChunks;                                  // 0x01F0 (size: 0x10)
    FVector m_vRandomSpreadAmplitude;                                                 // 0x0200 (size: 0xC)
    bool m_bUseCustomCollisionProfile;                                                // 0x020C (size: 0x1)
    FCollisionProfileName m_DeactivatedChunkCollisionProfile;                         // 0x0210 (size: 0x8)
    float m_fChunkDeactivationDelay;                                                  // 0x0218 (size: 0x4)

    void OnStateChanged__DelegateSignature(int32 _iNewState);
    void OnReplaySystemRecordingChanged(bool _bIsRecording);
    int32 BPF_GetStateIndex();
}; // Size: 0x230

class UInterchangeableInputData : public UGenericInputData
{
    TArray<FInterchangeableData> m_Inputs;                                            // 0x00C0 (size: 0x10)
    bool m_bUseActiveSubInputLifeSpan;                                                // 0x00D0 (size: 0x1)

}; // Size: 0xD8

class UInverseActorCondition : public UBaseActorCondition
{
    FBaseActorConditionInstance m_condition;                                          // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInverseActorTargetCondition : public UBaseActorTargetCondition
{
    FBaseActorTargetConditionInstance m_condition;                                    // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInvestigationPositionUpdaterService : public UBTService
{
}; // Size: 0x78

class UInvulnerabilityOrderService : public UOrderService
{
    bool m_bAcceptHitsFromTarget;                                                     // 0x0028 (size: 0x1)
    bool m_bResetGuardOnStart;                                                        // 0x0029 (size: 0x1)

    void BPE_ShouldDismissHit(const FBPOrderServiceInstance& _instance, const FHitResult& _result, FImpactResult& _Impact, const FHitRequest& _request, bool& _outShouldDismiss);
}; // Size: 0x30

class UIsInInteractiveDialogCondition : public UBaseActorCondition
{
    int32 m_iMaxChoicesCount;                                                         // 0x0028 (size: 0x4)

}; // Size: 0x30

class UIsInvolvedInDialogCondition : public UBaseActorCondition
{
}; // Size: 0x28

class UIsLockTargetCondition : public UBaseActorTargetCondition
{
}; // Size: 0x28

class UIsOnNavmeshCondition : public UBaseActorCondition
{
    float m_fDistTolerance;                                                           // 0x0028 (size: 0x4)

}; // Size: 0x30

class UIsOrderRunningService : public UBTService
{
    FBlackboardKeySelector m_BlackboardKey;                                           // 0x0070 (size: 0x28)
    EOrderType m_eOrder;                                                              // 0x0098 (size: 0x1)

}; // Size: 0xA0

class UIsTargetSlotCondition : public UBaseActorTargetCondition
{
    FSCUserDefinedEnumHandler m_Slot;                                                 // 0x0028 (size: 0x50)

}; // Size: 0x78

class UIsTargettedInfluenceTest : public UAIInfluenceTest
{
}; // Size: 0x50

class UItemsDB : public UDataAsset
{
    TArray<class UBaseItemData*> m_Items;                                             // 0x0030 (size: 0x10)

}; // Size: 0x40

class UJoinDialogAction : public UDialogActionBase
{
    FName m_ActorSentToDialog;                                                        // 0x0030 (size: 0x8)
    bool m_bPlayPrefightAnimations;                                                   // 0x0038 (size: 0x1)

    TArray<FName> GetActorOptions();
}; // Size: 0x40

class ULastTimeOnScreenTargetWeightEvaluation : public UBaseTargetWeightEvaluation
{
    FRuntimeFloatCurve m_TimeCurve;                                                   // 0x0028 (size: 0x88)

}; // Size: 0xB0

class ULevelSequenceAnimReplicationComponent : public UActorComponent
{
    TArray<FReplicatedSequencerAnimMontage> m_SequencerMontages;                      // 0x00D0 (size: 0x10)
    TArray<FReplicatedSequencerAnimMontagePosition> m_SequencerAnimMontagesPosition;  // 0x00E0 (size: 0x10)
    float m_fCinematicSlotWeight;                                                     // 0x00F0 (size: 0x4)
    int32 m_iPlayingSequenceId;                                                       // 0x00F4 (size: 0x4)

    void OnReplaySystemRecordingChanged(bool _bIsRecording);
    void OnRep_SequencerMontagesPosition();
    void OnRep_CinematicSlotWeight();
    void BPF_OnSequenceRegisterActor(class ALevelSequenceActor* _levelSequenceActor, class ULevelSequenceDirector* _director);
    void BPF_OnSequenceFinished(class ALevelSequenceActor* _levelSequenceActor);
}; // Size: 0x160

class ULevelUpNotification : public UBaseNotification
{
    int32 m_iLevel;                                                                   // 0x0030 (size: 0x4)

    class ULevelUpNotification* BPF_Init(int32 _iLevel);
}; // Size: 0x38

class ULifeInfluenceTest : public UFloatInfluenceTest
{
}; // Size: 0x60

class ULimbsHelper : public UBlueprintFunctionLibrary
{

    ELimbs BPF_Mirror(ELimbs _eLimb, bool _bMirror);
}; // Size: 0x28

class ULineHitDetectionDB : public UBaseHitDetectionDB
{
    float m_fHalfHeight;                                                              // 0x0058 (size: 0x4)
    int32 m_iNumLines;                                                                // 0x005C (size: 0x4)
    bool m_bOneSided;                                                                 // 0x0060 (size: 0x1)

}; // Size: 0x68

class ULoadChoices : public UMenuItem
{
    TWeakObjectPtr<class UPanelWidget> m_SlotsBox;                                    // 0x0330 (size: 0x8)
    TSubclassOf<class ULoadSlot> m_LoadingButtonClass;                                // 0x0338 (size: 0x8)
    FMargin m_SlotsPadding;                                                           // 0x0340 (size: 0x10)

    void BPF_SetFocusedIndex(uint8 _uiIndex);
    void BPF_HideWidgetAndSetFocusOnFirstSlot(class UWidget* _widget);
    void BPF_FillLoadChoices();
    void BPF_DeleteSelectedSave();
}; // Size: 0x358

class ULoadSlot : public UMenuSlot
{

    uint8 BPF_GetSlotIndex();
    FString BPF_GetSaveName();
    FCharacterSaveDescription BPF_GetSaveDescription();
    class ULoadChoices* BPF_GetLoadPanel();
    void BPE_InitSlot(FCharacterSaveDescription _save);
}; // Size: 0x350

class ULockDB : public UDataAsset
{
    FRelationshipActionConditionArray m_RelationshipBehaviours;                       // 0x0030 (size: 0x3C)
    EMoveStatus m_MoveStatusOutOfFightRange;                                          // 0x006C (size: 0x6)
    EMoveStatus m_MoveStatusInFightRange;                                             // 0x0072 (size: 0x6)
    class UCurveFloat* m_MaxVerticalAngleCurve;                                       // 0x0078 (size: 0x8)
    bool m_bDebugMaxVerticalAngle;                                                    // 0x0080 (size: 0x1)
    class UCurveFloat* m_MaxZDiff;                                                    // 0x0088 (size: 0x8)

}; // Size: 0x90

class ULookAtAnimInstance : public USCAnimInstance
{
    FAimOffsetStruct m_aimOffset0;                                                    // 0x0630 (size: 0x18)
    FAimOffsetStruct m_aimOffset1;                                                    // 0x0648 (size: 0x18)
    int32 m_iAimOffsetIndex;                                                          // 0x0660 (size: 0x4)
    bool m_bLookAtEnabled;                                                            // 0x0664 (size: 0x1)
    FVector2D m_vBlendSpaceParams;                                                    // 0x0668 (size: 0x8)
    FRotator m_BoneModifierRot;                                                       // 0x0670 (size: 0xC)
    FRotator m_CompensationRot;                                                       // 0x067C (size: 0xC)
    bool m_bEnableAnimationCompensation;                                              // 0x0688 (size: 0x1)
    float m_fMaxHeadDiffYaw;                                                          // 0x068C (size: 0x4)
    float m_fMaxHeadDiffPitch;                                                        // 0x0690 (size: 0x4)
    FName m_headInWorldSpaceSaveBoneName;                                             // 0x0694 (size: 0x8)
    FName m_headComparaisonInWorldSpaceSaveBoneName;                                  // 0x069C (size: 0x8)
    ELookAtApplyMode m_eApplyMode;                                                    // 0x06A4 (size: 0x1)
    ELookAtRefDirMode m_eRefDirMode;                                                  // 0x06A5 (size: 0x1)
    float m_fAngleThreshold;                                                          // 0x06C0 (size: 0x4)
    float m_fMaxFrontAngle;                                                           // 0x06C4 (size: 0x4)
    bool m_bLookInCameraDir;                                                          // 0x06C8 (size: 0x1)
    TSubclassOf<class ULookAtAnimRequest> m_animRequest;                              // 0x06D0 (size: 0x8)
    FLookAtConfig m_lookAtConfigs;                                                    // 0x06D8 (size: 0x78)
    TArray<ELookAtTargetType> m_targetPriorities;                                     // 0x0750 (size: 0x10)
    FLookAtModifierParams m_defaultModifierParams;                                    // 0x0760 (size: 0x14)
    FLookAtLimits m_boneModifierLimits;                                               // 0x0778 (size: 0x90)
    bool m_bInverseValuesOnBoneModifier;                                              // 0x0808 (size: 0x1)
    FVector2D m_vBoneModifierOffset;                                                  // 0x080C (size: 0x8)
    FVector2D m_vBoneModifierMultiplier;                                              // 0x0814 (size: 0x8)
    FLookAtLimits m_defaultLimits;                                                    // 0x0820 (size: 0x90)
    TArray<FLookAtLocomotionLimits> m_locomotionLimits;                               // 0x08B0 (size: 0x10)
    TMap<class ETransitionGlobalType, class FLookAtLimits> m_transitionLimits;        // 0x08C0 (size: 0x50)
    FLookAtModifierParams m_friendlyModifierParams;                                   // 0x0910 (size: 0x14)
    FLookAtModifierParams m_hostileInIdleModifierParams;                              // 0x0924 (size: 0x14)

}; // Size: 0xA60

class ULookAtAnimRequest : public UObject
{

    FAimOffsetStruct BPE_GetLookAtAimOffset(class ULookAtAnimInstance* _animInstance);
}; // Size: 0x28

class ULookAtAnimRequest2 : public UObject
{

    FAimOffsetStruct BPE_GetLookAtAimOffset(class UPlayerAnim* _animInstance);
}; // Size: 0x28

class ULookAtConfigData : public UInheritedDataAsset
{
    float m_fMaxRequiredYaw;                                                          // 0x0038 (size: 0x4)
    float m_fMaxRequiredPitch;                                                        // 0x003C (size: 0x4)
    ESpeedState m_eMaxSpeedState;                                                     // 0x0040 (size: 0x1)
    EMoveStatus m_eNeededMoveStatus;                                                  // 0x0041 (size: 0x1)
    float m_fTimerBeforeLookAt;                                                       // 0x0044 (size: 0x4)
    FLookAtModifierParams m_modifierParams;                                           // 0x0048 (size: 0x14)
    float m_fRotationMultiplier;                                                      // 0x005C (size: 0x4)
    float m_fMaxClampedYaw;                                                           // 0x0060 (size: 0x4)
    float m_fMaxClampedPitch;                                                         // 0x0064 (size: 0x4)

}; // Size: 0x68

class ULootBoxDB : public UDataAsset
{
    TMap<class ELootBoxType, class FLootBoxStaticData> m_LootBoxTypes;                // 0x0030 (size: 0x50)
    class UDataTable* m_SmallLootDataTable;                                           // 0x0080 (size: 0x8)
    TArray<class UDataTable*> m_BigLootDataTables;                                    // 0x0088 (size: 0x10)

    void BPF_GetLoot(const FLootBoxInstancedData& _LootBoxData, TArray<FLootBaseItemStruct>& Out_LootedItems);
}; // Size: 0xC8

class ULootBoxOpeningSequenceDB : public UDataAsset
{
    TMap<class EGearRarity, class FPictoData> m_pictosData;                           // 0x0030 (size: 0x50)
    float m_fSequenceStart;                                                           // 0x0080 (size: 0x4)
    float m_fSequenceEnd;                                                             // 0x0084 (size: 0x4)
    TArray<FSequenceCheckPointData> m_sequenceCheckPointsData;                        // 0x0088 (size: 0x10)
    float m_fLoopPlayBackStartPosition;                                               // 0x0098 (size: 0x4)
    float m_fLoopPlayBackEndPosition;                                                 // 0x009C (size: 0x4)

}; // Size: 0xA0

class UMCDominationInfluenceTest : public UAIInfluenceTest
{
    uint32 m_uiMCDominationFlags;                                                     // 0x0050 (size: 0x4)

}; // Size: 0x58

class UMMCPrepFocusCooldown : public UGameplayModMagnitudeCalculation
{
}; // Size: 0x40

class UMainMenu : public UMenuWidget
{
}; // Size: 0x3D8

class UMappableInputsDB : public UDataAsset
{
    FText m_RemappingNotificationMessages;                                            // 0x0030 (size: 0x48)
    bool m_bKeysInSelectionAreForbidden;                                              // 0x0078 (size: 0x1)
    TSoftObjectPtr<UTexture2D> m_NoMappingIcon;                                       // 0x0080 (size: 0x28)
    TArray<FKey> m_KeysSelectionForRemapping;                                         // 0x00A8 (size: 0x10)
    TArray<FKey> m_KeysIgnoredForRemapping;                                           // 0x00B8 (size: 0x10)
    TArray<FKey> m_CancelRemappingKeys;                                               // 0x00C8 (size: 0x10)
    TArray<FRemappingSectionStruct> m_MappableInputsSection;                          // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class UMappingEditorHelpers : public UClass
{

    FString BPF_GetInputPriorityGroupDesc(const FInputPriorityGroup& _group);
    bool BPF_GetInputMappingShowSlot(const FInputMappingKeySlotContainer& _slot);
    bool BPF_GetInputMappingShowData(const FInputMappingKeySlotContainer& _slot);
    FString BPF_GetInputMappingKeySlotDesc(const FInputMappingKeySlot& _slot);
    FString BPF_GetInputMappingKeySlotContainerTitle(const FInputMappingKeySlotContainer& _slot);
    FString BPF_GetInputMappingKeySlotContainerDesc(const FInputMappingKeySlotContainer& _slot);
    FString BPF_GetInputMappingGroupTitle(const FInputMappingGroup& _mapping);
    FString BPF_GetInputMappingGroupDesc(const FInputMappingGroup& _mapping);
    FLinearColor BPF_GetInputMappingGroupColor(const FInputMappingGroup& _mapping);
    FString BPF_GetInputMappingDataSlotDesc(const FInputMappingData& _data);
    bool BPF_GetInputMappingDataShowSlot(const FInputMappingData& _slot);
    bool BPF_FindInputProfileAvailableKey(FInputMappingProfileEnumHandler& _modifier, int32 _iIndex);
    bool BPF_FindInputPresetAvailableKey(FInputPresetsEnumHandler& _modifier, int32 iIndex);
}; // Size: 0x230

class UMenuAsyncActionBase : public UBlueprintAsyncActionBase
{

    void OnCurrentMenuChanged(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    void BPF_Cancel();
}; // Size: 0x80

class UMenuAsyncActionBaseHelper : public UBlueprintFunctionLibrary
{

    void BPF_CancelAsyncAction(class UMenuAsyncActionBase* _action);
}; // Size: 0x28

class UMenuDB : public UDataAsset
{
    class UAkAudioEvent* m_AudioMove;                                                 // 0x0030 (size: 0x8)
    class UAkAudioEvent* m_AudioValidate;                                             // 0x0038 (size: 0x8)
    class UAkAudioEvent* m_AudioBack;                                                 // 0x0040 (size: 0x8)
    FEquipmentCategoryInfos m_EquipmentSlotInfos;                                     // 0x0048 (size: 0x840)
    TArray<FEquipmentCategoryInfos> m_ItemSlotInfos;                                  // 0x0888 (size: 0x10)
    FEquipmentCategoryInfos m_EmptyCategoryInfos;                                     // 0x0898 (size: 0xC0)
    TSoftObjectPtr<UTexture2D> m_AvoidIcons;                                          // 0x0958 (size: 0x118)
    TSoftObjectPtr<UTexture2D> m_ParryIcons;                                          // 0x0A70 (size: 0x50)
    TSoftObjectPtr<UTexture2D> m_AbsorIcon;                                           // 0x0AC0 (size: 0x28)
    TSoftObjectPtr<UTexture2D> m_GuardBreakIcon;                                      // 0x0AE8 (size: 0x28)
    TSoftObjectPtr<UTexture2D> m_DiscipleIcon;                                        // 0x0B10 (size: 0x28)
    FEquipmentCategoryInfos m_GameModeInfos;                                          // 0x0B38 (size: 0x240)
    TArray<FControllerIcons> m_ControllerIcons;                                       // 0x0D78 (size: 0x10)
    FControllerIcons m_DefaultControllerIcons;                                        // 0x0D88 (size: 0x40)
    class UTexture2D* m_QuadrantSelectionIcons;                                       // 0x0DC8 (size: 0x20)
    FIconTextures m_QuadrantIcons;                                                    // 0x0DE8 (size: 0x40)
    FIconTextures m_StanceIcons;                                                      // 0x0E28 (size: 0x40)

    class UTexture2D* BPF_GetStanceIcon(EQuadrantTypes _eQuadrant, EIconStyle _eIconStyle);
    class UTexture2D* BPF_GetQuadrantSelectionIcon(EQuadrantTypes _eQuadrant);
    class UTexture2D* BPF_GetQuadrantIcon(EQuadrantTypes _eQuadrant, EIconStyle _eIconStyle);
    void BPF_GetGameModeInfos(const EGameModeTypes _eGameMode, FEquipmentCategoryInfos& _outInfos);
    FString BPF_GetControllerKeyIconDesc(const FControllerKeyIcons& _slot);
    FString BPF_GetControllerIconsDesc(const FControllerIcons& _icons);
    FString BPF_GetControllerAxisIconDesc(const FControllerAxisIcons& _slot);
    TSoftObjectPtr<UTexture2D> BPF_GetAttackParryIcon(EParrySide _eParrySide);
    TSoftObjectPtr<UTexture2D> BPF_GetAttackAvoidIcon(EAvoidType _eAvoidType);
}; // Size: 0xE78

class UMenuDataSource : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UMenuIconsDB : public UDataAsset
{
    TSoftObjectPtr<UTexture2D> m_EquipmentSlotDefaultIcons;                           // 0x0030 (size: 0x1B8)
    TSoftObjectPtr<UTexture2D> m_EquipmentSlotSelectedIcons;                          // 0x01E8 (size: 0x1B8)
    TArray<TSoftObjectPtr<UTexture2D>> m_ItemDefaultIcons;                            // 0x03A0 (size: 0x10)
    TArray<TSoftObjectPtr<UTexture2D>> m_ItemSelectedIcons;                           // 0x03B0 (size: 0x10)
    TSoftObjectPtr<UTexture2D> m_EmptyMiniWeaponIcon;                                 // 0x03C0 (size: 0x28)
    TArray<TSoftObjectPtr<UTexture2D>> m_FightingStyleMiniIcons;                      // 0x03E8 (size: 0x10)
    TArray<FControllerIcons> m_ControllerIcons;                                       // 0x03F8 (size: 0x10)
    FControllerIcons m_DefaultControllerIcons;                                        // 0x0408 (size: 0x40)
    FEquipmentCategoryInfos m_EmptyWeaponFamilyInfos;                                 // 0x0448 (size: 0xC0)

    FControllerIcons GetControllerIcons(FName _controllerType);
}; // Size: 0x508

class UMenuItem : public USCUserWidget
{
    class UWidget* m_PreviousWidget;                                                  // 0x0310 (size: 0x8)
    class UWidget* m_WidgetToFocusOnCancel;                                           // 0x0318 (size: 0x8)
    class UMenuItem* m_NextPanel;                                                     // 0x0320 (size: 0x8)
    bool m_bAllowSoundPlaying;                                                        // 0x0328 (size: 0x1)

    void BPE_OnChangeNextWidget(class UWidget* _widgetToHide, class UWidget* _previousWidget, class UWidget* _widgetToFocusOnCancel);
    void BPE_OnCancelPressed();
    void BPE_OnCancelChangeWidget();
}; // Size: 0x330

class UMenuLoading : public USCUserWidget
{

    void BPE_Reinit();
}; // Size: 0x310

class UMenuSlot : public USCUserWidget
{
    bool m_bAllowSoundPlaying;                                                        // 0x0310 (size: 0x1)

}; // Size: 0x318

class UMenuWidget : public USCUserWidget
{
    FMenuWidget_OnTransitionFinished m_OnTransitionFinished;                          // 0x0318 (size: 0x10)
    void OnTransitionFinished();
    bool m_bIgnoreKeyFlushOnFocus;                                                    // 0x0328 (size: 0x1)
    EWidgetLifeCycle m_eLifeCycle;                                                    // 0x0329 (size: 0x1)
    bool m_bPushInputContext;                                                         // 0x032A (size: 0x1)
    FAvailabilityLayerPushParams m_availabilityLayer;                                 // 0x0330 (size: 0x10)
    bool m_bBlockParentMenuInputs;                                                    // 0x0340 (size: 0x1)
    bool m_bBlockInputsWhenUIInputDisabled;                                           // 0x0341 (size: 0x1)
    bool m_bPopAvailabilityLayersOnlyOnHidden;                                        // 0x0342 (size: 0x1)
    bool m_bHideOnPushedOut;                                                          // 0x0343 (size: 0x1)
    bool m_bHideOnPopOut;                                                             // 0x0344 (size: 0x1)
    ESlateVisibility m_CurrentMenuVisibility;                                         // 0x0345 (size: 0x1)
    int32 m_iZOrder;                                                                  // 0x0348 (size: 0x4)

    void OnTransitionFinished__DelegateSignature();
    void BPF_SetMapTagName(FName _mapTagName);
    void BPF_PlayTransitionAnimation(class UWidgetAnimation* _inAnimation, TEnumAsByte<EUMGSequencePlayMode::Type> _ePlayMode, bool _bDisableInputs);
    void BPF_PlayBackSound();
    bool BPF_IsCurrentMenu();
    int32 BPF_GetZOrder();
    class UUserWidget* BPF_GetMenuAnimations();
    FVector2D BPF_GetLeftStickValue();
    bool BPF_GetIsInTransitionAnimation();
    void BPF_EnableInputs();
    void BPF_DisableInputs();
    bool BPF_AreInputsEnabled();
    void BPE_OpenFromNotification(class UBaseNotification* _notification);
    bool BPE_OnTrainingEditPressed();
    bool BPE_OnToggleStatsButtonPressed();
    bool BPE_OnStartTrainingPressed();
    bool BPE_OnSortingInventoryButtonPressed();
    bool BPE_OnRenameButtonPressed();
    bool BPE_OnRemoveButtonPressed();
    bool BPE_OnPasteButtonPressed();
    bool BPE_OnPageNavigation(ECycleDirection _eDirection);
    void BPE_OnMenuTransitionOut(EMenuTransitions _eTransition, EMenuEnum _eNewMenu);
    void BPE_OnMenuTransitionIn(EMenuTransitions _eTransition, EMenuEnum _ePrevMenu);
    bool BPE_OnMenuPreviewPressed();
    bool BPE_OnMenuButtonPressed();
    bool BPE_OnMenuActionSecondaryPressed();
    bool BPE_OnMenuActionSecondaryHoldButtonPressed();
    bool BPE_OnInputAction(InputAction eAction);
    void BPE_OnGroupMemberNewAnswer(const FUniqueNetIdRepl& _groupMemberUniqueId, class AActor* _memberActor, ECoopGameModeAnswerStatus _eNewAnswer, EGameModeTypes _eGameModeType);
    bool BPE_OnEditButtonPressed();
    bool BPE_OnCopyButtonPressed();
    bool BPE_OnBackButtonPressed();
    bool BPE_OnAltPageNavigation(ECycleDirection _eDirection);
    bool BPE_OnActionHoldButtonPressed();
    bool BPE_OnActionButtonPressed();
}; // Size: 0x3D8

class UMessageFeedbackUserWidget : public USCUserWidget
{
    class ABaseReplayController* m_Controller;                                        // 0x0310 (size: 0x8)
    EMessageReason m_eShowForReason;                                                  // 0x0318 (size: 0x1)

    bool BPF_IsActive();
    void BPE_Show(bool _bHasActiveMessage);
}; // Size: 0x320

class UMessageManager : public UObject
{
    class UMessengerComponent* m_MessengerComponent;                                  // 0x0028 (size: 0x8)

}; // Size: 0x30

class UMessageNotification : public UBaseNotification
{
    FText m_Message;                                                                  // 0x0030 (size: 0x18)

    class UMessageNotification* BPF_Init(FText _message);
}; // Size: 0x48

class UMessengerComponent : public UActorComponent
{
}; // Size: 0x110

class UMovableActionCondition : public UBaseActorCondition
{
    InputAction m_HasAction;                                                          // 0x0028 (size: 0x1)
    bool m_bIgnoreNonMovables;                                                        // 0x0029 (size: 0x1)

}; // Size: 0x30

class UMovableInteractionComponent : public UInteractionObjectComponent
{
    FMovableInteractionComponentOnPushObject OnPushObject;                            // 0x01F0 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    FMovableInteractionComponentOnThrowObject OnThrowObject;                          // 0x0200 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    FMovableInteractionComponentOnPickUpObject OnPickUpObject;                        // 0x0210 (size: 0x10)
    void UseObject(class APlayerController* PlayerController);
    TArray<InputAction> m_aInputActions;                                              // 0x0220 (size: 0x10)
    float m_fShowInteractionRange;                                                    // 0x0240 (size: 0x4)

}; // Size: 0x248

class UMoveInterruptAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UMoveSpeedOrderService : public UOrderService
{
    FName m_CurveName;                                                                // 0x0028 (size: 0x8)
    float m_fSpeedStateBlendDuration;                                                 // 0x0030 (size: 0x4)

}; // Size: 0x38

class UMoveStatusCondition : public UBaseActorCondition
{
    EMoveStatus m_eMoveStatus;                                                        // 0x0028 (size: 0x1)

}; // Size: 0x30

class UMoveToTargetNextAttackRangeBTTask : public UBTTask_MoveTo
{
}; // Size: 0xE0

class UMovementCapsuleOrderService : public UOrderService
{
    float m_fTargetHalfHeight;                                                        // 0x0028 (size: 0x4)
    float m_fTargetRadius;                                                            // 0x002C (size: 0x4)
    class UCurveFloat* m_Blend;                                                       // 0x0030 (size: 0x8)

}; // Size: 0x38

class UMovementFocusUpdateBTService : public UBTService
{
}; // Size: 0x70

class UMovementModeCondition : public UBaseActorCondition
{
    TEnumAsByte<EMovementMode> m_eMovementMode;                                       // 0x0028 (size: 0x1)

}; // Size: 0x30

class UMovementModeNotify : public USCAnimNotify
{
    TEnumAsByte<EMovementMode> m_eDesiredMode;                                        // 0x0048 (size: 0x1)

}; // Size: 0x50

class UMovementModeNotifyState : public USCAnimNotifyState
{
    TEnumAsByte<EMovementMode> m_eEnterMovementMode;                                  // 0x0048 (size: 0x1)
    TEnumAsByte<EMovementMode> m_eExitMovementMode;                                   // 0x0049 (size: 0x1)

}; // Size: 0x50

class UMovementModeOrderService : public UOrderService
{
    TEnumAsByte<EMovementMode> m_eMovementMode;                                       // 0x0028 (size: 0x1)

}; // Size: 0x30

class UMovieSceneRetargetingOverrideSection : public UMovieSceneSection
{
    class UWGRetargetingOverrideData* m_RetargetingOverrideData;                      // 0x00E8 (size: 0x8)

}; // Size: 0xF0

class UMovieSceneRetargetingOverrideTrack : public UMovieSceneNameableTrack
{
    TArray<class UMovieSceneSection*> m_Sections;                                     // 0x0080 (size: 0x10)

}; // Size: 0x90

class UMovieSceneSubtitlesSection : public UMovieSceneAkAudioEventSection
{
    FText Subtitle;                                                                   // 0x01D0 (size: 0x18)
    bool m_bIsMCSpeaking;                                                             // 0x01E8 (size: 0x1)

}; // Size: 0x1F0

class UMovieSceneSubtitlesTrack : public UMovieSceneNameableTrack
{
    TArray<class UMovieSceneSection*> Sections;                                       // 0x0080 (size: 0x10)

}; // Size: 0x90

class UMovieWidget : public UUserWidget
{
    class UMediaTexture* m_MediaTexture;                                              // 0x0268 (size: 0x8)
    class UImage* m_WidgetTorender;                                                   // 0x0270 (size: 0x8)
    FMovieWidgetOnEndReached OnEndReached;                                            // 0x0278 (size: 0x10)
    void OnEndReached();
    class UMediaPlayer* m_MediaPlayer;                                                // 0x0288 (size: 0x8)

    void OnEndReached__DelegateSignature();
    void MediaOpenedCallback(FString _url);
    void MediaEndCallback();
    bool BPF_OpenMovie(FString _url, bool _bLooping);
    void BPF_CloseMovie();
}; // Size: 0x290

class UNetOrderStructHelper : public UBlueprintFunctionLibrary
{

    bool GetBaseNetOrderStruct(class UOrderComponent* _OrderComponent, uint8 _uiOrderId, bool _bCheck, FNetOrderStruct& _outNetOrderStruct);
}; // Size: 0x28

class UNewNotificationWidget : public USCUserWidget
{
    EAttackLearningState m_eAttackLearningState;                                      // 0x0310 (size: 0x1)
    FInventorySearchFilter m_InventoryItemFilter;                                     // 0x0311 (size: 0x4)
    TArray<ECharacterProgressionRewardTypes> m_eProgressionRewards;                   // 0x0318 (size: 0x10)
    bool m_bAlwaysVisible;                                                            // 0x0328 (size: 0x1)
    FText m_displayedText;                                                            // 0x0330 (size: 0x18)

    void OnStatsChanged();
    void BPF_SetNotifyProgressionRewards(const TArray<ECharacterProgressionRewardTypes>& _rewards);
    void BPF_SetNotifyNewSparePoints(bool _bNewSparePoints);
    void BPF_SetNotifyNewAttacks(bool _bNotify);
    void BPF_Initialize(const TArray<ECharacterProgressionRewardTypes>& _rewards, const FInventorySearchFilter& _inventoryFilter, const TArray<EButtonNotificationType>& _notifications);
    void BPF_Init(TArray<ECharacterProgressionRewardTypes> _rewards, FInventorySearchFilter _inventoryFilter, bool _bNewSparePoints, bool _bNewAttacks, bool _bNewInventoryItems, bool _bNewEmotes, bool _bNewIntros);
    void BPE_Show();
}; // Size: 0x378

class UNotifyAttackFinishedBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UNotifyAttackStartedBTTask : public USCBTTaskNode
{
}; // Size: 0x70

class UOptionListenerComponent : public UActorComponent
{
    FOptionListenerComponentOnOptionChanged OnOptionChanged;                          // 0x00C0 (size: 0x10)
    void OnOptionChangedDynamicDelegate(EGameOptionTypes _eOptionType);

    void ReceiveOnOptionChanged(EGameOptionTypes _eOptionType);
    void OnOptionChangedDynamicDelegate__DelegateSignature(EGameOptionTypes _eOptionType);
}; // Size: 0xD8

class UOptionsMenu : public UMenuWidget
{
}; // Size: 0x3D8

class UOrderAnimSyncHelpers : public UBlueprintFunctionLibrary
{

    int32 BPF_GenerateAnimSyncID();
}; // Size: 0x28

class UOrderAttackDB : public UOrderDB
{
    float m_fRepulsionSpeed;                                                          // 0x00F8 (size: 0x4)

}; // Size: 0x100

class UOrderAttackGenericParams : public UOrderParams
{
    FNetOrderStructPlayAnim m_Params;                                                 // 0x0028 (size: 0x160)
    FNetOrderStructPlayAnim m_TransientParams;                                        // 0x0188 (size: 0x160)

}; // Size: 0x2E8

class UOrderAttackParams : public UOrderParams
{
    FNetOrderStructAttack m_Params;                                                   // 0x0028 (size: 0xF8)
    FNetOrderStructAttack m_TransientParams;                                          // 0x0120 (size: 0xF8)

}; // Size: 0x218

class UOrderAvoidedDB : public UOrderDB
{
    TSubclassOf<class UOrderServiceActivationConditions> m_activationCondition;       // 0x00F8 (size: 0x8)
    bool m_bInvertCondition;                                                          // 0x0100 (size: 0x1)
    FAvailabilityLayerContainer m_AvailabilityInfo;                                   // 0x0108 (size: 0x10)

}; // Size: 0x118

class UOrderComponent : public UActorComponent
{
    TArray<class TSubclassOf<UOrderDBSet>> m_OrderDBs;                                // 0x00C8 (size: 0x10)
    FOrderInfosInstanceMap m_OrderServiceInstances;                                   // 0x0150 (size: 0xA0)
    TMap<class FOrderType, class UOrderDelegateHandler*> m_OrderDelegateHandler;      // 0x01F0 (size: 0x50)

    void ServerUpdateOrder(uint8 _uiOrderId, EOrderType _eOrderType, FBuffer _ReplicatedBuffer, FUniqueNetIdRepl _callerPlayerId);
    void ServerPlayOrder(EOrderType _eOrderType, uint8 _uiForcedID, FBuffer _ReplicatedBuffer, int64 _iTimeLaunch, uint8 _uiAfterOrder, FUniqueNetIdRepl _callerPlayerId, bool _bRemoteRunOnMaster, uint8 _uiOrderIDToInsertBefore, uint8 _uiReplaceInSequence);
    void ServerCancelOrderByType(const FOrderType& _OrderType, bool _bCancelFirstOnly, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId, bool _bFromServer, bool _bIncludeChildType);
    void ServerCancelOrderByIDList(const TArray<uint8>& _OrderIDList, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId, bool _bFromServer);
    void ServerCancelOrderByID(uint8 _uiOrderId, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId, bool _bRemoteRunOnMaster, bool _bFromServer);
    void MultiCastUpdateOrder(uint8 _uiOrderId, EOrderType _eOrderType, FBuffer _ReplicatedBuffer, FUniqueNetIdRepl _callerPlayerId);
    void MultiCastPlayOrder(EOrderType _eOrderType, uint8 _uiForcedID, FBuffer _ReplicatedBuffer, int64 _iTimeLaunch, uint8 _uiAfterOrder, FUniqueNetIdRepl _callerPlayerId, bool _bRemoteRunOnMaster, uint8 _uiOrderIDToInsertBefore, uint8 _uiReplaceInSequence);
    void MultiCastFirstOrderTransformData(uint8 _uiOrderId, FOrderTransformData _orderTransformData);
    void MultiCastCancelOrderByType(const FOrderType& _OrderType, bool _bCancelFirstOnly, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId, const TArray<uint8>& _orderIdExceptions, bool _bIncludeChildType);
    void MultiCastCancelOrderByIDList(const TArray<uint8>& _OrderIDList, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId);
    void MultiCastCancelOrderByID(uint8 _uiOrderId, int64 _iTimeCancel, FUniqueNetIdRepl _callerPlayerId, bool _bRemoteRunOnMaster);
    class UOrderDelegateHandler* GetOrderDelegates(const FOrderType& _OrderType);
    void ClientPlayOrderRejected(uint8 _uiOrderId);
    bool BPF_IsOrderRunningWithID(uint8 _uiID, EOrderAccessMode _eAccessMode);
    bool BPF_IsOrderRunning(const FOrderType& _OrderType, EOrderAccessMode _eAccessMode, bool _bStillInRunningPhase, bool _bIncludeChildType);
    bool BPF_IsLastActionOrderPlayedInMirror();
    TArray<uint8> BPF_GetRunningAndPendingActionOrders(bool _bStillInRunningPhase);
    EOrderType BPF_GetOrderTypeFromOrderID(uint8 _uiOrderId);
    uint8 BPF_GetOrderIDFromType(EOrderType _eOrderType, bool& _bFound, EOrderAccessMode _eAccessMode, bool _bStillInRunningPhase);
    class UOrderDelegateHandler* BPF_GetOrderDelegates(EOrderType _eOrderType);
    class UOrderDB* BPF_GetOrderDB(FOrderType _OrderType);
    uint8 BPF_GetLastActionOrderId();
    FOrderType BPF_GetBPOrderTypeFromOrderID(uint8 _uiOrderId);
    class UOrderDelegateHandler* BPF_GetBPOrderDelegates(FName _BPOrderType);
    void BPF_CancelAllOrders();
}; // Size: 0x3F8

class UOrderCondition : public UBaseActorCondition
{
    EOrderType m_eOrderType;                                                          // 0x0028 (size: 0x1)
    FSCUserDefinedEnumHandler m_BPOrderType;                                          // 0x0030 (size: 0x50)
    EOrderAccessMode m_eAccessMode;                                                   // 0x0080 (size: 0x1)

}; // Size: 0x88

class UOrderDB : public UObject
{
    EOrderType m_eOrderType;                                                          // 0x0028 (size: 0x1)
    FSCUserDefinedEnumHandler m_BlueprintID;                                          // 0x0030 (size: 0x50)
    EFightingActionState m_ePushFightingStateOnStart;                                 // 0x0080 (size: 0x1)
    bool m_bPopFightingStateOnStop;                                                   // 0x0081 (size: 0x1)
    bool m_bIsStunOrder;                                                              // 0x0082 (size: 0x1)
    bool m_bDelayHitsWhenStarting;                                                    // 0x0083 (size: 0x1)
    EVisibilityBasedAnimTickOption m_eVisibilityBasedAnimTickOption;                  // 0x0084 (size: 0x1)
    bool m_bAnimgraphShouldAlwaysTick;                                                // 0x0085 (size: 0x1)
    bool m_bEnableIK;                                                                 // 0x0086 (size: 0x1)
    bool m_bOverrideLookAtApplyMode;                                                  // 0x0087 (size: 0x1)
    ELookAtApplyMode m_eOverridenLookAtApplyMode;                                     // 0x0088 (size: 0x1)
    bool m_bOverrideLookAtRefDirMode;                                                 // 0x0089 (size: 0x1)
    ELookAtRefDirMode m_eOverridenLookAtRefDirMode;                                   // 0x008A (size: 0x1)
    FDynamicBlendSettings m_LocoToOrderBlendSettings;                                 // 0x0090 (size: 0x10)
    FDynamicBlendSettings m_OrderToOrderBlendSettings;                                // 0x00A0 (size: 0x10)
    FDynamicBlendSettings m_OrderToLocoBlendSettings;                                 // 0x00B0 (size: 0x10)
    bool m_bOrderToLocoUseSpeedStateSpeedForStartingSpeedBlend;                       // 0x00C0 (size: 0x1)
    FOrderServiceInfosList m_OrderServices;                                           // 0x00C8 (size: 0x30)

    void BPE_OnOrderStopped(uint8 _uiOrderId, class UOrderComponent* _component);
    void BPE_OnOrderStarted(uint8 _uiOrderId, class UOrderComponent* _component);
    void BPE_OnOrderCanceled(uint8 _uiOrderId, class UOrderComponent* _component);
}; // Size: 0xF8

class UOrderDBSet : public UObject
{
    TArray<class TSubclassOf<UOrderDB>> m_Orders;                                     // 0x0028 (size: 0x10)

}; // Size: 0x38

class UOrderDashParams : public UOrderParams
{
    FNetOrderStructDash m_Params;                                                     // 0x0028 (size: 0x178)
    FNetOrderStructDash m_TransientParams;                                            // 0x01A0 (size: 0x178)

}; // Size: 0x318

class UOrderDeflectedDB : public UOrderDB
{
    TSubclassOf<class UOrderServiceActivationConditions> m_activationCondition;       // 0x00F8 (size: 0x8)
    bool m_bInvertCondition;                                                          // 0x0100 (size: 0x1)
    FAvailabilityLayerContainer m_AvailabilityInfo;                                   // 0x0108 (size: 0x10)

}; // Size: 0x118

class UOrderDelegateHandler : public UObject
{
    FOrderDelegateHandler_OnStarting m_OnStarting;                                    // 0x0028 (size: 0x10)
    void OrderStartingDynamicDelegate(uint8 _ID, class UOrderComponent* _OrderComponent);
    FOrderDelegateHandler_OnStarted m_OnStarted;                                      // 0x0038 (size: 0x10)
    void OrderStartingDynamicDelegate(uint8 _ID, class UOrderComponent* _OrderComponent);
    FOrderDelegateHandler_OnEnding m_OnEnding;                                        // 0x0048 (size: 0x10)
    void OrderStartingDynamicDelegate(uint8 _ID, class UOrderComponent* _OrderComponent);
    FOrderDelegateHandler_OnEnded m_OnEnded;                                          // 0x0058 (size: 0x10)
    void OrderStartingDynamicDelegate(uint8 _ID, class UOrderComponent* _OrderComponent);
    FOrderDelegateHandler_OnCanceled m_OnCanceled;                                    // 0x0068 (size: 0x10)
    void OrderStartingDynamicDelegate(uint8 _ID, class UOrderComponent* _OrderComponent);

}; // Size: 0x78

class UOrderFallFromPushedDB : public UOrderDB
{
    float m_fMinFallVelocity;                                                         // 0x00F8 (size: 0x4)
    float m_fMaxFallVelocity;                                                         // 0x00FC (size: 0x4)
    bool m_bRedirectToSlopeDir;                                                       // 0x0100 (size: 0x1)
    float m_fDelayBeforeEnteringFallFromPushed;                                       // 0x0104 (size: 0x4)

}; // Size: 0x108

class UOrderFallOnSlopeDB : public UOrderDB
{
    bool m_bPhysicAnimEnabled;                                                        // 0x00F8 (size: 0x1)
    FFallOnSlopeConfiguration m_SlopeConfiguration;                                   // 0x0100 (size: 0x18)
    FFallOnSlopeConfiguration m_GroundConfiguration;                                  // 0x0118 (size: 0x18)
    float m_fFallVelocityThreshold;                                                   // 0x0130 (size: 0x4)
    float m_fSlopeGroundAngleThreshold;                                               // 0x0134 (size: 0x4)
    float m_fSlopeRampAngleThreshold;                                                 // 0x0138 (size: 0x4)
    FName m_PhysicalAnimationProfile;                                                 // 0x013C (size: 0x8)
    float m_fActorRotationFromPelvisForward;                                          // 0x0144 (size: 0x4)
    float m_fFloorDetectionLengthFromPelvis;                                          // 0x0148 (size: 0x4)
    float m_fPelvisVerticalOffset;                                                    // 0x014C (size: 0x4)
    FCollisionProfileName m_RagdollCollisionProfileName;                              // 0x0150 (size: 0x8)
    class UPhysicsAsset* m_PhysicAsset;                                               // 0x0158 (size: 0x8)
    float m_fStartupDuration;                                                         // 0x0160 (size: 0x4)
    float m_fVelocityPushCoef;                                                        // 0x0164 (size: 0x4)
    float m_fTotalMaxDuration;                                                        // 0x0168 (size: 0x4)
    class UAnimSequence* m_Loop;                                                      // 0x0170 (size: 0x8)
    TMap<class ERagdollMeshOrientation, class FAnimContainer> m_RecoveryAnims;        // 0x0178 (size: 0x50)
    bool m_bPlayInstantRecoveryAnim;                                                  // 0x01C8 (size: 0x1)
    bool m_bPlayInstantRecoveryAnimOnPlaneGround;                                     // 0x01C9 (size: 0x1)
    FAnimContainer m_InstantRecoveryAnim;                                             // 0x01D0 (size: 0x18)
    FName m_PoseSnapshotName;                                                         // 0x01E8 (size: 0x8)
    bool m_bMirrorFallOnRightSide;                                                    // 0x01F0 (size: 0x1)
    class UAkRtpc* m_RTCPSpeed;                                                       // 0x01F8 (size: 0x8)
    FFloatRange m_RTCPMinMaxVelocity;                                                 // 0x0200 (size: 0x10)
    FName m_RTPCName;                                                                 // 0x0210 (size: 0x8)
    bool m_bCallRTPCOnSelf;                                                           // 0x0218 (size: 0x1)

    void BPE_StopBodyRollLoop(class UObject* _owner, uint8 _uiOrderId);
    void BPE_StartBodyRollLoop(class UObject* _owner, uint8 _uiOrderId, const class UPhysicalMaterial* _floorMaterial, bool _bInitialTrace);
    void BPE_BodyRollLoopMaterialSwitch(class UObject* _owner, uint8 _uiOrderId, const class UPhysicalMaterial* _floorMaterial);
}; // Size: 0x220

class UOrderFallOnSlopeEntryDB : public UOrderDB
{
    FAnimContainer m_OnHitSlope;                                                      // 0x00F8 (size: 0x18)
    FRuntimeFloatCurve m_VelocityBlendRatio;                                          // 0x0110 (size: 0x88)
    bool m_bForceVelocity;                                                            // 0x0198 (size: 0x1)
    float m_fForceVelocity;                                                           // 0x019C (size: 0x4)
    bool m_bForceVelocityOnPlaneGround;                                               // 0x01A0 (size: 0x1)
    float m_fForceVelocityOnPlaneGround;                                              // 0x01A4 (size: 0x4)
    TSubclassOf<class UDetectFallOrderService> m_SlopeDetectionDB;                    // 0x01A8 (size: 0x8)

}; // Size: 0x1B0

class UOrderFidgetDB : public UOrderDB
{
    FSCUserDefinedEnumHandler m_VariableWeightLayer;                                  // 0x00F8 (size: 0x50)
    class UDataTable* m_BlendProfileBySpeedStateTable;                                // 0x0148 (size: 0x8)
    float m_fSyncFidgetMirrorWithQuadrantCooldown;                                    // 0x0150 (size: 0x4)
    FFidgetDBDescription m_FidgetDBs;                                                 // 0x0158 (size: 0x70)
    class UFidgetDB* m_TakeOutWeaponFidgetDB;                                         // 0x01C8 (size: 0x8)
    float m_fHideWeaponPostBlendRatio;                                                // 0x01D0 (size: 0x4)
    TArray<FEditableOrderType> m_eTakeOutWeaponPostOrderList;                         // 0x01D8 (size: 0x10)
    bool m_bPlayAlertFidgetIfMoveStatusMatch;                                         // 0x01E8 (size: 0x1)
    bool m_bPlayAlertFidgetIfMoveStatusDoesntMatch;                                   // 0x01E9 (size: 0x1)
    float m_fFidgetDefaultBlendInDuration;                                            // 0x01EC (size: 0x4)
    float m_fFidgetMaxBlendInDurationByAnimPercent;                                   // 0x01F0 (size: 0x4)
    float m_fFidgetDefaultBlendOutDuration;                                           // 0x01F4 (size: 0x4)
    float m_fFidgetQuickBlendOutDuration;                                             // 0x01F8 (size: 0x4)

}; // Size: 0x200

class UOrderHasTargetActivationCondition : public UOrderServiceActivationConditions
{
}; // Size: 0x28

class UOrderHittedDB : public UOrderDB
{
}; // Size: 0xF8

class UOrderHittedGenericDB : public UOrderDB
{
}; // Size: 0xF8

class UOrderHittedGuardTypeCondition : public UOrderServiceActivationConditions
{
    bool m_bCheckWasGuarded;                                                          // 0x0028 (size: 0x1)
    bool m_bWasGuarded;                                                               // 0x0029 (size: 0x1)
    bool m_bCheckGuardBreak;                                                          // 0x002A (size: 0x1)
    bool m_bWasGuardBroken;                                                           // 0x002B (size: 0x1)
    bool m_bCheckGuardType;                                                           // 0x002C (size: 0x1)
    EGuardType m_eGuardType;                                                          // 0x002D (size: 0x1)

}; // Size: 0x30

class UOrderOpeningDoorParams : public UOrderParams
{
    FNetStructOpeningDoor m_Params;                                                   // 0x0028 (size: 0x120)
    FNetStructOpeningDoor m_TransientParams;                                          // 0x0148 (size: 0x120)

}; // Size: 0x268

class UOrderParams : public UObject
{
}; // Size: 0x28

class UOrderParamsHitActionLauncher : public UHitActionLauncher
{
    FUOrderParamsClassInstance m_OrderParamsInstance;                                 // 0x0038 (size: 0x10)
    bool m_bApplyDamage;                                                              // 0x0048 (size: 0x1)
    bool m_bNotifyHitted;                                                             // 0x0049 (size: 0x1)
    bool m_bApplyFreezeFrame;                                                         // 0x004A (size: 0x1)

}; // Size: 0x50

class UOrderPickupObjectHelper : public UBlueprintFunctionLibrary
{

    bool BPF_SetupPickupOrderParamsAndPlay(class AFightingCharacter* _fightingChar, class AActor* _actorToPickup, class UAnimSequence* _animSequence, FSCUserDefinedEnumHandler _variableWeightLayer, bool _bPushPopActionState, bool _bMirror);
}; // Size: 0x28

class UOrderPlayAnimHelper : public UBlueprintFunctionLibrary
{

    void BPF_GetOrderAnimContainer(class UOrderComponent* _OrderComponent, uint8 _uiID, FAnimContainer& _outAnimContainer);
}; // Size: 0x28

class UOrderPlayAnimParams : public UOrderParams
{
    FNetOrderStructPlayAnim m_Params;                                                 // 0x0028 (size: 0x160)
    FNetOrderStructPlayAnim m_TransientParams;                                        // 0x0188 (size: 0x160)

}; // Size: 0x2E8

class UOrderPlayAnimVariableWeightDB : public UOrderDB
{
    bool m_bUpdateQuadrant;                                                           // 0x00F8 (size: 0x1)

}; // Size: 0x100

class UOrderPresetDB : public UObject
{
    TArray<FOrderServiceInfos> m_Services;                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

class UOrderRunningDecorator : public USCBTDecorator
{
    TArray<EOrderType> m_eOrders;                                                     // 0x0070 (size: 0x10)

}; // Size: 0x80

class UOrderService : public UObject
{

    void BPE_OnInit(const FBPOrderServiceInstance& _instance);
}; // Size: 0x28

class UOrderServiceActivationConditions : public UObject
{

    bool BPE_CanActivate(uint8 _uiOrderId, const class ABaseCharacter* _owner);
}; // Size: 0x28

class UOrderServiceFrameRangeRequest : public UObject
{

    FFloatRange BPE_GetFrameRange(uint8 _uiOrderId, const class ABaseCharacter* _owner);
}; // Size: 0x28

class UOrderServiceFrameRangeRequestByDodgeType : public UOrderServiceFrameRangeRequest
{
    FFloatRange m_frameRanges;                                                        // 0x0028 (size: 0x30)

}; // Size: 0x58

class UOrderServiceHasHitTargetActivationCondition : public UOrderServiceActivationConditions
{
    bool m_bMustBeSucessful;                                                          // 0x0028 (size: 0x1)

}; // Size: 0x30

class UOrderServiceInstanceHelper : public UBlueprintFunctionLibrary
{

    void BPF_GetOrderInstanceInfos(const FBPOrderServiceInstance& _orderServiceInstance, uint8& _uiOutOrder, EOrderType& _eOutType, class UOrderComponent*& _OrderComponent);
    class UOrderService* BPF_FindOrderServiceByClass(const FBPOrderServiceInstance& _myOrderServiceInstance, TSubclassOf<class UOrderService> _class, FBPOrderServiceInstance& _resultOrderServiceInstance);
}; // Size: 0x28

class UOrderServiceIsPlayingActivationCondition : public UOrderServiceActivationConditions
{
    TSubclassOf<class UOrderService> m_InstanceClass;                                 // 0x0028 (size: 0x8)
    bool m_bStopWhenOrderServiceRunning;                                              // 0x0030 (size: 0x1)

}; // Size: 0x38

class UOrderServiceNotifyState : public USCAnimNotifyState
{
    bool m_bTickFrozen;                                                               // 0x0048 (size: 0x1)
    TSubclassOf<class UOrderService> m_ServiceClass;                                  // 0x0050 (size: 0x8)
    class UOrderService* m_ServiceInstanced;                                          // 0x0058 (size: 0x8)
    TSubclassOf<class UOrderServiceActivationConditions> m_activationCondition;       // 0x0060 (size: 0x8)

    TSubclassOf<class UOrderService> GetServiceClass(bool _bIncludeInstanced);
}; // Size: 0x68

class UOrderServiceRagingBullPhaseActivationCondition : public UOrderServiceActivationConditions
{
    uint8 m_uiAllowedPhases;                                                          // 0x0028 (size: 0x1)

}; // Size: 0x30

class UOrderTargetCondition : public UBaseActorTargetCondition
{
    EOrderType m_eOrderType;                                                          // 0x0028 (size: 0x1)
    bool m_bTargetShouldTargetSelf;                                                   // 0x0029 (size: 0x1)
    EOrderType m_eRequiredTargetOrderType;                                            // 0x002A (size: 0x1)

}; // Size: 0x30

class UOrderTauntHelper : public UBlueprintFunctionLibrary
{

    void BP_TriggerTauntEffects(class AActor* _Instigator);
}; // Size: 0x28

class UOrderTimeCondition : public UBaseActorCondition
{
    FEditableOrderType m_OrderType;                                                   // 0x0028 (size: 0x58)
    EOrderAccessMode m_eAccessMode;                                                   // 0x0080 (size: 0x1)
    FFloatRange m_ValidTimeRange;                                                     // 0x0084 (size: 0x10)

}; // Size: 0x98

class UOrderTraversalDB : public UOrderDB
{
    bool m_bCanBeHitted;                                                              // 0x00F8 (size: 0x1)

    void BPE_HittedFallOnSlopeEntryAnim(const FNetOrderStructTraversal& _netOrderStruct, FAnimContainer& _outResult);
}; // Size: 0x100

class UOrderTraversalParams : public UOrderParams
{
    FNetOrderStructTraversal m_Params;                                                // 0x0028 (size: 0x428)
    FNetOrderStructTraversal m_TransientParams;                                       // 0x0450 (size: 0x428)
    ETraversalEntryType m_eForceEntryType;                                            // 0x0878 (size: 0x1)

}; // Size: 0x880

class UOrderTraversalPushDB : public UOrderDB
{
    float m_fMarginAfterTraversalEnd;                                                 // 0x00F8 (size: 0x4)
    FHitBox m_HitOnLandedWithoutFall;                                                 // 0x0100 (size: 0x298)
    FHitBox m_HitOnLethalFall;                                                        // 0x0398 (size: 0x298)
    float m_fMaxLandingDistanceFromNavmesh;                                           // 0x0630 (size: 0x4)
    float m_fFallVelocityVariation;                                                   // 0x0634 (size: 0x4)

}; // Size: 0x638

class UOrderTypeHelper : public UBlueprintFunctionLibrary
{

    FOrderType MakeOrderTypeFromEnum(EOrderType _eOrderType);
    FOrderType MakeOrderTypeFromBP(const class ABaseCharacter* _owner, FName _OrderType);
    FOrderType MakeFromEditableOrderType(const class ABaseCharacter*& _owner, const FEditableOrderType& _OrderType);
}; // Size: 0x28

class UOrderWallJumpAttackParams : public UOrderParams
{
    FNetOrderStructWallJumpAttack m_Params;                                           // 0x0030 (size: 0x1C0)
    FNetOrderStructWallJumpAttack m_TransientParams;                                  // 0x01F0 (size: 0x1C0)

}; // Size: 0x3B0

class UOutsideCirclesLifeBTTaskNode : public UBTTaskNode
{
}; // Size: 0x70

class UOverTimeCameraMixerBlender : public UCameraMixerBlender
{

    float GetCoeff();
    void BlendWithStarting(float _fTarget, float _fDelay, float _fStarting, ESCBlendType _eBlendType, class UCurveFloat* _blendCurve);
    void Blend(float _fTarget, float _fDelay, ESCBlendType _eBlendType, class UCurveFloat* _blendCurve);
}; // Size: 0x30

class UOverwriteDropOnBreakMomentNotify : public USCAnimNotify
{
}; // Size: 0x48

class UPagingScrollBox : public UScrollBox
{
    FPagingScrollBox_OnItemClicked m_OnItemClicked;                                   // 0x0880 (size: 0x10)
    void ItemClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FPagingScrollBox_OnItemRightClicked m_OnItemRightClicked;                         // 0x0890 (size: 0x10)
    void ItemRightClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FPagingScrollBox_OnItemFocused m_OnItemFocused;                                   // 0x08A0 (size: 0x10)
    void ItemDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FPagingScrollBox_OnItemLostFocus m_OnItemLostFocus;                               // 0x08B0 (size: 0x10)
    void ItemDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FPagingScrollBox_OnItemSelected m_OnItemSelected;                                 // 0x08C0 (size: 0x10)
    void ItemSelectedDelegate(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    FPagingScrollBox_OnItemVisible m_OnItemVisible;                                   // 0x08D0 (size: 0x10)
    void ItemVisibleDelegate(int32 _iDataIndex, class UUserWidget* _cell);
    FPagingScrollBox_ItemPreviewButtonPressed m_ItemPreviewButtonPressed;             // 0x08E0 (size: 0x10)
    void ItemPreviewButtonPressed();
    int32 m_iLoadedRowCount;                                                          // 0x08F0 (size: 0x4)
    TSubclassOf<class USCUserWidget> m_CellClass;                                     // 0x08F8 (size: 0x8)
    TArray<class UWidget*> m_Headers;                                                 // 0x0900 (size: 0x10)

    void OnItemSelected(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    void OnItemRightClicked(class UButtonUserWidget* _button, bool _bWithMouse);
    void OnItemPreviewButtonPressedCallback();
    void OnItemLostFocus(class UButtonUserWidget* _button, EFocusCause _eCause);
    void OnItemFocused(class UButtonUserWidget* _button, EFocusCause _eCause);
    void OnItemClicked(class UButtonUserWidget* _button, bool _bWithMouse);
    void ItemVisibleDelegate__DelegateSignature(int32 _iDataIndex, class UUserWidget* _cell);
    void ItemPreviewButtonPressed__DelegateSignature();
    class UUserWidget* BPF_GetWidgetFromSectionDataIndex(int32 _iSection, int32 _iDataIndex);
    class UUserWidget* BPF_GetWidgetFromDataIndex(int32 _iIndex);
    int32 BPF_GetWidgetDataIndex(const int32 iRow, const int32 iCol);
    int32 BPF_GetRowDataIndex(const int32 iRow);
    class UUserWidget* BPF_GetLastVisibleWidgetFromSection(int32 _iSection);
    class UUserWidget* BPF_GetLastVisibleCell();
    int32 BPF_GetItemCount();
    int32 BPF_GetDataIndexFromWidget(class UUserWidget* _widget);
}; // Size: 0x9D0

class UParriedBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UParryAnimRequest : public UObject
{

    void BPE_GetPickupOnParryAnim(const FHitRequest& _request, class AFightingCharacter* _character, FAnimContainer& _outAnim);
    void BPE_GetParryAnimWeapon(const FParryRequestInfos& _infos, FAnimContainer& _outAnim);
    void BPE_GetParryAnim(const FParryRequestInfos& _infos, FAnimContainer& _outAnim);
}; // Size: 0x28

class UParryBTTask : public UAIDefenseBTTask
{
}; // Size: 0x90

class UParryDB : public UDataAsset
{
    FParryAnimationCharacterQuadrantArray m_ParryAnimations;                          // 0x0030 (size: 0x180)
    TSubclassOf<class UParryMatch> m_ParryMatchClass;                                 // 0x01B0 (size: 0x8)
    float m_fParryDuration;                                                           // 0x01B8 (size: 0x4)
    int32 m_iFrameBuildUp;                                                            // 0x01BC (size: 0x4)
    int32 m_iFrameRelease;                                                            // 0x01C0 (size: 0x4)
    class UCurveFloat* m_ParryMovementdynamic;                                        // 0x01C8 (size: 0x8)
    bool m_bParryConsumStamina;                                                       // 0x01D0 (size: 0x1)
    bool m_bParryConsumStaminaWhenSucceed;                                            // 0x01D1 (size: 0x1)
    bool m_bOverrideAnimDynamicByCurve;                                               // 0x01D2 (size: 0x1)
    float m_fTrackingDuration;                                                        // 0x01D4 (size: 0x4)
    float m_fParrySelectionAxisOffset;                                                // 0x01D8 (size: 0x4)
    class UAvailabilityLayerData* m_ParryLayerDataOnSucceed;                          // 0x01E0 (size: 0x8)
    TArray<FParriedProfile> m_ParriedProfile;                                         // 0x01E8 (size: 0x10)
    class UCurveFloat* m_ParriedAttackScaleCurve;                                     // 0x01F8 (size: 0x8)
    float m_fFrontBackMargin;                                                         // 0x0200 (size: 0x4)
    float m_fLeftRightMargin;                                                         // 0x0204 (size: 0x4)
    float m_fHighLowMargin;                                                           // 0x0208 (size: 0x4)
    float m_fFrontBackOffset;                                                         // 0x020C (size: 0x4)
    float m_fLeftRightOffset;                                                         // 0x0210 (size: 0x4)
    float m_fHighLowOffset;                                                           // 0x0214 (size: 0x4)
    float m_fGuardGaugeCost;                                                          // 0x0218 (size: 0x4)
    bool m_bHasImpactOnGuardGauge;                                                    // 0x021C (size: 0x1)
    class UParryPropertyDB* m_DefaultParryPropertyDB;                                 // 0x0220 (size: 0x8)
    class UParryMatch* m_ParryMatch;                                                  // 0x0228 (size: 0x8)

}; // Size: 0x230

class UParryFromDownAbility : public USCGameplayAbility
{
    bool m_bLaunchDownRecovery;                                                       // 0x0568 (size: 0x1)
    FAnimContainer m_animRecoveryOverriden;                                           // 0x0570 (size: 0x18)

}; // Size: 0x588

class UParryMatch : public UObject
{

    bool BPE_DoesParrySideMatch(EParrySide _eParrySide, EAttackTarget _eAttackTarget, EAttackOrigin _eAttackOrigin);
    bool BPE_DoesParryHeightMatch(EParryHeight _eParryHeight, EAttackTarget _eAttackTarget, EAttackOrigin _eAttackOrigin);
}; // Size: 0x28

class UParryPropertyDB : public USpecialAbilityPropertyDB
{
}; // Size: 0x50

class UParryToHitActionOrderService : public UOrderService
{
    TSubclassOf<class UHitActionLauncher> m_hitActionLauncher;                        // 0x0028 (size: 0x8)
    TArray<class UBaseHitDetectionDB*> m_IgnoringHitDetectionDBs;                     // 0x0030 (size: 0x10)
    FGameplayTagContainer m_IgnoringGameplayTagContainer;                             // 0x0040 (size: 0x20)

    void BPE_OnParryFailed(FBPOrderServiceInstance _description);
}; // Size: 0x60

class UParryToHitOrderService : public UOrderService
{
    FHitBox m_HitToApply;                                                             // 0x0028 (size: 0x298)
    float m_fFreezeFrames;                                                            // 0x02C0 (size: 0x4)

    void BPE_GetParryAnimations(const FHitDescription& _hitDescription, class AFightingCharacter* _parriyer, FAnimContainer& _outParryierAnim, FHittedAnimContainer& _outParriedAnim);
}; // Size: 0x2C8

class UParryWindowNotifyState : public USCAnimNotifyState
{
    TArray<FParryType> m_ParryTypeArray;                                              // 0x0048 (size: 0x10)
    class UParryPropertyDB* m_ParryPropertyDB;                                        // 0x0058 (size: 0x8)

}; // Size: 0x60

class UPatrolBTTask : public UBTTaskNode
{
    FGameplayTag m_MovingAIActionTag;                                                 // 0x0070 (size: 0x8)

}; // Size: 0x78

class UPauseScoringOrderService : public UOrderService
{
    bool m_bPauseEfficiency;                                                          // 0x0028 (size: 0x1)
    bool m_bRestartEfficiencyTimers;                                                  // 0x0029 (size: 0x1)
    bool m_bPauseBonusMalus;                                                          // 0x002A (size: 0x1)
    bool m_bRestartBonusMalusTimers;                                                  // 0x002B (size: 0x1)

}; // Size: 0x30

class UPelvisDirectionComputationParamsNotifyState : public UAnimNotifyState
{
    FPelvisDirectionComputationParams m_Params;                                       // 0x0030 (size: 0x38)

}; // Size: 0x68

class UPelvisDirectionComputationParamsOrderService : public UOrderService
{
    bool m_bUseLastFrameLocation;                                                     // 0x0028 (size: 0x1)
    FPelvisDirectionComputationParams m_Params;                                       // 0x0030 (size: 0x38)

}; // Size: 0x68

class UPerPlatformCanvaPanelSlot : public UCanvasPanelSlot
{
    FAnchorData NormalLayoutData;                                                     // 0x00E0 (size: 0x28)
    FAnchorData SmallScreenLayoutData;                                                // 0x0108 (size: 0x28)

}; // Size: 0x138

class UPerPlatformCanvasPanel : public UCanvasPanel
{
}; // Size: 0x138

class UPerPlatformComboBox : public UComboBoxString
{
    int32 NormalSize;                                                                 // 0x0E08 (size: 0x4)
    int32 SmallScreenSize;                                                            // 0x0E0C (size: 0x4)
    FPerPlatformComboBoxOnCultureChanged OnCultureChanged;                            // 0x0E20 (size: 0x10)
    void OnCultureChanged();

}; // Size: 0xE40

class UPerPlatformEditableTextBox : public UEditableTextBox
{
    int32 NormalSize;                                                                 // 0x0A40 (size: 0x4)
    int32 SmallScreenSize;                                                            // 0x0A44 (size: 0x4)

}; // Size: 0xA58

class UPerPlatformImage : public UImage
{
    FVector2D NormalSize;                                                             // 0x0218 (size: 0x8)
    FVector2D SmallScreenSize;                                                        // 0x0220 (size: 0x8)

    void RefreshGUIs();
}; // Size: 0x238

class UPerPlatformMultiLineEditableTextBox : public UMultiLineEditableText
{
    int32 NormalSize;                                                                 // 0x0478 (size: 0x4)
    int32 SmallScreenSize;                                                            // 0x047C (size: 0x4)

}; // Size: 0x490

class UPerPlatformRichTextBlock : public URichTextBlock
{
    class UDataTable* NormalTextStyleSet;                                             // 0x0680 (size: 0x8)
    class UDataTable* SmallScreenTextStyleSet;                                        // 0x0688 (size: 0x8)

}; // Size: 0x6A8

class UPerPlatformScaleBox : public UScaleBox
{
    TEnumAsByte<EStretch::Type> NormalStretch;                                        // 0x0148 (size: 0x1)
    TEnumAsByte<EStretch::Type> SmallScreenStretch;                                   // 0x0149 (size: 0x1)
    TEnumAsByte<EStretchDirection::Type> NormalStretchDirection;                      // 0x014A (size: 0x1)
    TEnumAsByte<EStretchDirection::Type> SmallScreenStretchDirection;                 // 0x014B (size: 0x1)
    float NormalUserSpecifiedScale;                                                   // 0x014C (size: 0x4)
    float SmallScreenUserSpecifiedScale;                                              // 0x0150 (size: 0x4)
    bool NormalIgnoreInheritedScale;                                                  // 0x0154 (size: 0x1)
    bool SmallScreenIgnoreInheritedScale;                                             // 0x0155 (size: 0x1)

}; // Size: 0x158

class UPerPlatformScaleBoxSlot : public UScaleBoxSlot
{
    FMargin NormalPadding;                                                            // 0x0060 (size: 0x10)
    FMargin SmallScreenPadding;                                                       // 0x0070 (size: 0x10)
    TEnumAsByte<EHorizontalAlignment> NormalHorizontalAlignment;                      // 0x0080 (size: 0x1)
    TEnumAsByte<EHorizontalAlignment> SmallScreenHorizontalAlignment;                 // 0x0081 (size: 0x1)
    TEnumAsByte<EVerticalAlignment> NormalVerticalAlignment;                          // 0x0082 (size: 0x1)
    TEnumAsByte<EVerticalAlignment> SmallScreenVerticalAlignment;                     // 0x0083 (size: 0x1)

}; // Size: 0x88

class UPerPlatformSizeBox : public USizeBox
{
    float NormalWidthOverride;                                                        // 0x0160 (size: 0x4)
    float SmallScreenWidthOverride;                                                   // 0x0164 (size: 0x4)
    float NormalHeightOverride;                                                       // 0x0168 (size: 0x4)
    float SmallScreenHeightOverride;                                                  // 0x016C (size: 0x4)

}; // Size: 0x180

class UPerPlatformTextBlock : public UTextBlock
{
    int32 NormalSize;                                                                 // 0x02B0 (size: 0x4)
    int32 SmallScreenSize;                                                            // 0x02B4 (size: 0x4)
    float NormalWrapTextAt;                                                           // 0x02B8 (size: 0x4)
    float SmallScreenWrapTextAt;                                                      // 0x02BC (size: 0x4)
    int32 NormalLetterSpacing;                                                        // 0x02C0 (size: 0x4)
    int32 SmallScreenLetterSpacing;                                                   // 0x02C4 (size: 0x4)

}; // Size: 0x2C8

class UPerPlatformWidgetLoader : public UPanelWidget
{
}; // Size: 0x138

class UPerPlatformWidgetLoaderSlot : public UWidgetSwitcherSlot
{
    EWidgetPlatform Platform;                                                         // 0x0058 (size: 0x1)

}; // Size: 0x60

class UPhysicAnimOrderService : public UOrderService
{
    bool m_bEnabled;                                                                  // 0x0030 (size: 0x1)
    FCollisionProfileName m_CollisionProfileName;                                     // 0x0034 (size: 0x8)
    FName m_PhysicAnimProfile;                                                        // 0x003C (size: 0x8)
    TArray<FBoneReference> m_BaseBones;                                               // 0x0048 (size: 0x10)
    bool m_bRequireCurve;                                                             // 0x0058 (size: 0x1)
    FName m_CurveName;                                                                // 0x005C (size: 0x8)
    float m_fBlendOutDuration;                                                        // 0x0064 (size: 0x4)

}; // Size: 0x68

class UPickUpMenu : public UHUDUserWidget
{
    class UResourcesTexturesData* m_RessourcesDataAsset;                              // 0x03A0 (size: 0x8)

    void LoadPictoCallback();
    void BPE_OnClose();
}; // Size: 0x3A8

class UPickUpMenuItem : public UUserWidget
{
}; // Size: 0x2A8

class UPickupObjectBTTask : public UBTTaskNode
{
}; // Size: 0x70

class UPickupObjectNotify : public USCAnimNotify
{
}; // Size: 0x48

class UPivotFootData : public UDataAsset
{
    class UCurveFloat* m_MinSpeedCurve;                                               // 0x0030 (size: 0x8)
    class UCurveFloat* m_DurationCurve;                                               // 0x0038 (size: 0x8)
    class UCurveFloat* m_DecelAccelRatioCurve;                                        // 0x0040 (size: 0x8)
    class UCurveFloat* m_AccelCurve;                                                  // 0x0048 (size: 0x8)
    class UCurveFloat* m_DecelCurve;                                                  // 0x0050 (size: 0x8)
    class UCurveFloat* m_OrientationCurve;                                            // 0x0058 (size: 0x8)
    FFloatRange m_TurnAllowanceOnAccelRange;                                          // 0x0060 (size: 0x10)
    FFloatRange m_TransitionAllowanceOnAccelRange;                                    // 0x0070 (size: 0x10)

}; // Size: 0x80

class UPlayAnimSubAnimInstance : public USCAnimInstance
{
    uint8 m_uiSubStateId;                                                             // 0x0628 (size: 0x1)
    EOrderType m_eOrderType;                                                          // 0x0629 (size: 0x1)
    FAnimContainer m_AnimContainerToPlay;                                             // 0x0630 (size: 0x18)
    FName m_IKSubInstanceTag;                                                         // 0x0648 (size: 0x8)
    int32 m_iSubStateID;                                                              // 0x0650 (size: 0x4)
    uint8 m_uiOrderID;                                                                // 0x0654 (size: 0x1)
    float m_fGlobalAlpha;                                                             // 0x0658 (size: 0x4)
    bool m_bIKEnabled;                                                                // 0x065C (size: 0x1)

    void BPE_SetTargetVerticalOffset(float _fVerticalOffet);
}; // Size: 0x680

class UPlayOrderRagingBullTask : public UPlayOrderTask
{
    class URagingBullDB* m_ragingBullDB;                                              // 0x0070 (size: 0x8)

}; // Size: 0x80

class UPlayOrderTask : public USCBTTaskNode
{
}; // Size: 0x70

class UPlayOrderThrowObjectTask : public UPlayOrderTask
{
    EThrowObjectActionType m_ThrowObjectActionType;                                   // 0x0070 (size: 0x1)

}; // Size: 0x78

class UPlayerAnim : public USCAnimInstance
{
    TArray<float> m_StateWeightArray;                                                 // 0x0628 (size: 0x10)
    TArray<float> m_VariableWeightLayerWeight;                                        // 0x0648 (size: 0x10)
    FAnimStructMoveTransition m_StartAnimStruct;                                      // 0x0660 (size: 0x90)
    FAnimStructMoveTransition m_StopAnimStruct;                                       // 0x06F0 (size: 0x90)
    FAnimStructMoveTransition m_UTurnAnimStruct;                                      // 0x0780 (size: 0x90)
    FAnimStructMoveTransition m_LandingAnimStruct;                                    // 0x0810 (size: 0x90)
    FAnimStructMoveTransition m_TurnInPlaceAnimStruct;                                // 0x08A0 (size: 0x90)
    EQuadrantTypes m_eAnimQuadrant;                                                   // 0x0930 (size: 0x1)
    float m_fFreeMoveV1V2ThresholdSpeed;                                              // 0x0938 (size: 0x4)
    FAnimStructAttack m_AttackStruct;                                                 // 0x0940 (size: 0x90)
    FAnimQuadrantStruct m_QuadrantStruct;                                             // 0x0AB0 (size: 0x4)
    FAnimContainer m_IdleAnimContainerFL;                                             // 0x0AB8 (size: 0x18)
    FAnimContainer m_IdleAnimContainerFR;                                             // 0x0AD0 (size: 0x18)
    FAnimContainer m_IdleAnimContainerBR;                                             // 0x0AE8 (size: 0x18)
    FAnimContainer m_IdleAnimContainerBL;                                             // 0x0B00 (size: 0x18)
    FBlendSpaceContainer m_IdleUpperBodyBlendSpaceContainerFL;                        // 0x0B18 (size: 0x10)
    FBlendSpaceContainer m_IdleUpperBodyBlendSpaceContainerFR;                        // 0x0B28 (size: 0x10)
    FBlendSpaceContainer m_IdleUpperBodyBlendSpaceContainerBR;                        // 0x0B38 (size: 0x10)
    FBlendSpaceContainer m_IdleUpperBodyBlendSpaceContainerBL;                        // 0x0B48 (size: 0x10)
    FBlendSpaceDirectionContainer m_LockMoveBlendSpace;                               // 0x0B58 (size: 0x20)
    FBlendSpaceDirectionContainer m_LockMoveUpperBodyBlendSpace;                      // 0x0B78 (size: 0x20)
    FAnimStructBase m_DodgeStruct;                                                    // 0x0BA0 (size: 0x90)
    FAnimStructOverride m_V0OverrideStruct;                                           // 0x0C40 (size: 0x90)
    TArray<class UAnimSequence*> m_GuardAnim;                                         // 0x0CE8 (size: 0x10)
    bool m_bGuardMirrorFrontRightBackLeft;                                            // 0x0CF8 (size: 0x1)
    TArray<class UAnimSequence*> m_GuardAnimWeapon;                                   // 0x0D00 (size: 0x10)
    TArray<class UAnimSequence*> m_GuardPrepAnim;                                     // 0x0D10 (size: 0x10)
    TArray<class UAnimSequence*> m_GuardPrepAnimWeapon;                               // 0x0D20 (size: 0x10)
    bool m_bGuardInProgress;                                                          // 0x0D30 (size: 0x1)
    float m_fGuardPrepRatio;                                                          // 0x0D34 (size: 0x4)
    FAnimStruct4 m_PlayAnimStruct;                                                    // 0x0D38 (size: 0x90)
    EOrderType m_ePlayAnimOrder;                                                      // 0x0DC8 (size: 0x1)
    uint8 m_uiPlayAnimState;                                                          // 0x0DC9 (size: 0x1)
    FAnimStructVariableWeight m_WeaponActionAnimStruct;                               // 0x0DD0 (size: 0x90)
    class UAnimSequence* m_LastActionAnim;                                            // 0x0E68 (size: 0x8)
    bool m_bLastActionAnimInMirror;                                                   // 0x0E70 (size: 0x1)
    float m_fLastActionAnimCursor;                                                    // 0x0E74 (size: 0x4)
    float m_fLastActionAnimIdealCursor;                                               // 0x0E78 (size: 0x4)
    FAnimStructHandPose m_HandPoseAnimStruct;                                         // 0x0E80 (size: 0x90)
    class UHandPoseDB* m_HandPoseDB;                                                  // 0x0F10 (size: 0x8)
    FAnimStructEmote m_EmoteAnimStruct;                                               // 0x0F20 (size: 0x90)
    FVector m_vOwnerVelocity;                                                         // 0x0FB4 (size: 0xC)
    float m_fOwnerVelocityLength;                                                     // 0x0FC0 (size: 0x4)
    float m_fOwnerVelocityMaxForV0Anim;                                               // 0x0FC4 (size: 0x4)
    float m_fOwnerVelocityMaxForV1Anim;                                               // 0x0FC8 (size: 0x4)
    float m_fOwnerVelocityMaxForV2Anim;                                               // 0x0FCC (size: 0x4)
    bool m_bIsBlendSpaceAngleValid;                                                   // 0x0FD0 (size: 0x1)
    float m_fBlendSpaceAngle;                                                         // 0x0FD4 (size: 0x4)
    float m_fBlendspaceAngleMirror;                                                   // 0x0FD8 (size: 0x4)
    FSpeedDescriptionStruct m_LockMoveSpeedDescription;                               // 0x0FE0 (size: 0x50)
    FSpeedDescriptionStruct m_FreeMoveV1SpeedDescription;                             // 0x1030 (size: 0x50)
    FSpeedDescriptionStruct m_FreeMoveV2SpeedDescription;                             // 0x1080 (size: 0x50)
    FSpeedDescriptionStruct m_FreeMoveV3SpeedDescription;                             // 0x10D0 (size: 0x50)
    float m_fProceduralLeanDeactivationDamping;                                       // 0x1120 (size: 0x4)
    float m_fProceduralLeanDamping;                                                   // 0x1124 (size: 0x4)
    float m_fProceduralLeanRatio;                                                     // 0x1128 (size: 0x4)
    float m_fProceduralLeanMaxAngle;                                                  // 0x112C (size: 0x4)
    float m_ProceduralLeanLerpTarget;                                                 // 0x1130 (size: 0x10)
    FRotator m_ProceduralLeanAngleRotator;                                            // 0x1140 (size: 0xC)
    FMovementMode m_MovementMode;                                                     // 0x1160 (size: 0xC)
    bool m_bCheatFlying;                                                              // 0x116C (size: 0x1)
    EFallLevel m_eFallLevel;                                                          // 0x116D (size: 0x1)
    FBlendSpaceStructBase m_PlayBlendSpaceStruct;                                     // 0x1170 (size: 0x90)
    FAnimStructVariableWeight m_FidgetAnimStruct;                                     // 0x1210 (size: 0x90)
    FAnimStructVariableWeight m_WeaponIdleAnimStruct;                                 // 0x12B0 (size: 0x90)
    FSCUserDefinedEnumHandler m_WeaponIdleVariableWeightLayer;                        // 0x1340 (size: 0x50)
    FAnimStructVariableWeight m_OpeningDoorAnimStruct;                                // 0x1390 (size: 0x90)
    FAnimContainer m_PickUpAnim;                                                      // 0x1428 (size: 0x18)
    FSCUserDefinedEnumHandler m_PickUpAnimVariableWeightLayer;                        // 0x1440 (size: 0x50)
    FAnimContainer m_DropWeaponAnim;                                                  // 0x1490 (size: 0x18)
    FSCUserDefinedEnumHandler m_DropWeaponAnimVariableWeightLayer;                    // 0x14A8 (size: 0x50)
    FAnimContainer m_HandSwapWeaponAnim;                                              // 0x14F8 (size: 0x18)
    FSCUserDefinedEnumHandler m_HandSwapWeaponAnimVariableWeightLayer;                // 0x1510 (size: 0x50)
    FName m_TraversalIKAnimInstanceName;                                              // 0x1560 (size: 0x8)
    bool m_bProceduralLandingActive;                                                  // 0x1568 (size: 0x1)
    bool m_bCascadeIsInSlope;                                                         // 0x15C0 (size: 0x1)
    bool m_bCascadeIsLethal;                                                          // 0x15C1 (size: 0x1)
    bool m_bRagdollInProgress;                                                        // 0x15D8 (size: 0x1)
    FName m_RagdollInProgressSnapshotName;                                            // 0x15DC (size: 0x8)
    float m_fWantedSpeed;                                                             // 0x15E4 (size: 0x4)
    FAnimContainer m_optimizationFrameAnimContainer;                                  // 0x15E8 (size: 0x18)
    FAnimContainer m_FreeMoveAnimContainer;                                           // 0x1600 (size: 0x18)
    FAnimContainer m_FreeMoveMirroredAnimContainer;                                   // 0x1618 (size: 0x18)
    FBlendSpaceDirectionContainer m_FreeMoveBlendSpaceV1;                             // 0x1630 (size: 0x20)
    FBlendSpaceDirectionContainer m_FreeMoveBlendSpaceV2;                             // 0x1650 (size: 0x20)
    FBlendSpaceDirectionContainer m_FreeMoveBlendSpaceV3;                             // 0x1670 (size: 0x20)
    FLookAtAnimHandler m_LookAtAnimHandler;                                           // 0x1690 (size: 0x488)
    bool m_bEyesLookAtEnabled;                                                        // 0x1B18 (size: 0x1)
    bool m_bLookAtEnabled;                                                            // 0x1B19 (size: 0x1)
    bool m_bOverridePoseWithSnapshot;                                                 // 0x1B1A (size: 0x1)
    FPoseSnapshot m_PoseSnapshotOverride;                                             // 0x1B20 (size: 0x38)
    float m_fPoseSnapshotOverrideBlend;                                               // 0x1B58 (size: 0x4)
    FAnimStructTraversal m_TraversalAnimStruct;                                       // 0x1B60 (size: 0x80)
    EQuadrantTypes m_eForcedQuadrant;                                                 // 0x1BE4 (size: 0x1)
    float m_fSpine1AlphaMax;                                                          // 0x1BE8 (size: 0x4)
    float m_fSpine2AlphaMax;                                                          // 0x1BEC (size: 0x4)
    float m_fSpine3AlphaMax;                                                          // 0x1BF0 (size: 0x4)
    float m_fSpine1Alpha;                                                             // 0x1BF4 (size: 0x4)
    float m_fSpine2Alpha;                                                             // 0x1BF8 (size: 0x4)
    float m_fSpine3Alpha;                                                             // 0x1BFC (size: 0x4)
    float m_fSpineModifsWeight;                                                       // 0x1C00 (size: 0x4)
    FVector m_vProceduralShakePelvisOffset;                                           // 0x1C04 (size: 0xC)
    float m_fProceduralShakePelvisWeight;                                             // 0x1C10 (size: 0x4)
    float m_fProceduralLandingPelvisHeight;                                           // 0x1C14 (size: 0x4)
    bool m_bFallInProgress1;                                                          // 0x1C18 (size: 0x1)
    bool m_bFallInProgress2;                                                          // 0x1C19 (size: 0x1)
    float m_fProceduralLandingWeight;                                                 // 0x1C1C (size: 0x4)
    EMoveDirections m_eVerticalMovementDirection;                                     // 0x1C20 (size: 0x1)
    EMoveDirections m_eHorizontalMovementDirection;                                   // 0x1C21 (size: 0x1)
    bool m_bUseUpperBodySyncLayer;                                                    // 0x1C22 (size: 0x1)
    float m_fHandPoseBlendWeight;                                                     // 0x1C24 (size: 0x4)
    bool m_bHandPoseBlendWeightIsNullOrNegative;                                      // 0x1C28 (size: 0x1)
    FMoveStatus m_MoveStatus;                                                         // 0x1C29 (size: 0x4)
    FSpeedState m_SpeedState;                                                         // 0x1C2D (size: 0x5)
    bool m_bOptimizationFrame;                                                        // 0x1C32 (size: 0x1)
    class UBaseMovementDB* m_BaseMovementDB;                                          // 0x1C38 (size: 0x8)
    bool m_bCarryAnimatedWeapon;                                                      // 0x1C40 (size: 0x1)
    bool m_bCarryWeapon;                                                              // 0x1C41 (size: 0x1)
    float m_fSpeedStateAlphaV0;                                                       // 0x1C44 (size: 0x4)
    float m_fSpeedStateAlphaV1;                                                       // 0x1C48 (size: 0x4)
    float m_fSpeedStateAlphaV2;                                                       // 0x1C4C (size: 0x4)
    float m_fSpeedStateAlphaV3;                                                       // 0x1C50 (size: 0x4)
    float m_fBodyPartDesynchronizationWeight;                                         // 0x1C54 (size: 0x4)
    FLocomotionTransitionsResultCache m_LocomotionTransitionsCache;                   // 0x1C58 (size: 0xA)
    float m_fSpineModifWeaponBlendDuration;                                           // 0x1C84 (size: 0x4)
    class UCurveVector* m_ProceduralShakeCurve;                                       // 0x1CA0 (size: 0x8)
    float m_fProceduralShakePlayRate;                                                 // 0x1CA8 (size: 0x4)
    float m_fProceduralShakeStrength;                                                 // 0x1CAC (size: 0x4)
    class UCurveFloat* m_ProceduralLandingCurve;                                      // 0x1CC0 (size: 0x8)
    float m_fProceduralLandingDuration;                                               // 0x1CC8 (size: 0x4)
    float m_fProceduralLandingBlendOutSpeed;                                          // 0x1CCC (size: 0x4)
    float m_fProceduralMediumLandingAmplitudeCoef;                                    // 0x1CD0 (size: 0x4)
    float m_fProceduralMediumLandingDurationCoef;                                     // 0x1CD4 (size: 0x4)
    class UCurveFloat* m_AnimLayerByStunCurve;                                        // 0x1CE8 (size: 0x8)
    float m_fAlphaSpine1MaxNoDrunken;                                                 // 0x1CF0 (size: 0x4)
    float m_fAlphaSpine2MaxNoDrunken;                                                 // 0x1CF4 (size: 0x4)
    float m_fAlphaSpine3MaxNoDrunken;                                                 // 0x1CF8 (size: 0x4)
    float m_fBlendSwitchWeaponFamilyDuration;                                         // 0x1CFC (size: 0x4)
    TArray<FAddVariableWeightInfo> m_VariableWeightAlphaByLayersReplication;          // 0x1EB0 (size: 0x10)
    TArray<FName> m_RemoveVariableWeightAlphaByLayersReplication;                     // 0x1EC0 (size: 0x10)
    TArray<FSetVariableWeightInfo> m_SetVariableWeightAlphaByLayersReplication;       // 0x1ED0 (size: 0x10)
    TArray<FOverridenVariableWeightInfo> m_VariableWeightOverridenAlphaByLayers;      // 0x1F30 (size: 0x10)
    float m_fVariableWeightIntoBlendTime;                                             // 0x1F40 (size: 0x4)
    float m_fVariableWeightOutOfBlendTime;                                            // 0x1F44 (size: 0x4)
    TSet<FName> m_SetOfStateToIgnoreInVariableWeight;                                 // 0x1F48 (size: 0x50)
    FName m_VariableWeightMasterStateName;                                            // 0x1F98 (size: 0x8)
    FName m_PlayAnimSubAnimInstanceTags;                                              // 0x1FB0 (size: 0x20)
    FName m_AttackSubAnimInstanceTags;                                                // 0x1FD0 (size: 0x10)
    FName m_LookAtSubAnimInstanceTag;                                                 // 0x1FE0 (size: 0x8)
    float m_fSpeedInterpolationForSpeedState;                                         // 0x1FE8 (size: 0x4)
    FSCUserDefinedEnumHandler m_LayerEnumForVariableWeight;                           // 0x1FF0 (size: 0x50)

    void OnRep_VariableWeightAlphaByLayers();
    void OnRep_SpeedState();
    void OnRep_SetVariableWeightAlphaByLayers();
    void OnRep_RemoveVariableWeightAlphaByLayers();
    void OnRep_OverridenAlpha();
    void OnRep_MoveStatus();
    void OnRep_MovementMode();
    void OnGlobalBehaviorChanged(EGlobalBehaviors _eBehavior, const bool _bFromDialog);
    bool IsV3Type(EMoveTransitionType _enumValue);
    bool IsV2Type(EMoveTransitionType _enumValue);
    bool IsV1Type(EMoveTransitionType _enumValue);
    bool IsUTurnV3Type(EMoveTransitionType _enumValue);
    bool IsUTurnV2Type(EMoveTransitionType _enumValue);
    bool IsUTurnV1Type(EMoveTransitionType _enumValue);
    bool IsUTurnType(EMoveTransitionType _enumValue);
    bool IsTurnInPlaceType(EMoveTransitionType _enumValue);
    bool IsStrafeV2Type(EMoveTransitionType _enumValue);
    bool IsStrafeV1Type(EMoveTransitionType _enumValue);
    bool IsStrafeType(EMoveTransitionType _enumValue);
    bool IsStopV3Type(EMoveTransitionType _enumValue);
    bool IsStopV2Type(EMoveTransitionType _enumValue);
    bool IsStopV1Type(EMoveTransitionType _enumValue);
    bool IsStopType(EMoveTransitionType _enumValue);
    bool IsStartV3Type(EMoveTransitionType _enumValue);
    bool IsStartV2Type(EMoveTransitionType _enumValue);
    bool IsStartV1Type(EMoveTransitionType _enumValue);
    bool IsStartType(EMoveTransitionType _enumValue);
    bool IsOrientedStartV3Type(EMoveTransitionType _enumValue);
    bool IsOrientedStartV2Type(EMoveTransitionType _enumValue);
    bool IsOrientedStartV1Type(EMoveTransitionType _enumValue);
    bool IsNorthStartV3Type(EMoveTransitionType _enumValue);
    bool IsNorthStartV2Type(EMoveTransitionType _enumValue);
    bool IsNorthStartV1Type(EMoveTransitionType _enumValue);
    bool IsNorthStartType(EMoveTransitionType _enumValue);
    bool IsLandingType(EMoveTransitionType _enumValue);
    EMoveTransitionType GetUTurnTypeFromAnimState(EMoveTransitionType _eCurrentTurnType, uint8 _uiAnimState);
    ESpeedState GetTransitionSpeedState(EMoveTransitionType _enumValue, bool _bSafe);
    ETransitionGlobalType GetTransitionGlobalType(EMoveTransitionType _eTransition);
    FVector GetTrackingPosition(ELimbs _eLimbs, int32 _iAttackStateID);
    float GetStateWeight(int32 _iStateID);
    FTransform GetSavedTransformFromSaveBone(ESaveBone _eSaveBone);
    FName GetSaveBoneAsName(ESaveBone _eSaveBone);
    EMoveTransitionType GetLastUTurnTransitionType();
    EMoveTransitionType GetLastStartTransitionType();
    FVector GetHitTargetPosition(ELimbs _eLimbs, int32 _iAttackStateID);
    float GetAimIKAlpha(ELimbs _eLimbs, int32 _iAttackStateID);
    void BPF_SetVariableWeightBlendDurationOverride(const FSCUserDefinedEnumHandler& _userEnum, bool _bBlendOut, bool _bOverride, float _fOverrideDuration);
    void BPF_SetSpineAlphaMax(float _fSpine1Alpha, float _fSpine2Alpha, float _fSpine3Alpha);
    void BPF_SetSpeedState(ESpeedState _eSpeedState);
    void BPF_SetMoveStatus(EMoveStatus _eMoveStatus);
    void BPF_ResetVariableWeightInfo();
    void BPF_RemoveVariableWeightActivation(const FSCUserDefinedEnumHandler& _userEnum);
    bool BPF_IsIntransition();
    float BPF_GetVariableWeightMirrorCoeff(const FSCUserDefinedEnumHandler& _userEnum);
    float BPF_GetVariableWeightAlpha(const FSCUserDefinedEnumHandler& _userEnum);
    void BPF_AddVariableWeightActivation(const FSCUserDefinedEnumHandler& _userEnum, bool _bMirror);
    void BPE_OnMoveStatusChanged();
}; // Size: 0x2080

class UPlayerFightingComponent : public UActorComponent
{
    bool m_bIsInDialog;                                                               // 0x00C8 (size: 0x1)
    FPlayerFightingComponentOnDialogStatusChanged OnDialogStatusChanged;              // 0x00D0 (size: 0x10)
    void DialogStatusChanged();
    FPlayerFightingComponentOnPropAttached OnPropAttached;                            // 0x00E0 (size: 0x10)
    void OnPropAttached(class AActor* _spawnedProp);
    FPlayerFightingComponentOnMeshChanged OnMeshChanged;                              // 0x0108 (size: 0x10)
    void OnMeshChanged(ECharacterGender _eNewGender, bool _bMustHandlePropSpawn);
    class UEquipmentSelectionData* m_DefaultEquipmentSelection;                       // 0x0118 (size: 0x8)
    float m_fLockMoveFadeDuration;                                                    // 0x0120 (size: 0x4)
    float m_fEnemyBehindDist;                                                         // 0x012C (size: 0x4)
    float m_fEnemyBehindCosAngle;                                                     // 0x0130 (size: 0x4)
    FPlayerGenderSpecificData m_ByGenderData;                                         // 0x0138 (size: 0xC0)
    TSoftObjectPtr<USkeletalMesh> m_ManSkeletalMeshPath;                              // 0x01F8 (size: 0x28)
    TSoftObjectPtr<USkeletalMesh> m_WomanSkeletalMeshPath;                            // 0x0220 (size: 0x28)
    TSoftObjectPtr<UBaseMovementDB> m_ManBaseMovementDBPath;                          // 0x0248 (size: 0x28)
    TSoftObjectPtr<UBaseMovementDB> m_WomanBaseMovementDBPath;                        // 0x0270 (size: 0x28)
    ECharacterGender m_eForcedGender;                                                 // 0x02B8 (size: 0x1)
    bool m_bFakePlayer;                                                               // 0x02C4 (size: 0x1)
    FName m_PlayerPositionMPCParameterName;                                           // 0x02C8 (size: 0x8)
    class AActor* m_AttachedProp;                                                     // 0x0300 (size: 0x8)
    int32 m_iOutfitIndex;                                                             // 0x031C (size: 0x4)

    void SetPropHidden(bool _bHidden);
    void OnTargetChangedCallback(class AActor* _oldTarget, class AActor* _newTarget);
    void OnStatsUpdated();
    void OnRep_OutfitIndex();
    void OnRep_Dialog();
    void OnPropAttached__DelegateSignature(class AActor* _spawnedProp);
    void OnMeshChanged__DelegateSignature(ECharacterGender _eNewGender, bool _bMustHandlePropSpawn);
    void OnLanded();
    void OnFalling();
    void DialogStatusChanged__DelegateSignature();
    void BPF_SwapOutfit(int32 _iNewOutfitIndex, class UMaterialInterface* _forcedMaterial, bool _bSpawnProps);
    void BPF_SwapMesh(const FOutfitData& _outfitData, class UMaterialInterface* _forcedMaterial);
    void BPF_SpawnPropFromCurrentOutfit();
    void BPF_SetIsInEndOfMovesetTutorial(bool _bActivate);
    void BPF_SetIsGameover(bool _bIsGameOver);
    void BPF_ServerSetIsInDialog(bool _bInDialog);
    void BPF_RemoveProp();
    bool BPF_IsGameOver();
    FPlayerGenderSpecificData BPF_GetCurrentGenderData();
}; // Size: 0x320

class UPlayerInputCondition : public UBaseActorCondition
{
    InputAction m_eInput;                                                             // 0x0028 (size: 0x1)
    bool m_bCheckAvailabilityLayers;                                                  // 0x0029 (size: 0x1)
    EPlayerInputConditionTestMethod m_eTestMethod;                                    // 0x002C (size: 0x4)
    FFloatRange m_AllowedVectorProjectedOnForward;                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

class UPlayerScoringComponent : public UActorComponent
{

    void OnOwnerTakedownStarted(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnOwnerKilledSomething(class AActor* _victim, bool _bIsOnlyAssist, bool _bKillingBlow, class AActor* _Instigator, const FDamageInfos& _damage);
    void OnOwnerAttackTaunt();
    void OnOwnerAttackFocus(class AVitalPointActor* _vitalPointSelected);
    void OnAvoidedAttackEnds(uint8 _iOrderID, class UOrderComponent* _OrderComponent);
    void OnAlertLevelChanged(EAlertLevel _eNewLevel);
    void BPF_SetScoringActive(bool _bActivate);
    void BPF_SetGlobalMultiplier(float _GlobalMultiplier);
    void BPF_SetFloorScore(float _newFloorScore);
    void BPF_ResetScoringValues();
    void BPF_ResetDiminishingQueue();
    void BPF_OnKnockdownAttackStarted(uint8 _orderID, class UOrderComponent* _OrderComponent);
    void BPF_InitializeFromDB();
    float BPF_GetFloorScoreToReachMaxMultiplier();
    float BPF_GetCurrentScore();
    float BPF_GetCurrentEfficiency();
    void BPF_ComputeHighScore(bool _bUpdateSave, float& _fCurrentSavedHighScore, float& _fCurrentLevelScore, bool& _bHighscoreIsNew);
    void BPE_ToggleFloorScore(bool _Freeze);
    bool BPE_ShouldDecrementFloorWhenFloorScoreIsZero();
    void BPE_OnUpdateFloorScore(float _FloorScore, float _MaxFloorScore);
    void BPE_OnUnbindCallbacks(class AFightingCharacter* _owner);
    void BPE_OnNewFloorReached(int32 _NewFloor, int32 _OldFloor);
    void BPE_OnNewEfficiency(float _fOld, float _fNew);
    void BPE_OnInitializeScoring();
    void BPE_OnFinalFloorReached();
    void BPE_OnBindCallbacks(class AFightingCharacter* _owner);
    bool BPE_IsSyncAttackKnockdown(const FSCUserDefinedEnumHandler& _BlueprintID);
    float BPE_GetScoreOnAIFriendlyHit();
    void BPE_GetScoreFromKill(EScoringKillType _KillType, float& _ScoreValue, bool& _NeedsDiminishing, bool& _AddToQueue, class UCurveFloat*& _DiminishingReturnCurve, float& _MaxDiminishingReturn, bool& _ImpactScoreStat);
    void BPE_GetScoreFromHitboxRowHandle(const FDataTableRowHandle& _hitboxRawHanlde, bool& _ActionFound, float& _ScoreValue, bool& _NeedsDiminishing, bool& _AddToQueue, class UCurveFloat*& _DiminishingReturnCurve, float& _MaxDiminishingReturn, bool& _ImpactScoreStat, bool& _ApplyMultiplierBonus);
    void BPE_GetScoreFromAttackDB(const class UAttackDB* _AttackDB, bool& _ActionFound, float& _ScoreValue, bool& _NeedsDiminishing, bool& _AddToQueue, class UCurveFloat*& _DiminishingReturnCurve, float& _MaxDiminishingReturn, bool& _ImpactScoreStat, bool& _ApplyMultiplierBonus);
    void BPE_GetScoreFromAction(InputAction _action, bool& _ActionFound, float& _ScoreValue, bool& _NeedsDiminishing, bool& _AddToQueue, class UCurveFloat*& _DiminishingReturnCurve, float& _MaxDiminishingReturn, bool& _ImpactScoreStat, bool& _ApplyMultiplierBonus);
    float BPE_GetScoreFocus(const FVitalPointDataDefinition& _VitalPointDef, class AFightingCharacter* _character);
    void BPE_GetScoreDefense(float& _ScoreValue, bool& _NeedsDiminishing, bool& _AddToQueue, class UCurveFloat*& _DiminishingReturnCurve, float& _MaxDiminishingReturn, bool& _ImpactScoreStat);
    int32 BPE_GetScoreArchetype(class UArchetypeAsset* _archetype);
    void BPE_GetMultiplierFloorValue(float _Floor, float& _FloorScoreForNextFloor, float& _FloorScoreRatioWhenEnteringFromLower, float& _FloorScoreRatioWhenEnteringFromUpper, FFloatRange& _BaseDecrementRateRange, FFloatRange& _CooldownBeforeDecrementRange);
    int32 BPE_GetMaxMultiplierFloor();
    float BPE_GetMalusOnHitStructureBrokenAI();
    float BPE_GetInactionTimeDuringInactivity();
    float BPE_GetInactionTime();
    int32 BPE_GetGlobalQueueSize();
    float BPE_GetFloorScoreToReachMaxMultiplier();
    float BPE_GetFloorScoreGlobalMalusRatioOnMCHit();
    int32 BPE_GetEfficiencyQueueSize();
    void BPE_GetEfficiencyMalusOnMCHit(float& _EfficiencyValue, int32& _NbOfOccurences);
    float BPE_GetEfficiencyCoeffInactiveAction();
    void BPE_GetEfficiencyBoundsFromActionType(EScoringActionType _ScoringActionType, bool& _ActionTypeFound, float& _MinEfficiency, float& _MaxEfficiency);
    class UCurveFloat* BPE_GetCurveForEfficiencyWeightByPlaceInQueue();
    float BPE_GetBonusOnWeaponHit(const class ABaseWeapon* _weapon);
    float BPE_GetBonusOnPunish();
    float BPE_GetBonusOnEnvironmentalKill(EScoringKillType _eScoringKillType, float _fTargetHealthBeforeKill);
    float BPE_GetBonusMCLifeMultiplier(class AFightingCharacter* _MCCharacter);
    void BPE_GetBonusKillStreak(int32 _KillCount, float& _BonusValue, float& _DurationBetweenKills);
    float BPE_GetAILifeBonus(class AFightingCharacter* _AICharacter);
    bool BPE_CanTargetGenerateScoring(class AFightingCharacter* _OpponentCharacter);
}; // Size: 0x2F8

class UPlayerTargetCondition : public UBaseActorCondition
{
    EActionType m_eAction;                                                            // 0x0028 (size: 0x1)
    bool m_bUpdateTarget;                                                             // 0x0029 (size: 0x1)
    FBaseActorTargetConditionInstance m_OptionalSubConditionOnTarget;                 // 0x0030 (size: 0x10)

}; // Size: 0x40

class UPopCurrentOrderFightingStateNotify : public USCAnimNotify
{
}; // Size: 0x48

class UPopupWidget : public USCUserWidget
{
    InputAction m_eValidateAction;                                                    // 0x0310 (size: 0x1)
    InputAction m_eCancelAction;                                                      // 0x0311 (size: 0x1)

    void OnMenuChanged(EMenuEnum _ePrevMenu, EMenuEnum _eNewMenu);
    void BPF_OnChoseB();
    void BPF_OnChoseA(int32 _playerID);
    void BPE_SetContent(const FText& _title, const FText& _message, const FText& _choiceA, const FText& _choiceB);
    bool BPE_IsUsingChoiceB();
    bool BPE_IsUsingChoiceA();
}; // Size: 0x3E0

class UPoseAssetNotifyState : public USCAnimNotifyState
{
    FSCPoseAssetSelection m_PoseAsset;                                                // 0x0048 (size: 0x10)
    bool m_bOverridePoseAsset;                                                        // 0x0058 (size: 0x1)
    bool m_bUseCustomEaseIn;                                                          // 0x0059 (size: 0x1)
    float m_fEaseInDuration;                                                          // 0x005C (size: 0x4)
    bool m_bUseCustomEaseOut;                                                         // 0x0060 (size: 0x1)
    float m_fEaseOutDuration;                                                         // 0x0064 (size: 0x4)
    int32 m_iSerializeVersion;                                                        // 0x0088 (size: 0x4)

}; // Size: 0x90

class UPostProcessAnimInstance : public USCAnimInstance
{
    bool m_bUseClothAnimDrive;                                                        // 0x0628 (size: 0x1)
    FName m_ClothAnimDriveCurveName;                                                  // 0x062C (size: 0x8)

}; // Size: 0x640

class UPredictionComponent : public UActorComponent
{
    bool m_bLocalPredictionOnly;                                                      // 0x00C8 (size: 0x1)

}; // Size: 0xD0

class UPredictionManager : public UObject
{
}; // Size: 0xD8

class UPreviewData : public UDataAsset
{
    FSlateColor m_RatingBonusTint;                                                    // 0x0030 (size: 0x28)
    FSlateColor m_RatingPenaltyTint;                                                  // 0x0058 (size: 0x28)
    FSlateColor m_RatingNormalTint;                                                   // 0x0080 (size: 0x28)
    FSlateColor m_PreviewBonusTint;                                                   // 0x00A8 (size: 0x28)
    FSlateColor m_PreviewPenaltyTint;                                                 // 0x00D0 (size: 0x28)
    FSlateColor m_NormalTint;                                                         // 0x00F8 (size: 0x28)
    FSlateColor m_ScaleTint;                                                          // 0x0120 (size: 0x28)

    FSlateColor BPF_GetColorForScaleComparison(float _fBase, float _fPreview);
    FSlateColor BPF_GetColorForRatingComparison(float _fBase, float _fPreview);
    FSlateColor BPF_GetColorForComparison(float _fBase, float _fPreview);
}; // Size: 0x148

class UProgressionDoorData : public UDataAsset
{
    FText m_ItemName;                                                                 // 0x0030 (size: 0x18)
    FText m_Description;                                                              // 0x0048 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_DisplayTexture;                                      // 0x0060 (size: 0x28)
    TSubclassOf<class USCUserWidget> m_NotificationWidget;                            // 0x0088 (size: 0x8)

}; // Size: 0x90

class UProgressionDoorNotification : public UBaseNotification
{
    class UQuestItemData* m_LastFulfilledQuest;                                       // 0x0030 (size: 0x8)
    FProgressionDoorStruct m_ProgressionDoorStruct;                                   // 0x0038 (size: 0x18)

    class UProgressionDoorNotification* BPF_Init(const FProgressionDoorStruct& _progressionDoorStruct, class UQuestItemData* _lastFulfilledQuest);
}; // Size: 0x50

class UProgressionRewardNotification : public UBaseNotification
{
    ECharacterProgressionRewardTypes m_eRewardType;                                   // 0x0030 (size: 0x1)
    FCharacterProgressionReward m_Reward;                                             // 0x0038 (size: 0x60)
    class UCharacterProgressionUnlockDB* m_Unlock;                                    // 0x0098 (size: 0x8)

    class UProgressionRewardNotification* BPF_Init(ECharacterProgressionRewardTypes _eRewardType, FCharacterProgressionReward _reward, class UCharacterProgressionUnlockDB* _unlock);
}; // Size: 0xA0

class UProxyActorsContainerComponent : public UActorComponent
{
    FProxyActorsContainerComponentOnTriggerProxyActor OnTriggerProxyActor;            // 0x00C0 (size: 0x10)
    void OnTriggerProxy(class AActor* _proxyActor);

    void UnregisterProxyActor(class AActor* _proxyActor);
    void RegisterProxyActor(class AActor* _proxyActor);
    void OnTriggerProxy__DelegateSignature(class AActor* _proxyActor);
}; // Size: 0xE0

class UPushConfiguration : public UObject
{
    float m_fPushEnvRedirectionLimitAngle;                                            // 0x0028 (size: 0x4)
    float m_fExpectedSnapDistance;                                                    // 0x002C (size: 0x4)
    float m_fLandingDistanceFromFloorToConsidereFall;                                 // 0x0030 (size: 0x4)
    float m_fDistanceFromEdgeToTestFloorHeight;                                       // 0x0034 (size: 0x4)
    float m_fFloorSearchDistance;                                                     // 0x0038 (size: 0x4)
    float m_fHeightSearchDistanceOnNormal;                                            // 0x003C (size: 0x4)

    void BPE_GetPushCloseTraversalAnimations(const FTraversalInfo& _request, ESCCardinalPoints _eCardinalPoint, class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, FPushTraversalAnimContainer& _outOnVoidResult);
    bool BPE_GetPushCloseAnimOnTraversal(class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, const FTraversalInfo& _traversalInfo, FPushAnims& _outAnimsClose, bool& _bGrabberShouldSnap, FHitBox& _hit);
    bool BPE_GetPushCloseAnimOnImpactHeight(class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, float _fHeight, FPushAnims& _outAnimsClose, bool& _bGrabberShouldSnap, FHitBox& _hit);
    void BPE_GetPushCloseAnimOnEnv(class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, class UBaseEnvironmentalInteractionComponent* _env, FPushAnims& _outAnimsClose, bool& _bGrabberShouldSnap, FHitBox& _hit);
    void BPE_GetPushAnims(class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, FPushAnims& _outAnims, FPushAnims& _outAnimsClose, bool& _bGrabberShouldSnap);
}; // Size: 0x40

class UPushHitActionLauncher : public UHitActionLauncher
{
    class UPushConfiguration* m_PushConfiguration;                                    // 0x0038 (size: 0x8)
    class UHitActionLauncher* m_fallbackHitAction;                                    // 0x0040 (size: 0x8)
    float m_fMaxAIWallDistance;                                                       // 0x0048 (size: 0x4)
    TSubclassOf<class UNavigationQueryFilter> m_filterClass;                          // 0x0050 (size: 0x8)
    bool m_bForceAIPushDirection;                                                     // 0x0058 (size: 0x1)
    float m_fForcedAILocalDirectionAngle;                                             // 0x005C (size: 0x4)

}; // Size: 0x60

class UPushInstigatorAbility : public USCGameplayAbility
{
    class UPushConfiguration* m_PushConfiguration;                                    // 0x0568 (size: 0x8)

    void BPF_HandleDefaultPush(const FSCGameplayAbilityActivationInfo& _activationInfo);
}; // Size: 0x570

class UPushObjMovementComponent : public UInterpToMovementComponent
{
    int32 m_iNumPoints;                                                               // 0x01A0 (size: 0x4)
    float m_fDist;                                                                    // 0x01A4 (size: 0x4)
    float m_fGroundTraceOffset;                                                       // 0x01A8 (size: 0x4)
    class UCurveFloat* m_SpeedCurve;                                                  // 0x01B0 (size: 0x8)
    TArray<float> m_SpeedSteps;                                                       // 0x01B8 (size: 0x10)
    float m_fMaxRotationSpeed;                                                        // 0x01F4 (size: 0x4)
    float m_fOnRailSpeedReduc;                                                        // 0x01F8 (size: 0x4)
    float m_fOnRailGravScale;                                                         // 0x01FC (size: 0x4)
    float m_fAngleTransitionTime;                                                     // 0x0200 (size: 0x4)
    float m_fShortenedDistThreshold;                                                  // 0x0204 (size: 0x4)
    float m_fSpeedOnRail;                                                             // 0x0208 (size: 0x4)
    float m_fTimeToReachSpeedOnRail;                                                  // 0x020C (size: 0x4)

    void BPF_SetObjectState(EPushableState _eState, bool _bResetIgnoreWhenMoving);
    float BPF_GetCurrentTime();
    int32 BPF_GetCurrentSpeedStep();
    void BPF_GenerateAndStartMovement(const FVector& _vDir, float _fStartStep);
    void BPF_CalculateMovementBox(const FVector& _vLastControlPoint, FBox& _OutBox);
    FVector BPF_CalculateLastPointLocation(const FVector& _vDir);
}; // Size: 0x238

class UPushObjectAnimRequest : public UObject
{

    class UAnimSequence* BPE_GetPushAnimation(const class AActor* _Instigator, const FVector& _vTargetDir, const class APushableActor* _pushable, bool& _bOutMirror);
}; // Size: 0x28

class UPushObjectNotify : public USCAnimNotify
{
}; // Size: 0x48

class UPushedObstacleComponent : public UActorComponent
{
    bool m_bActive;                                                                   // 0x00C0 (size: 0x1)
    EPushObstacleReaction m_ePushReaction;                                            // 0x00C4 (size: 0x4)
    FHitBox m_HitBox;                                                                 // 0x00C8 (size: 0x298)
    FPushedObstacleComponent_OnPushDetected m_OnPushDetected;                         // 0x0360 (size: 0x10)
    void PushSignature(class UPushedObstacleComponent* _component, class AFightingCharacter* _pushedPlayer);

    void PushSignature__DelegateSignature(class UPushedObstacleComponent* _component, class AFightingCharacter* _pushedPlayer);
    void BPE_OnPushInterruption(class AFightingCharacter* _interruptedCharacter);
    EPushObstacleReaction BPE_GetPushReaction(class AFightingCharacter* _pushedPlayer);
    bool BPE_GetPushInterruptionHit(class AFightingCharacter* _interruptedCharacter, FHitBox& _inOutResult);
}; // Size: 0x370

class UQuadrantHelper : public UBlueprintFunctionLibrary
{

    EQuadrantTypes BPF_Mirror(EQuadrantTypes _eQuadrant, bool _bMirror);
    EQuadrantTypes BPF_MakeQuadrant(bool _bIsFront, bool _bIsLeft);
    bool BPF_IsLeft(EQuadrantTypes _eQuadrant);
    bool BPF_IsFront(EQuadrantTypes _eQuadrant);
}; // Size: 0x28

class UQuestItemData : public UBaseItemData
{
    FText m_Description;                                                              // 0x0078 (size: 0x18)
    class UProgressionDoorData* m_ProgressionDoor;                                    // 0x0090 (size: 0x8)
    FName m_ScalarParameterName;                                                      // 0x0098 (size: 0x8)

}; // Size: 0xA0

class URagdollNotify : public UAnimNotify
{
    bool m_bRagdollEnabled;                                                           // 0x0038 (size: 0x1)
    bool m_bCollisionEnabled;                                                         // 0x0039 (size: 0x1)

}; // Size: 0x40

class URagdollOrderService : public UOrderService
{
}; // Size: 0x28

class URagingBullDB : public UDataAsset
{
    float m_fMaxAngularSpeed;                                                         // 0x0030 (size: 0x4)
    float m_fWantedSpeed;                                                             // 0x0034 (size: 0x4)
    float m_fWantedTravelDistance;                                                    // 0x0038 (size: 0x4)
    bool m_bStopOnTargetMissed;                                                       // 0x003C (size: 0x1)
    float m_fMissedTravelDistance;                                                    // 0x0040 (size: 0x4)
    FHitBox m_HitBox;                                                                 // 0x0048 (size: 0x298)
    FAnimContainer m_wallSplashFrontAnim;                                             // 0x02E0 (size: 0x18)
    FRagingBullAnimContainer m_entryAnimContainer;                                    // 0x02F8 (size: 0x18)
    int32 m_iAnimBuildUpFrames;                                                       // 0x0310 (size: 0x4)
    int32 m_iWantedBuildupFrames;                                                     // 0x0314 (size: 0x4)
    FRagingBullAnimContainer m_loopAnimContainer;                                     // 0x0318 (size: 0x18)
    float m_fDistanceToSwitchAnimation;                                               // 0x0330 (size: 0x4)
    FRagingBullAnimContainer m_secondLoopAnimContainer;                               // 0x0338 (size: 0x18)
    FRagingBullAnimContainer m_exitAnimContainer;                                     // 0x0350 (size: 0x18)

}; // Size: 0x368

class URagingBullRedirectToTrackedTargetOrderService : public URedirectToTrackedTargetOrderService
{
}; // Size: 0x48

class URandomAnimDB : public UDataAsset
{
    TArray<FSCConditionnalAnimContainer> m_Anims;                                     // 0x0030 (size: 0x10)

    FAnimContainer BPF_PickRandomAnim(class AActor* _requester);
}; // Size: 0x50

class URangeFeedbackUserWidget : public USCUserWidget
{
    class UCurveFloat* m_RemappingCurve;                                              // 0x0310 (size: 0x8)
    float m_fMinDefaultValue;                                                         // 0x0318 (size: 0x4)
    float m_fMaxDefaultValue;                                                         // 0x031C (size: 0x4)
    float m_fDefaultAlpha;                                                            // 0x0320 (size: 0x4)

    void BPE_OnDefaultValuesSet();
    void BPE_DisplayRangeValueFeedback(float _fValueAlpha);
}; // Size: 0x328

class URarityDB : public UDataAsset
{
    FRarityData m_RaritiesData;                                                       // 0x0030 (size: 0xF0)
    FRarityData m_DirtRarityData;                                                     // 0x0120 (size: 0x30)

    void BPF_GetRarityData(EGearRarity _rarity, FRarityData& _outRarityData);
}; // Size: 0x150

class URatingProgressBar : public UProgressBar
{
    int32 m_iImageCount;                                                              // 0x0318 (size: 0x4)
    int32 m_iSteps;                                                                   // 0x031C (size: 0x4)

}; // Size: 0x330

class UReattachStabbedWeapon_Notify : public USCAnimNotify
{
    FName m_BoneToAttachWeaponTo;                                                     // 0x0048 (size: 0x8)

}; // Size: 0x50

class URedirectOrderServiceNotifyState : public UOrderServiceNotifyState
{
    bool m_bUseAnimRootMotion;                                                        // 0x0068 (size: 0x1)
    ESCRotationWay m_eRootMotionRotWay;                                               // 0x0069 (size: 0x1)

}; // Size: 0x70

class URedirectToTargetOrderService : public UOrderService
{
    TSubclassOf<class UOrderService> m_StartAfterTargetService;                       // 0x0028 (size: 0x8)
    bool m_bUseAnimRootMotion;                                                        // 0x0030 (size: 0x1)
    bool m_bApplyEvenIfNoRootRotation;                                                // 0x0031 (size: 0x1)
    bool m_bForceAnimRotationWay;                                                     // 0x0032 (size: 0x1)
    ESCRotationWay m_eRootRotationWay;                                                // 0x0033 (size: 0x1)
    bool m_bUseTargetableActorComponentLocation;                                      // 0x0034 (size: 0x1)
    bool m_bWantLock;                                                                 // 0x0035 (size: 0x1)
    bool m_bUseFakeDirIfNoTarget;                                                     // 0x0036 (size: 0x1)
    bool m_bInvertDirOnBackQuadrant;                                                  // 0x0037 (size: 0x1)
    float m_fRedirectFrames;                                                          // 0x0038 (size: 0x4)
    float m_fMaxAngleFromTarget;                                                      // 0x003C (size: 0x4)
    float m_fMaxAngleFromStart;                                                       // 0x0040 (size: 0x4)
    ERedirectToTargetOrigin m_eRedirectionOrigin;                                     // 0x0044 (size: 0x1)
    EOrientationApplyMethod m_eOrientationApplyMethod;                                // 0x0045 (size: 0x1)

    FVector BPF_GetRedirectionOrigin(const FVector& _target, const FBPOrderServiceInstance& _instance);
    FVector BPE_GetTarget(const FBPOrderServiceInstance& _instance);
    float BPE_GetMaxAngularSpeed(const FBPOrderServiceInstance& _instance);
}; // Size: 0x48

class URedirectToTrackedTargetOrderService : public URedirectToTargetOrderService
{
}; // Size: 0x48

class URelationshipTypeCondition : public UBaseActorTargetCondition
{
    TArray<ERelationshipTypes> m_AllowedRelationshipTypes;                            // 0x0028 (size: 0x10)

}; // Size: 0x38

class UReplayActorSelectorComponent : public UActorComponent
{
    FReplayActorSelectorComponent_OnReceiveTraceResult m_OnReceiveTraceResult;        // 0x00C0 (size: 0x10)
    void OnReceivedTraceResultSignature(bool _bHasHit, float _fDistance);

    void BPF_RequestTrace();
}; // Size: 0xE0

class UReplayCineCameraComponent : public UCineCameraComponent
{
    float m_fZoomSpeed;                                                               // 0x08F0 (size: 0x4)
    class UCurveFloat* m_ZoomSpeedCurve;                                              // 0x08F8 (size: 0x8)

    FReplayKeyDataCameraSettings BPF_GetCameraSettings();
    void BPF_ApplyCameraSettings(FReplayKeyDataCameraSettings _settings);
}; // Size: 0x910

class UReplayCutManagement : public UObject
{
    class UReplayTimelineModel* m_Model;                                              // 0x0028 (size: 0x8)

    void BPF_RemoveCut(class UReplayKey* _key);
    bool BPF_CanAddCut(float _fDemoTime);
}; // Size: 0x38

class UReplayFightingCharacterComponent : public UActorComponent
{
    FReplayVoiceReplication m_VoiceInfos;                                             // 0x00C0 (size: 0x14)
    FReplayCameraTransform m_CameraTransform;                                         // 0x00E0 (size: 0x50)
    class AReplayingCamera* m_CameraDummy;                                            // 0x0188 (size: 0x8)

    void OnRep_VoiceInfos();
    void OnRep_CameraTransform();
}; // Size: 0x1A0

class UReplayGameWorldFunctionLibrary : public UBlueprintFunctionLibrary
{

    bool BPF_IsPhotomodeActivated(const class UObject* _worldContextObject);
    FString BPF_GetReplayActorUniqueID(const class AActor* _actor);
    class AFightingCharacter* BPF_GetMainCharacter(const class UObject* _worldContextObject);
    bool BPF_GetFinalLevelPostProcessSettings(class ASCPlayerController* _playerController, FPostProcessSettings& outPostProcessSettings);
    class UExponentialHeightFogComponent* BPF_GetExponentialHeightFog(const class UObject* _worldContextObject);
    float BPF_GetApplicationDeltaTime();
    TArray<class ASCCharacterImpostor*> BPF_GetActiveImpostors(const class UObject* _worldContextObject);
    TArray<class AFightingCharacter*> BPF_GetActiveAIs(const class UObject* _worldContextObject);
    TArray<class AActor*> BPF_GetActiveAIAndImpostors(const class UObject* _worldContextObject);
}; // Size: 0x28

class UReplayGameplayCameraRecordEventProxy : public UObject
{

    void BPF_DeserializeGameplayCameraEvent(const class UObject* _worldContextObject, FBPF_DeserializeGameplayCameraEventCallback _callback);
}; // Size: 0x28

class UReplayHelperLibrary : public UBlueprintFunctionLibrary
{

    void BPF_SetScreenMessagesEnabled(bool _bEnabled);
    void BPF_SaveReplayFilterProperties(const FFilterProperties& _inProperties, class ABaseReplayController* _controller);
    void BPF_SaveFilterPreset(int32 _iSlot, const FFilterProperties& _inProperties, class ABaseReplayController* _controller);
    FFilterProperties BPF_LoadReplayFilterProperties(class ABaseReplayController* _controller, bool& _bOutIsDefault);
    FFilterProperties BPF_LoadFilterPreset(int32 _iSlot, bool& _bIsValid);
    bool BPF_IsAvailabilityLayerPushed(const FAvailabilityLayerCache& _inALCache);
    bool BPF_HandleInput(const class ABaseReplayController* _controller, const FInputHandleContainer& _inputHandleContainer, bool _bIgnoreAvailability);
    void BPF_GetAnimSequences(TArray<FAnimSequenceDBEntry>& _outSequencesDB, const FAnimSequenceDBCache& _sequencesCache, const class ABaseWeapon* _weapon);
    bool BPF_FilterPresetComparison(const FFilterProperties& _first, const FFilterProperties& _second);
    void BPF_CancelAnyViewportFade(const class UObject* _worldContextObject);
    bool BPF_AreScreenMessagesEnabled();
    bool BPF_AreAvailabilityLayersPushed(const FAvailabilityLayerCaches& _inALCaches);
}; // Size: 0x28

class UReplayKey : public UObject
{
    FReplayKeyData m_Data;                                                            // 0x0030 (size: 0xC0)
    FReplayKey_OnDelete m_OnDelete;                                                   // 0x00F0 (size: 0x10)
    void OnReplayKeyEvent(class UReplayKey* _key);
    FReplayKey_OnPostDelete m_OnPostDelete;                                           // 0x0100 (size: 0x10)
    void OnReplayKeyEvent(class UReplayKey* _key);
    FReplayKey_OnIndexUpdate m_OnIndexUpdate;                                         // 0x0110 (size: 0x10)
    void OnReplayKeyIndexUpdate(class UReplayKey* _key, int32 _previousIndex, EReplayKeyIndexUpdateReason _eReason);
    FReplayKey_OnDataUpdate m_OnDataUpdate;                                           // 0x0120 (size: 0x10)
    void OnReplayKeyDataUpdate(class UReplayKey* _key, const FReplayKeyData& _previousData);
    FReplayKey_OnTransitionUpdate m_OnTransitionUpdate;                               // 0x0130 (size: 0x10)
    void OnReplayKeyTransitionUpdate(class UReplayKey* _key, bool _bIsOnTransition);
    FReplayKey_OnSelectionUpdate m_OnSelectionUpdate;                                 // 0x0140 (size: 0x10)
    void OnReplayKeySelectionUpdate(class UReplayKey* _key, bool _bIsSelected);
    FReplayKey_OnHoveredUpdate m_OnHoveredUpdate;                                     // 0x0150 (size: 0x10)
    void OnReplayKeyHoveredUpdate(class UReplayKey* _key, bool _bIsHovered);
    FReplayKey_OnTimeUpdate m_OnTimeUpdate;                                           // 0x0160 (size: 0x10)
    void OnReplayKeyTimeUpdate(class UReplayKey* _key, float _fTime);

    bool BPF_HasReplayKeyType(int32 _iKeyTypeFlags, int32 _iContainsKeyTypeFlags);
    bool BPF_HasActiveBlend();
}; // Size: 0x170

class UReplayKeyWidget : public UButtonUserWidget
{
    bool m_bIsKeySelected;                                                            // 0x0820 (size: 0x1)
    bool m_bIsKeyHovered;                                                             // 0x0821 (size: 0x1)
    FVector2D m_vSize;                                                                // 0x0824 (size: 0x8)
    class UReplayKeyWidgetVisualsDB* m_VisualsDB;                                     // 0x0830 (size: 0x8)
    class UReplayKey* m_Key;                                                          // 0x0838 (size: 0x8)
    FVector2D m_vCachedTimelinePositionWithMargin;                                    // 0x0840 (size: 0x8)
    FVector2D m_vCachedTimelinePosition;                                              // 0x0848 (size: 0x8)
    bool m_bCachedTimelineIsOutOfBounds;                                              // 0x0850 (size: 0x1)
    FReplayKeyWidget_OnKeyMoved m_OnKeyMoved;                                         // 0x0858 (size: 0x10)
    void ReplayKeyWidgetStateChanged(const class UReplayKeyWidget* _widget);

    void BPE_OnSelectionUpdate(class UReplayKey* _key, bool _bIsSelected);
    void BPE_OnHoveringStateUpdate(class UReplayKey* _key, bool _bIsHovered);
    bool BPE_ApplyVisualsOverride(const FReplayKeyWidgetVisualKey& _key, FVector2D& _vSize);
    void BPE_ApplyVisuals(const FReplayKeyWidgetVisualData& _visuals);
}; // Size: 0x888

class UReplayKeyWidgetVisualsDB : public UDataAsset
{
    TMap<class FReplayKeyWidgetVisualKey, class FReplayKeyWidgetVisualData> m_Visuals; // 0x0030 (size: 0x50)
    FReplayKeyWidgetVisualData m_DefaultVisual;                                       // 0x0080 (size: 0x18)

}; // Size: 0x98

class UReplayLevelStreamingReplication : public UObject
{
    FSCReplayLevelStreamingData m_StreamingState;                                     // 0x0038 (size: 0xA8)

}; // Size: 0x140

class UReplayLoadingScreenWidget : public USCUserWidget
{
    int32 m_iZIndex;                                                                  // 0x0310 (size: 0x4)
    bool m_bIsHidding;                                                                // 0x0314 (size: 0x1)

    void BPF_NotifyHideCompleted();
    void BPE_OnHideRequested();
    void BPE_OnHideCancelled();
}; // Size: 0x318

class UReplayMainUserWidget : public UReplayMenuWidget
{
    FReplayTimelineControl m_TimelineControl;                                         // 0x03E0 (size: 0x38)
    bool m_bUIInitialized;                                                            // 0x0418 (size: 0x1)
    bool m_bAutoSelectKeyOnAdd;                                                       // 0x0419 (size: 0x1)
    bool m_bOnlyApplyPersistentSettingsOnCustomCameraKeys;                            // 0x041A (size: 0x1)
    bool m_bOnApplyCameraSettingsSetCameraModeToCustom;                               // 0x041B (size: 0x1)
    bool m_bSelectKeyOnGoToTimeCompleted;                                             // 0x041C (size: 0x1)
    bool m_bOnSelectFailDefaultToSelectedKey;                                         // 0x0430 (size: 0x1)
    class UReplayTimelineWidget* m_TimelineWidget;                                    // 0x0438 (size: 0x8)
    FReplayAvailabilityLayerCache m_AvailabilityLayers;                               // 0x0440 (size: 0x120)

    bool OnTimelineModePressed();
    void OnKeyRemoved(class UReplayKey* _key);
    void OnKeyAdded(class UReplayKey* _key, bool _bCanSelectKey);
    void BPF_ToggleTimelineMode();
    void BPF_SetSelectedKeyLookAtTarget(const class AActor* _actor);
    void BPF_SetSelectedKeyFollowTarget(const class AActor* _actor);
    void BPF_SetInPreviewMode(bool _bInPreview);
    void BPF_SetInMoveKeyState(const bool _bMovingKey);
    bool BPF_SelectPreviousKey();
    bool BPF_SelectNextKey();
    bool BPF_SelectKeyAndGoToTime(class UReplayKey* _key);
    bool BPF_SelectKey(class UReplayKey* _key);
    void BPF_ResetTimelineControlAndScrub();
    void BPF_ResetSavedCameraTransform();
    bool BPF_RemoveSelectedKeyCut();
    bool BPF_RemoveSelectedKey();
    bool BPF_RemoveHoveredKey();
    void BPF_PasteKey();
    void BPF_NotifySelectedKeyTimeDilationUpdate();
    void BPF_NotifySelectedKeyCameraModeUpdated();
    void BPF_MoveTimelineCursor(ECycleDirection _eDirection, EReplayTimelineControlType _eControlType);
    void BPF_LeavePasteKeyMode();
    bool BPF_IsInMoveKeyState();
    bool BPF_IsInKeyPastingMode();
    bool BPF_HasSelectedOrHoveredKey();
    bool BPF_HasKeySelected();
    void BPF_GoToTime(class UReplayKey* _key);
    class UReplayKey* BPF_GetSelectedKey();
    class AReplayController* BPF_GetReplayController();
    class UReplayKey* BPF_GetKeyFromCurrentDemoTime(ECycleDirection _eDirection);
    bool BPF_GetIsMovingTimelineCursor();
    bool BPF_GetIsInPreviewMode();
    void BPF_CreateKeyWidgets();
    void BPF_CopySelectedKey();
    bool BPF_CanApplyCurrentCineCameraSettingsAndPositionToKey(const class UReplayKey* _key);
    bool BPF_CanApplyCurrentCineCameraSettingsAndPositionToCurrentTime();
    void BPF_ApplyCurrentCineCameraSettingsAndPositionToKey(class UReplayKey* _key, bool _bApplyPosition, bool _bApplyLensSettings, bool _bApplyFocusSettings);
    class UReplayKey* BPF_AddKeyAtCurrentTime(int32 _iTypeFlags, const FReplayKeyData _presetData, int32 _iPresetOverride, bool& _bOutKeyAlreadyExists);
    void BPF_AddCutAtCurrentTime(const FReplayKeyData _presetData, int32 _iPresetOverride);
    bool BPE_OnVideoRecordingStop();
    void BPE_OnUndoOrRedoPressed(const ETimelineStateAction _eAction, const FTimelineChangeState& _changeState);
    bool BPE_OnTimelineZoom(float _fActionValue);
    bool BPE_OnTimelineMoveForwardPressed();
    bool BPE_OnTimelineMoveBackwardPressed();
    void BPE_OnTimelineModeToggled();
    bool BPE_OnSpecialMenuPressed();
    bool BPE_OnSelectRightKeyPressed();
    bool BPE_OnSelectLeftKeyPressed();
    void BPE_OnSelectedKeyDataUpdate(class UReplayKey* _key, const FReplayKeyData& _previousData);
    bool BPE_OnSelectCurrentKeyPressed();
    bool BPE_OnScrubReleased();
    bool BPE_OnResumePressed();
    bool BPE_OnReplayQuitPressed();
    bool BPE_OnReplayJumpStart();
    bool BPE_OnReplayJumpEnd();
    bool BPE_OnRemoveKeyPressed();
    bool BPE_OnRemoveCutPressed();
    void BPE_OnPreviewModeChanged(bool _bInPreview);
    bool BPE_OnPasteKeyPressed();
    bool BPE_OnNavigationModePressed();
    bool BPE_OnMoveKeyRightPressed();
    bool BPE_OnMoveKeyReleased();
    bool BPE_OnMoveKeyLeftPressed();
    void BPE_OnKeySelectionUpdate(class UReplayKey* _key, bool _bSelected);
    void BPE_OnKeySelected(class UReplayKey* _key);
    void BPE_OnKeyRemoved(class UReplayKey* _key);
    void BPE_OnKeyPastedOn(class UReplayKey* _key, bool _bIsNew);
    void BPE_OnKeyAdded(class UReplayKey* _key);
    void BPE_OnGoToTimeInitiated(bool _bUnselectKey);
    void BPE_OnGoToTimeCompleted();
    bool BPE_OnEditReplayPressed();
    bool BPE_OnEditCameraPressed();
    void BPE_OnCutCreated();
    bool BPE_OnCopyKeyPressed();
    void BPE_OnCameraModeChanged(EReplayCameraMode _eCameraMode);
    bool BPE_OnApplySettingsPressed();
    bool BPE_OnAddSpeedKeyPressed();
    bool BPE_OnAddKeyPressed();
    bool BPE_OnAddCutPressed();
}; // Size: 0x6F0

class UReplayManagement : public UObject
{
    class UReplaySaveGame* m_ReplaySaveGame;                                          // 0x0030 (size: 0x8)
    FReplayManagement_OnTaskStateChanged m_OnTaskStateChanged;                        // 0x0038 (size: 0x10)
    void OnTaskStateChangedSignature(bool _bIsTaskRunning, FString _taskName);

    void OnStreamingCompleteQuitReplayManagement();
    void OnQuitReplayManagementMenu(bool _bIsPlayingReplay);
    void BPF_SetReplayOpenState(const EReplayOpenState _eOpenState);
    void BPF_ResetReplayEditorMetaDataWithCallback(FString _replayID, const FBPF_ResetReplayEditorMetaDataWithCallbackCallback& _callback);
    void BPF_ResetReplayEditorMetaData(FString _replayID);
    bool BPF_IsReplayVersionCompatible(int32 _iReplayVersion, int32 _iChangeList);
    bool BPF_IsCurrentReplay(FString _replayID);
    bool BPF_HasSpaceForNewReplay(const FReplaySizeManagement& _inSizeManagement);
}; // Size: 0x98

class UReplayManagementMenuWidget : public UMenuWidget
{
    FReplayManagementMenuWidget_OnQuitReplayManagementMenu m_OnQuitReplayManagementMenu; // 0x03D8 (size: 0x10)
    void OnQuitReplayManagementMenu(bool _bHasLaunchedReplay);

    void BPF_PlayReplay(const FReplayInfo& _info);
    void BPF_EnumerateStreams();
    void BPF_EditReplay(const FReplayInfo& _info);
    void BPF_DeleteReplays(const FReplayListInfo& _infos);
    void BPF_DeleteReplay(const FReplayInfo& _info);
    void BPE_OnStreamsEnumerated(bool _bError, const FReplayListInfo& _replayInfos);
    void BPE_OnStreamsDeletedProgress(bool _bError, const FReplayListInfo& _initialState, const FReplayListInfo& _currentState);
    void BPE_OnStreamsDeleted(bool _bError);
    void BPE_OnStreamDeleted(bool _bError);
}; // Size: 0x3E8

class UReplayMenuAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UReplayMenuWidget : public USCUserWidget
{
    TSubclassOf<class UReplayScreenshotUserWidget> m_ScreenshotWidgetClass;           // 0x0370 (size: 0x8)
    TSubclassOf<class UReplayUIModeUserWidget> m_HideUIModeClass;                     // 0x0378 (size: 0x8)
    class UReplayScreenshotUserWidget* m_ScreenshotWidget;                            // 0x0380 (size: 0x8)
    class UReplayUIModeDB* m_UIModeDB;                                                // 0x0388 (size: 0x8)
    TArray<class UReplayUIModeUserWidget*> m_UIModes;                                 // 0x0390 (size: 0x10)
    TArray<class UReplayUIModeUserWidget*> m_UIOverlays;                              // 0x03A0 (size: 0x10)
    FReplayMenuWidget_OnOverlayChange m_OnOverlayChange;                              // 0x03B0 (size: 0x10)
    void OnOverlayChangedSignature(const class UReplayUIModeUserWidget* _currentOverlay, const class UReplayUIModeUserWidget* _nextOverlay);
    class ABaseReplayController* m_Controller;                                        // 0x03C0 (size: 0x8)
    TArray<class UReplaySubMenuWidget*> m_SubMenus;                                   // 0x03C8 (size: 0x10)
    bool m_bUpdateUIModeOnMenuPushed;                                                 // 0x03D8 (size: 0x1)

    void BPF_RestoreOverlay();
    bool BPF_PushSubMenu(class UReplaySubMenuWidget* _subMenu, class UReplaySubMenuWidget* _parentSubMenu);
    bool BPF_PopSubMenuIfTop(const class UReplaySubMenuWidget* _subMenu);
    class UReplaySubMenuWidget* BPF_PopSubMenu();
    bool BPF_PopMenuAndAllChildren(const class UReplaySubMenuWidget* _subMenu);
    class UReplaySubMenuWidget* BPF_PeekSubMenu();
    void BPF_LeaveCurrentUIMode();
    bool BPF_IsSubMenuOnTop(const class UReplaySubMenuWidget* _subMenu);
    bool BPF_IsSubMenuOnStack(const class UReplaySubMenuWidget* _subMenu);
    class UReplayUIModeUserWidget* BPF_GetNextOverlay();
    class UReplayUIModeUserWidget* BPF_GetCurrentUIMode();
    void BPF_EnterUIMode(TSubclassOf<class UReplayUIModeUserWidget> _UIModeClass);
    void BPF_CycleUIOverlay();
    void BPF_CloseAllSubMenu(const class UReplaySubMenuWidget* _parent);
    bool BPE_OnTakeScreenshotPressed();
    void BPE_OnRemovedFromParent();
    bool BPE_OnMenuRightPressed();
    bool BPE_OnMenuOptionsPressed();
    bool BPE_OnMenuLeftPressed();
    bool BPE_OnMenuInputPressed(InputAction _eAction);
    bool BPE_OnMenuBackKeyPressed();
    bool BPE_OnMenuActionPressed();
    bool BPE_OnLeaveModePressed();
    bool BPE_OnHideUIPressed();
    bool BPE_OnExportPressed();
    bool BPE_OnCycleUIModePressed();
    bool BPE_OnCharacterSettingsPressed();
    bool BPE_OnCameraSettingsPressed();
    bool BPE_OnApplyFocusPressed();
    void BPE_OnAnyInputConsumed();
}; // Size: 0x3E0

class UReplaySaveGame : public UObject
{
    int64 m_iReplayMaxSizeStopRecordingTolerance;                                     // 0x0028 (size: 0x8)
    int64 m_iReplayTotalMaxSize;                                                      // 0x0030 (size: 0x8)
    int64 m_iTotalSaveGameSpaceAvailableForReplays;                                   // 0x0038 (size: 0x8)
    int64 m_iDesktopTotalSaveGameSpaceAvailableForReplays;                            // 0x0040 (size: 0x8)
    int64 m_iReplayEditorMedataDataSize;                                              // 0x0048 (size: 0x8)
    int64 m_iReplayFileMetaDataSize;                                                  // 0x0050 (size: 0x8)

    FString BPE_GetTitleInfoForSaveFile(FString _fileName, bool _bIsMetaData);
    FString BPE_GetSubtitlesInfoForSaveFile(bool _bIsMetaData);
    class UTexture2D* BPE_GetIconForSaveFile();
    FString BPE_GetDetailsInfoForSaveFile(bool _bIsMetaData);
}; // Size: 0x58

class UReplayScreenshotUserWidget : public USCUserWidget
{
    bool m_bTakeScreenshotOnCooldown;                                                 // 0x0310 (size: 0x1)
    FAvailabilityLayerCaches m_AvailabilityLayers;                                    // 0x0318 (size: 0x18)

    void BPF_RequestScreenshot(int32 _iResolutionX, int32 _iResolutionY);
    class ABaseReplayController* BPF_GetReplayController();
    void BPE_OnScreenshotRequestProcessed();
    void BPE_OnScreenshotRequested();
}; // Size: 0x338

class UReplaySoundReplication : public UObject
{
    FSoundReplicationData m_SoundReplicationData;                                     // 0x0028 (size: 0xA0)

    void SetRTPCValue(uint32 _rtpc, FString _rtpcName, float _akRtpcValue, int32 _iInterpolationTimeMs, class AActor* _actor);
}; // Size: 0xE0

class UReplaySpectatorPawnMovement : public USpectatorPawnMovement
{

    void BPF_SetDirectionConstraintDelegate(FBPF_SetDirectionConstraintDelegateDelegate _delegate);
    FVector BPF_GetConstrainedDirection(const FVector& _vLeashOrigin, const FVector& _vLeashSize, const FVector& _vCurrentLocation, const FVector& _vDirection, bool& _bOutConstrained);
}; // Size: 0x178

class UReplaySubMenuWidget : public USCUserWidget
{
    TSubclassOf<class UCustomWidgetNavigation> m_CustomWidgetNavigationClass;         // 0x0310 (size: 0x8)
    class UCustomWidgetNavigation* m_CustomWidgetNavigation;                          // 0x0318 (size: 0x8)
    class UReplaySubMenuWidget* m_ParentSubMenu;                                      // 0x0320 (size: 0x8)

    bool BPF_IsSubMenuAvailable(const class UReplaySubMenuWidget* _menu);
    void BPF_BindIsSubMenuAvailableDelegate(const FBPF_BindIsSubMenuAvailableDelegateDelegate& _delegate);
    void BPE_OnRemovedFromParent();
    bool BPE_OnMenuPushRequest(class UReplayMenuWidget* _parent, class UReplaySubMenuWidget* _previousMenu, class UReplaySubMenuWidget* _parentSubMenu);
    void BPE_OnMenuPushed(class UReplaySubMenuWidget* _previousMenu, class UReplaySubMenuWidget* _parentSubMenu);
    bool BPE_OnMenuPopRequest(class UReplayMenuWidget* _parent);
    void BPE_OnMenuPopped();
}; // Size: 0x338

class UReplaySystem : public UObject
{
    FReplaySystemOnTimeDilationChanged OnTimeDilationChanged;                         // 0x0030 (size: 0x10)
    void ReplayTimeDilationChangeDelegate(float _fTimeDilation);
    FReplaySystem_OnRecordingStreamingCompleted m_OnRecordingStreamingCompleted;      // 0x0058 (size: 0x10)
    void OnRecordingComplete();
    FReplaySystem_OnRecordingChanged m_OnRecordingChanged;                            // 0x0068 (size: 0x10)
    void OnReplayRecordingChanged(bool _bRecording);
    FReplaySystem_OnReplayFeedbackEvent m_OnReplayFeedbackEvent;                      // 0x0078 (size: 0x10)
    void ReplayFeedbackEventSignature(EReplayFeedbackEvent _eEvent);
    FReplaySystem_OnDemoFinishPlayback m_OnDemoFinishPlayback;                        // 0x0088 (size: 0x10)
    void DynamicMulticast();
    bool m_bTimeDilationReplicated;                                                   // 0x0098 (size: 0x1)
    bool m_bPauserPlayerStateReplicated;                                              // 0x0099 (size: 0x1)
    class UThePlainesGameInstance* m_GameInstance;                                    // 0x00A0 (size: 0x8)
    class UReplayLevelStreamingReplication* m_ReplayStreaming;                        // 0x00A8 (size: 0x8)
    class UReplaySoundReplication* m_ReplaySound;                                     // 0x00B0 (size: 0x8)
    class UReplayManagement* m_ReplayManagement;                                      // 0x00B8 (size: 0x8)
    float m_fReplayStartVislogTimeS;                                                  // 0x00E8 (size: 0x4)
    TArray<FReplayInitialStateToggleEvent> m_InitialStateToggleEvents;                // 0x0120 (size: 0x10)

    void ReplaySpaceStatusDelegate__DelegateSignature(const FReplaySizeManagement& _sizeManagement, bool _bHasSpaceForNewReplay);
    void BPF_StopRecordingAndContinueWith(class APlayerController* _controller, FBPF_StopRecordingAndContinueWithOnContinue _onContinue, const EReplayStopRecordingReason _eReason);
    void BPF_StopRecording(const EReplayStopRecordingReason _eReason);
    void BPF_StartReplay(FString _replayID);
    void BPF_StartRecording();
    void BPF_SetPlayingPlayerCharacter(class AFightingCharacter* _character, const class UObject* _worldContextObject);
    void BPF_SetDemoPlayTimeDilation(const class UObject* _worldContextObject, float _fDilation);
    void BPF_ReplayStopRecording(const class UObject* _worldContextObject, const EReplayStopRecordingReason _eReason);
    void BPF_ReplayStartRecording(const class UObject* _worldContextObject);
    void BPF_ReplayStartPlaying(const class UObject* _worldContextObject);
    void BPF_RegisterInitialStateEvent(FBPF_RegisterInitialStateEventEvent _event, class AActor* _Instigator, FBPF_RegisterInitialStateEventGetValueEvent _getValueEvent);
    void BPF_QueryReplaySpaceStatus(const class UObject* _worldContextObject, FBPF_QueryReplaySpaceStatusCallback _callback);
    void BPF_PushPopPauseRecording(int32& _iInOutTag, FString _context, const bool _bPush, const class UObject* _worldContextObject);
    void BPF_PushPopDisableRecording(int32& _iInOutTag, FString _context, const bool _bPush, const class UObject* _worldContextObject, const EReplayStopRecordingReason _eReason);
    bool BPF_MustUpdateMaxFPS();
    bool BPF_IsRecordingDisabled(const class UObject* _worldContextObject);
    bool BPF_IsRecording(const class UObject* _worldContextObject);
    bool BPF_IsReadyForPlaying(const class UObject* _worldContextObject);
    bool BPF_IsPlaying(const class UObject* _worldContextObject);
    bool BPF_IsKeepingReplay();
    bool BPF_IsDemoPlayPaused(const class UObject* _worldContextObject);
    bool BPF_IsCurrentDemoTimeSnapped(const class UObject* _worldContextObject);
    float BPF_GetVislogGameplayTimeS();
    EReplayStopRecordingReason BPF_GetStopRecordingReason(const class UObject* _worldContextObject, bool& _bOutIsRecording);
    float BPF_GetSnappedDemoTime(float _fDemoTimeS, bool _bCheckClosestFrame);
    class UReplaySystem* BPF_GetReplaySystem(const class UObject* _worldContextObject);
    class UReplayManagement* BPF_GetReplayManagement(const class UObject* _worldContextObject);
    class AReplayController* BPF_GetReplayController(const class UObject* _worldContextObject);
    class AFightingCharacter* BPF_GetPlayingPlayerCharacter(const class UObject* _worldContextObject);
    int32 BPF_GetKeyFrameIndexFromDemoTime(float _fDemoTimeS, bool _bCheckClosestFrame);
    float BPF_GetDemoTimeFromKeyFrameIndex(int32 _iKeyFrameIndex);
    float BPF_GetDemoPlayTimeDilation(const class UObject* _worldContextObject);
    class USCDemoNetDriver* BPF_GetDemoNetDriver(const class UObject* _worldContextObject);
    bool BPF_GetCurrentReplayRecordingData(FReplayCurrentRecordingData& _inoutData);
    float BPF_GetCurrentReplayLengthS(const class UObject* _worldContextObject);
    float BPF_GetCurrentReplayLengthMS(const class UObject* _worldContextObject);
    float BPF_GetCurrentDemoTimeS(const class UObject* _worldContextObject);
    float BPF_GetActorLastReplicationTime(class AActor* _actor);
    bool BPF_CanStartRecording(const class UObject* _worldContextObject);
}; // Size: 0x228

class UReplayTimelineContainerBase : public UUserWidget
{

    TScriptInterface<class IReplayWidgetHandler> BPF_GetWidgetHandler();
}; // Size: 0x278

class UReplayTimelineController : public UObject
{
    FReplayTimelineController_OnModelReset m_OnModelReset;                            // 0x0048 (size: 0x10)
    void DynamicMulticast();
    class UReplayCutManagement* m_CutManagement;                                      // 0x0058 (size: 0x8)
    class UReplayTimelineModel* m_Model;                                              // 0x0060 (size: 0x8)
    FReplayTimelineController_OnTimeDilationChanged m_OnTimeDilationChanged;          // 0x0068 (size: 0x10)
    void OnTimeDilationChangedSignature(float _fPreviousTimeDilation, float _fCurrentTimeDilation);

    void BPF_SaveKeysWithCallback(const FBPF_SaveKeysWithCallbackOnModelSaved& _onModelSaved);
    void BPF_SaveKeys();
    void BPF_ResetTransitionContext();
    void BPF_ResetModelWithCallback(const FBPF_ResetModelWithCallbackOnModelSaved& _onModelSaved);
    void BPF_ResetModel();
    void BPF_ResetFocusTargetTransitionContext();
    class UReplayKey* BPF_GetCurrentKeyWithCameraTransition();
    class UReplayKey* BPF_GetCurrentKeyOfType(EReplayKeyTypeFlag _eTypeFlag);
}; // Size: 0x1F0

class UReplayTimelineModel : public UObject
{
    FReplayTimelineModel_OnKeyAdded m_OnKeyAdded;                                     // 0x0028 (size: 0x10)
    void OnKeyAddedSignature(class UReplayKey* _key, bool _bCanSelectKey);
    FReplayTimelineModel_OnKeyRemoved m_OnKeyRemoved;                                 // 0x0038 (size: 0x10)
    void OnReplayKeyEvent(class UReplayKey* _key);
    FReplayTimelineModel_OnRecalcDilatedTime m_OnRecalcDilatedTime;                   // 0x0048 (size: 0x10)
    void OnTimelineRecalcDilatedTimeSignature(int32 iRecalcStartIndex);
    FName m_ChosenMusicForExport;                                                     // 0x005C (size: 0x8)
    TArray<class UReplayKey*> m_Keys;                                                 // 0x0068 (size: 0x10)
    FFilterProperties m_FilterProperties;                                             // 0x0078 (size: 0x38)

    void OnTimelineRecalcDilatedTimeSignature__DelegateSignature(int32 iRecalcStartIndex);
    void OnKeyAddedSignature__DelegateSignature(class UReplayKey* _key, bool _bCanSelectKey);
    void BPF_UpdateKeyLocationData(class UReplayKey* _key, const FVector& _vLocation, const FQuat& _qRotation);
    void BPF_UpdateKeyData(class UReplayKey* _key, const FReplayKeyData& _data);
    void BPF_SetMusicForExport(FName _wantedMusic);
    void BPF_SaveState();
    void BPF_RecalcDilatedTimes(int32 _iStartingIndex);
    bool BPF_IsLastKey(const class UReplayKey* _key);
    bool BPF_IsFirstKey(const class UReplayKey* _key);
    bool BPF_IsBoundaryKey(int32 _iIndex);
    bool BPF_HasUndoStateAvailable();
    bool BPF_HasRedoStateAvailable();
    bool BPF_HasKey(int32 _iKeyIndex);
    class UReplayKey* BPF_GetPreviousKeyWithCameraTransition(const class UReplayKey* _key);
    class UReplayKey* BPF_GetPreviousKeyOfType(const class UReplayKey* _key, const EReplayKeyTypeFlag _eType);
    class UReplayKey* BPF_GetPreviousKey(const class UReplayKey* _key);
    class UReplayKey* BPF_GetNextKeyWithCameraTransition(const class UReplayKey* _key);
    class UReplayKey* BPF_GetNextKeyOfType(const class UReplayKey* _key, const EReplayKeyTypeFlag _eType);
    class UReplayKey* BPF_GetNextKey(const class UReplayKey* _key);
    TArray<class UReplayKey*> BPF_GetKeys();
    class UReplayKey* BPF_GetKeyAtKeyFrameIndex(int32 _iKeyFrameIndex);
    class UReplayKey* BPF_GetKey(int32 _iIndex);
    FName BPF_GetCurrentMusicForExport();
}; // Size: 0xD8

class UReplayTimelineTransition : public UReplayTimelineContainerBase
{
    TArray<EReplayTransitionElement> m_DrawOrder;                                     // 0x0278 (size: 0x10)
    FLinearColor m_DefaultTint;                                                       // 0x0288 (size: 0x10)
    FLinearColor m_HighlightTint;                                                     // 0x0298 (size: 0x10)
    bool m_bCurrentTransitionAntiAlias;                                               // 0x02A8 (size: 0x1)
    float m_fCurrentTransitionThickness;                                              // 0x02AC (size: 0x4)
    FReplayTimelineIndicatorDisplayProperties m_TimeDilationDisplayProperties;        // 0x02B0 (size: 0x20)
    FReplayTimelineTimeDilationContext m_TimeDilationTransitionsContext;              // 0x02D0 (size: 0x10)
    FReplayTimelineCurrentTransitionContext m_CurrentTransitionContext;               // 0x02E0 (size: 0x1C)

    void OnKeyHoverOrSelectStateChanged(const class UReplayKeyWidget* _widget);
    void OnDelayedUpdateTransitionForKey(const class UReplayKeyWidget* _widget);
    bool BPE_OverrideGenerateTimeDilationIndicatorDilatedTimes(FReplayTimelineTimeDilationData& _data);
    void BPE_DrawTimeDilationTransitions();
}; // Size: 0x308

class UReplayTimelineWidget : public UUserWidget
{
    float m_fZoom;                                                                    // 0x0290 (size: 0x4)
    float m_fPreviewCursorAlphaTriggerUnzoom;                                         // 0x0294 (size: 0x4)
    float m_fAdaptZoomViewPercentage;                                                 // 0x0298 (size: 0x4)
    class UReplayTimelineContainerBase* m_BackgroundWidget;                           // 0x02A8 (size: 0x8)
    class UReplayTimelineTransition* m_TransitionWidget;                              // 0x02B0 (size: 0x8)
    class UCanvasPanel* m_KeysPanel;                                                  // 0x02B8 (size: 0x8)
    FMargin m_TimelineMargin;                                                         // 0x02C0 (size: 0x10)
    TSubclassOf<class UReplayKeyWidget> m_KeyWidgetClass;                             // 0x02D0 (size: 0x8)
    TMap<class UReplayKey*, class UReplayKeyWidget*> m_KeyWidgetsMap;                 // 0x02D8 (size: 0x50)
    TArray<class UReplayKeyWidget*> m_KeyWidgets;                                     // 0x0328 (size: 0x10)
    class AReplayController* m_ReplayController;                                      // 0x0338 (size: 0x8)

    void OnTimelineControllerTransitionContextInitialized();
    void OnKeyDataUpdated(class UReplayKey* _key, const FReplayKeyData& _previousData);
    void OnKeyDataIndexUpdate(class UReplayKey* _key, int32 _iPreviousIndex, EReplayKeyIndexUpdateReason _eReason);
    void OnGoToTimeCompleted();
    void BPF_SetZoom(float _fZoom);
    void BPF_KeyPropertyChanged(class UReplayKey* _key);
    void BPF_Initialize(class AReplayController* _controller);
    class UReplayKeyWidget* BPF_GetWidget(const class UReplayKey* _key);
    float BPF_GetTimelinePosition(float _fDilatedDemoTime);
    FFloatRange BPF_GetRemappedZoomView(const FFloatRange& _zoomRescaleRange);
    void BPF_GetKeyPositionOffsetOverrides(const class UReplayKeyWidget* _keyWidget, float& _fOutTimeOffset, float& _fTimelinePositionOffset);
    FVector2D BPF_GetKeyPosition(const class UReplayKeyWidget* _keyWidget, bool _bOffsetKeySize, bool _bAddContainerPadding, bool& _bOutIsOutOfBounds, bool _bPreventKeyTypePositionOverride);
    float BPF_GetCurrentTimelinePosition();
    float BPF_GetCurrentDilatedTime();
    class UReplayKeyWidget* BPF_AddKey(class UReplayKey* _key);
    void BPE_RequestKeysDisplayUpdate();
    void BPE_OnUpdateKeySelectedDisplay(class UReplayKey* _key);
    void BPE_OnTimelineControllerTransitionContextInitialized(const class UReplayKey* _currentCameraKey);
    void BPE_OnPaintTimelineBounds(const FFloatRange& _zoomRescaleRange, const FFloatRange& _timelineRange, FPaintContext& _context);
    void BPE_OnPaintCursorPreview(FVector2D _vStartPosition, FVector2D _vEndPosition, FPaintContext& _context);
    void BPE_OnKeyWidgetHoverOrSelectChange(const class UReplayKeyWidget* _widget);
    void BPE_OnKeySelectionUpdate(class UReplayKey* _key, bool _bSelected);
    void BPE_OnKeyPostDelete(class UReplayKey* _key);
    void BPE_OnKeyDilatedTimeRecalc(int32 _iStartingIndex);
    void BPE_OnKeyAdded(class UReplayKeyWidget* _widget);
    void BPE_OnDebugPaintCursor(FVector2D _vStartPosition, FVector2D _vEndPosition, EReplayTimelineDebugType _eDebugType, FPaintContext& _context);
}; // Size: 0x358

class UReplayUIModeDB : public UDataAsset
{
    TArray<class TSubclassOf<UReplayUIModeUserWidget>> m_UIModeUserWidgets;           // 0x0030 (size: 0x10)

}; // Size: 0x40

class UReplayUIModeUserWidget : public USCUserWidget
{
    bool m_bAddToViewport;                                                            // 0x0310 (size: 0x1)
    int32 m_iZOrder;                                                                  // 0x0314 (size: 0x4)
    bool m_bIsActive;                                                                 // 0x0318 (size: 0x1)
    bool m_bHandleInputWhenUINotVisible;                                              // 0x0319 (size: 0x1)
    bool m_bIsOverlay;                                                                // 0x031A (size: 0x1)
    FText m_DisplayName;                                                              // 0x0320 (size: 0x18)

    void BPE_OnLeaveMode();
    void BPE_OnEnterMode();
}; // Size: 0x338

class UReplayableDestructibleComponent : public UDestructibleComponent
{
    bool m_bCreatePhysicsStateAtStart;                                                // 0x0810 (size: 0x1)
    FReplayableDestructibleComponentOnReCreatedPhysicsState OnReCreatedPhysicsState;  // 0x0818 (size: 0x10)
    void DynamicMulticast();
    FReplayableDestructibleComponentOnRepDestructibleStateChange OnRepDestructibleStateChange; // 0x0828 (size: 0x10)
    void ReplayableDestructibleStateChangeDelegate(EReplayableDestructibleState _eState);
    float m_fDelayNotifyHitEvent;                                                     // 0x0838 (size: 0x4)
    bool m_bOnFirstDestructionEnableChunksCollision;                                  // 0x083C (size: 0x1)
    bool m_bReplayUpdateChunksOnTick;                                                 // 0x083D (size: 0x1)
    class UReplayableStaticObjectComponent* m_ReplayableStaticObjectComponent;        // 0x0840 (size: 0x8)
    TArray<FReplicatedDamageEvent> m_DamageEvents;                                    // 0x0848 (size: 0x10)
    bool m_bCreatePhysicsState;                                                       // 0x0868 (size: 0x1)
    FReplicatedDestructibleChunks m_ChunksState;                                      // 0x0878 (size: 0x40)
    FReplicatedBoxSphereBounds m_ReplicatedBounds;                                    // 0x08B8 (size: 0x20)
    EReplayableDestructibleState m_eReplayableDestructibleState;                      // 0x08D8 (size: 0x1)

    void OnReplayTimeDilationChanged(float _fDilation);
    void OnReplaySystemRecordingChanged(bool _bIsRecording);
    void OnRep_ReplayUpdateChunksOnTick();
    void OnRep_ReplayableDestructibleState();
    void OnRep_DamageEvents();
    void OnRep_ChunksState();
    void OnRep_Bounds();
    void EnableNotifyHitEvent();
    void BPF_SetApexActorEnabled(bool _bValue);
    bool BPF_IsDamaged();
    void BPE_OnPreFirstDamageReceived(float _fBaseDamage, bool _bFullDamage);
}; // Size: 0x8E0

class UReplayableDestructionComponent : public UActorComponent
{
    bool m_bBroken;                                                                   // 0x00C0 (size: 0x1)
    FReplayableDestructionComponentOnRepBrokenState OnRepBrokenState;                 // 0x00C8 (size: 0x10)
    void OnRepBrokenState(bool bBroken);

    void OnRep_BrokenStateUpdate();
}; // Size: 0xD8

class UReplayablePhysObjectComponent : public UReplayableStaticObjectComponent
{
    bool m_bIsReplicatingMovement;                                                    // 0x00C8 (size: 0x1)
    bool m_bDebugDisabled;                                                            // 0x00C9 (size: 0x1)
    bool m_bForceNetUpdateOnBodyAwake;                                                // 0x00CA (size: 0x1)
    class AActor* m_AttachedActor;                                                    // 0x00D0 (size: 0x8)

    void OnReplaySystemRecordingChanged(bool _bIsRecording);
    void OnRep_IsReplicatingMovement();
    void OnRep_AttachmentChanged();
    void OnComponentWake(class UPrimitiveComponent* _wakingComponent, FName _boneName);
    void OnComponentSleep(class UPrimitiveComponent* _wakingComponent, FName _boneName);
}; // Size: 0xE0

class UReplayablePhysicsComponent : public UActorComponent
{
    FCompressedPoseSnapshot m_LastPoseSnapshot;                                       // 0x00C8 (size: 0x40)
    class USkeletalMeshComponent* m_SkeletalMeshComp;                                 // 0x0108 (size: 0x8)
    bool m_bActive;                                                                   // 0x0110 (size: 0x1)

    void OnReplaySystemRecordingChanged(bool _bIsRecording);
    void OnRep_LastPoseSnapshot();
    void OnRep_Active();
}; // Size: 0x118

class UReplayableStaticObjectComponent : public UActorComponent
{
    class UPrimitiveComponent* m_RootPrimComp;                                        // 0x00C0 (size: 0x8)

}; // Size: 0xC8

class UResilienceOrderService : public UOrderService
{
    int32 m_iBonus;                                                                   // 0x0028 (size: 0x4)

}; // Size: 0x30

class UResourceItemData : public UBaseItemData
{
    int32 m_iFragmentsNb;                                                             // 0x0078 (size: 0x4)
    EGearRarity m_eRarity;                                                            // 0x007C (size: 0x1)

}; // Size: 0x80

class UResourcesTexturesData : public UDataAsset
{
    FText m_FragmentText;                                                             // 0x0030 (size: 0x18)
    TSoftObjectPtr<UTexture2D> m_FragmentTexture;                                     // 0x0048 (size: 0x28)

}; // Size: 0x70

class URichTextBlockControllerDecorator : public URichTextBlockDecorator
{
    EControllerIconStyles m_eDefaultIconStyle;                                        // 0x0028 (size: 0x1)
    EControllerIconAxisTypes m_eDefaultAxisType;                                      // 0x0029 (size: 0x1)
    FSCUserDefinedEnumHandler m_DefaultDrawingStyle;                                  // 0x0030 (size: 0x50)
    TSubclassOf<class UUserWidget> m_WidgetClass;                                     // 0x0080 (size: 0x8)
    int32 m_iBaselineOffset;                                                          // 0x0088 (size: 0x4)
    FString m_MetaData;                                                               // 0x0090 (size: 0x10)

}; // Size: 0xA0

class URichTextBlockControllerDecoratorHelper : public UBlueprintFunctionLibrary
{

    FString BPF_GetInputActionValueName(InputAction _eAction);
    FString BPF_GetControllerIconStylesValueName(EControllerIconStyles _eStyle);
    FString BPF_GetControllerIconAxisTypesValueName(EControllerIconAxisTypes _eAxis);
}; // Size: 0x28

class URunReactionBTTaskNode : public UBTTaskNode
{
    EGlobalBehaviors m_NextBehavior;                                                  // 0x0070 (size: 0x1)
    EGlobalBehaviors m_BehaviorToTest;                                                // 0x0071 (size: 0x1)
    EFightingActionState m_eActionState;                                              // 0x0072 (size: 0x1)

}; // Size: 0x78

class URushAbility : public USCGameplayAbility
{
    ESpeedState eMinNeededSpeedState;                                                 // 0x0568 (size: 0x1)
    bool m_bResetGuard;                                                               // 0x0569 (size: 0x1)

}; // Size: 0x570

class URushAttackDB : public UDataAsset
{
    float m_fRushAttackMinTime;                                                       // 0x0030 (size: 0x4)
    bool m_bFailedAttackRushFalseTracking;                                            // 0x0034 (size: 0x1)
    float m_fRushAttackTrackingAngle;                                                 // 0x0038 (size: 0x4)

}; // Size: 0x40

class USCAITriggerableActions : public UObject
{
}; // Size: 0x28

class USCAbilitySystemComponent : public UAbilitySystemComponent
{
    TArray<class TSubclassOf<UGameplayEffect>> m_StartEffects;                        // 0x1318 (size: 0x10)
    FSCAbilitySystemComponent_OnSkillConsolidated m_OnSkillConsolidated;              // 0x1328 (size: 0x10)
    void OnSkillConsolidated();
    TMap<class TSubclassOf<UGameplayAbility>, class FAbilityDelegateHandler> m_OrderDelegateHandler; // 0x1338 (size: 0x50)

    void BPF_UnlockSkill(TSubclassOf<class USkillGameplayEffect> _effect, bool _bForce);
    void BPF_UnlockPermanentSkills(const TMap<TSubclassOf<USkillGameplayEffect>, int32>& _unlockedSkillOccurences);
    void BPF_UnlockAllSkills(FString _path);
    void BPF_ResetShrineEffects();
    void BPF_RemoveLooseGameplayTag(FGameplayTag _tag);
    void BPF_RemoveAndSaveGameplayTag(const FGameplayTagContainer& _tag);
    void BPF_OnAbilityDeactived_Unbind(TSubclassOf<class UGameplayAbility> _abilityClass, FBPF_OnAbilityDeactived_UnbindDelegate _delegate);
    void BPF_OnAbilityDeactived_Bind(TSubclassOf<class UGameplayAbility> _abilityClass, FBPF_OnAbilityDeactived_BindDelegate _delegate);
    void BPF_OnAbilityActived_Unbind(TSubclassOf<class UGameplayAbility> _abilityClass, FBPF_OnAbilityActived_UnbindDelegate _delegate);
    void BPF_OnAbilityActived_Bind(TSubclassOf<class UGameplayAbility> _abilityClass, FBPF_OnAbilityActived_BindDelegate _delegate);
    void BPF_LockAllSkills(bool _bResetSave);
    bool BPF_IsSkillUnlocked(TSubclassOf<class USkillGameplayEffect> _effect);
    bool BPF_IsInStartEffects(TSubclassOf<class USkillGameplayEffect> _effect);
    bool BPF_IsAbilityActive(TSubclassOf<class UGameplayAbility> _abilityClass);
    TArray<class TSubclassOf<USkillGameplayEffect>> BPF_GetUnlockedSkills();
    bool BPF_GetNotificationsEnabled();
    void BPF_GetCooldownRemainingForTag(FGameplayTagContainer _inCooldownTags, float& _fTimeRemaining, float& _fCooldownDuration);
    void BPF_ConsolidateSkill(TSubclassOf<class USkillGameplayEffect> _effect);
    void BPF_ClearAndSaveGameplayTag();
    bool BPF_CanUnlockSkill(TSubclassOf<class USkillGameplayEffect> _effect);
    bool BPF_CanConsolidatekSkill(TSubclassOf<class USkillGameplayEffect> _effect);
    void BPF_AddShrineEffect(TSubclassOf<class UGameplayEffect> _effect);
    void BPF_AddLooseGameplayTag(FGameplayTag _tag);
    void BPF_AddAndSaveGameplayTag(const FGameplayTagContainer& _tag, bool _bNeedSaveGame);
}; // Size: 0x13A8

class USCAbilitySystemComponentHelper : public UBlueprintFunctionLibrary
{

    void BPF_AssignOnPlayerTagsChangedDelegate(const FGameplayTag& _matching, const FBPF_AssignOnPlayerTagsChangedDelegateDelegate& _delegate);
}; // Size: 0x28

class USCAbilitySystemGlobals : public UAbilitySystemGlobals
{
}; // Size: 0x260

class USCActorManager : public UObject
{

    void OnActorDestroyed(class AActor* _actorDestroyed);
}; // Size: 0x90

class USCAkAudioRTPCNotifyState : public USCAnimNotifyState
{
    class UAkRtpc* m_RTCPObject;                                                      // 0x0048 (size: 0x8)
    FName m_RTPCName;                                                                 // 0x0050 (size: 0x8)
    float m_fValueAtStart;                                                            // 0x0058 (size: 0x4)
    float m_fValueAtEnd;                                                              // 0x005C (size: 0x4)
    bool m_bCallRTPCOnSelf;                                                           // 0x0060 (size: 0x1)

}; // Size: 0x68

class USCAnimMetaData : public UAnimMetaData
{
    TArray<FSCAnimOrderServiceSettings> m_CustomOrderServiceSettings;                 // 0x0030 (size: 0x10)
    bool m_bUseWeaponAnimInfos;                                                       // 0x0040 (size: 0x1)
    FWeaponAnimInfo m_WeaponAnimInfos;                                                // 0x0048 (size: 0x90)
    TMap<class TSubclassOf<ABaseWeapon>, class FWeaponAnimInfo> m_WeaponAnimInfosPerClass; // 0x00D8 (size: 0x50)
    FName m_SlopeCurveName;                                                           // 0x0128 (size: 0x8)
    bool m_bShowSyncedAnimDebug;                                                      // 0x0130 (size: 0x1)
    bool m_bRotateTargetBoneLocationOnFloorOrientation;                               // 0x0131 (size: 0x1)
    bool m_bLockSpineXAxisRotation;                                                   // 0x0132 (size: 0x1)
    bool m_bLockSpineYAxisRotation;                                                   // 0x0133 (size: 0x1)
    float m_fFloorSpineRepartitionBlendInOut;                                         // 0x0134 (size: 0x4)
    FFloatRange m_FloorSpineRepartitionFrameRange;                                    // 0x0138 (size: 0x10)
    bool m_bOverrideSlopeBoneRepartition;                                             // 0x0148 (size: 0x1)
    TArray<FPropertyFloorBoneRepartition> m_OverrideSlopeBoneRepartition;             // 0x0150 (size: 0x10)

    void BPE_OnPlay(uint8 _uiOrderId, class ABaseCharacter* _character);
}; // Size: 0x160

class USCAnimNotify : public UAnimNotify
{
    FBaseActorConditionInstance m_triggerCondition;                                   // 0x0038 (size: 0x10)

}; // Size: 0x48

class USCAnimNotifyState : public UAnimNotifyState
{
    bool m_bRectifiedActivationConditions;                                            // 0x0030 (size: 0x1)
    bool m_bDebugLogActivationTime;                                                   // 0x0031 (size: 0x1)
    FBaseActorConditionInstance m_triggerCondition;                                   // 0x0038 (size: 0x10)

}; // Size: 0x48

class USCBlueprintNotify : public UAnimNotify
{

    void BPE_ReceivedNotifyFromActiveOrder(class USkeletalMeshComponent* _meshComp, class UAnimSequenceBase* _animation);
}; // Size: 0x38

class USCButton : public UButton
{
    FSCButtonOnFocusReceived OnFocusReceived;                                         // 0x0428 (size: 0x10)
    void ButtonFocused(class USCButton* _buttonFocused);
    FSCButtonOnFocusLost OnFocusLost;                                                 // 0x0438 (size: 0x10)
    void ButtonUnFocused(class USCButton* _buttonUnfocused);

    void BPF_SetOverrideFocusTints(FLinearColor _focusedColor, FLinearColor _noFocusColor);
}; // Size: 0x468

class USCCloseAISense_Sight : public UAISense_Sight
{
}; // Size: 0x1A0

class USCComboBoxButton : public UButtonUserWidget
{
    int32 m_iSelectedItem;                                                            // 0x0820 (size: 0x4)
    TArray<FString> m_Items;                                                          // 0x0828 (size: 0x10)
    TSubclassOf<class USCComboScrollList> m_ScrolllistClass;                          // 0x0838 (size: 0x8)

    void OnRightClick(class UButtonUserWidget* _button, bool _bWithMouse);
    void OnListClosed();
    void OnItemSelected(int32 _iIndex);
    void Onclick(class UButtonUserWidget* _button, bool _bWithMouse);
    bool BPF_IsOpened();
    void BPF_InitList(TArray<FString> _items);
    void BPE_SelectionChanged();
}; // Size: 0x848

class USCComboScrollList : public USCUserWidget
{
    FSCComboScrollListOnItemSelected OnItemSelected;                                  // 0x0310 (size: 0x10)
    void ItemSelected(int32 SelectedIndex);

    void ItemSelected__DelegateSignature(int32 SelectedIndex);
    void BPE_InitFromStrings(const TArray<FString>& _list, int32 _iSelectedItem);
}; // Size: 0x320

class USCCrowdFollowingComponent : public UCrowdFollowingComponent
{

    void OnGlobalBehaviorChanged(EGlobalBehaviors _eNewBehavior, const bool _bFromDialog);
    void BPF_SetForcedMaxSpeedStateOnAllAIs(ESpeedState _eSpeedState);
}; // Size: 0x3A8

class USCCustomDPIScaling : public UDPICustomScalingRule
{
    float m_fBaseRatio;                                                               // 0x0028 (size: 0x4)
    class UCurveFloat* m_CurveBelowRatio;                                             // 0x0030 (size: 0x8)
    class UCurveFloat* m_CurveAboveRatio;                                             // 0x0038 (size: 0x8)

}; // Size: 0x40

class USCCustomNavLink : public UNavLinkCustomComponent
{
}; // Size: 0x1C0

class USCDebugSettings : public UDeveloperSettings
{
    EGameDifficulty m_eForcedDifficulty;                                              // 0x0038 (size: 0x1)

}; // Size: 0x40

class USCDemoNetDriver : public USCBaseDemoNetDriver
{
}; // Size: 0x12C8

class USCDialogAsyncActionBase : public UBlueprintAsyncActionBase
{
    FSCDialogAsyncActionBaseOnDialogCompleted OnDialogCompleted;                      // 0x0030 (size: 0x10)
    void DialogAsyncOutputPin(int32 DialogNodeId);
    FSCDialogAsyncActionBaseOnDialogCut OnDialogCut;                                  // 0x0040 (size: 0x10)
    void DialogAsyncOutputPin(int32 DialogNodeId);
    FSCDialogAsyncActionBaseOnLineEnded OnLineEnded;                                  // 0x0050 (size: 0x10)
    void DialogAsyncOutputPin(int32 DialogNodeId);
    FSCDialogAsyncActionBaseOnInteractiveChoiceSelected OnInteractiveChoiceSelected;  // 0x0060 (size: 0x10)
    void DialogAsyncOutputPin(int32 DialogNodeId);

    class USCDialogAsyncActionBase* BPF_StartConversationExtended(class ACharacter* _character, FName _startingSegment, const bool _bGenericSubtitles, class ACharacter* _secondary, bool _bCutOtherDialogs, bool _bLookAtEnabled);
}; // Size: 0x98

class USCDialogWidget : public USCUserWidget
{
    bool m_bHandleShowSubtitleOption;                                                 // 0x0310 (size: 0x1)

    void BPF_RemoveAllDelegates();
    bool BPF_IsRuleFulfilled(const FSCConversationRule& _rule);
    void BPF_InteractiveDialogTimerExpired();
    void BPF_DialogSelected(int32 _iIndex);
    bool BPF_AreRulesFulfilled(const TArray<FSCConversationRule>& _rules);
    void BPF_AddAllDelegates();
    void BPE_ShowBlackBarsRequested();
    void BPE_OnNextSegmentHasChoices();
    void BPE_OnDialogSegmentCompleted(class USCDialogComponent* _dialogLauncher, const bool _bGenericSubtitles);
    void BPE_OnDialogCompleted(class USCDialogComponent* _dialogLauncher);
    void BPE_InteractiveSequenceStarted(const FSCConversationInteractiveChoice& _choice);
    void BPE_InteractiveDialogInterrupted();
    void BPE_DialogLaunched(class USCDialogComponent* _dialogLauncher, const FSCDialogData& _dialogData, const bool _bGenericSubtitles);
    void BPE_DialogCanceled(class USCDialogComponent* _dialogLauncher, const bool _bGenericSubtitles);
}; // Size: 0x320

class USCGameSettings : public USCBaseGameSettings
{
    TSoftObjectPtr<UMirrorAnimDB> m_DefaulMirrorAnimDB;                               // 0x00F8 (size: 0x28)
    bool m_bFilterByOrderServiceOnTeleport;                                           // 0x0120 (size: 0x1)
    TArray<TSoftClassPtr<UOrderService>> m_FilteringOrderServicesOnTeleport;          // 0x0128 (size: 0x10)
    FSoftObjectPath m_DefaultAttackTable;                                             // 0x0138 (size: 0x18)
    FSCWuguanUserEnumSetting m_UserEnums;                                             // 0x0150 (size: 0x580)
    FDataTableRowHandle m_DefaultHitbox;                                              // 0x06D0 (size: 0x10)
    FSoftObjectPath m_PoseAssetForFacial;                                             // 0x06E0 (size: 0x18)
    float m_DefaultPoseAssetNotifyStateEaseIn;                                        // 0x06F8 (size: 0x4)
    float m_DefaultPoseAssetNotifyStateEaseOut;                                       // 0x06FC (size: 0x4)
    float m_fPredictionTime;                                                          // 0x0700 (size: 0x4)
    int32 m_iHitBoxSamplingInFPS;                                                     // 0x0704 (size: 0x4)
    uint8 m_uiPredictionStep;                                                         // 0x0708 (size: 0x1)
    bool m_bAllowPredictionOnMovement;                                                // 0x0709 (size: 0x1)
    bool m_bDetachAvoidCapsuleWhenNoAvoidWindow;                                      // 0x070A (size: 0x1)
    TSoftClassPtr<UArenaSettings> m_ArenaSettings;                                    // 0x0710 (size: 0x28)

}; // Size: 0x8E8

class USCGameViewportClient : public UGameViewportClient
{
}; // Size: 0x420

class USCGameplayAbility : public UGameplayAbility
{
    FGameplayTagQuery m_AdvancedSelfTagCondition;                                     // 0x03B0 (size: 0x48)
    FGameplayTagQuery m_AdvancedTargetTagCondition;                                   // 0x03F8 (size: 0x48)
    bool m_bCommitAbilityOnOrderStart;                                                // 0x0440 (size: 0x1)
    TArray<FInputDetection> m_Inputs;                                                 // 0x0448 (size: 0x10)
    TSubclassOf<class UAbilityPayload> m_Payload;                                     // 0x0458 (size: 0x8)
    bool m_bIgnoreAvailabilityLayers;                                                 // 0x0460 (size: 0x1)
    bool m_bToggleAbility;                                                            // 0x0461 (size: 0x1)
    bool m_bHoldToToggle;                                                             // 0x0462 (size: 0x1)
    bool m_bConsumeAndResetInputs;                                                    // 0x0463 (size: 0x1)
    class UAvailabilityLayerData* m_AvailabilityLayersWhileActive;                    // 0x0468 (size: 0x8)
    EALBinaryOperation m_eALOperation;                                                // 0x0470 (size: 0x1)
    bool m_bTargetBecomesLockMoveTarget;                                              // 0x0471 (size: 0x1)
    TSubclassOf<class UGameplayEffect> m_CooldownGameplayEffectClassOnAbilityEnd;     // 0x0478 (size: 0x8)
    class UAbilityPayload* m_PayloadInstance;                                         // 0x0498 (size: 0x8)
    FGameplayTagContainer m_CombinedCooldownTags;                                     // 0x0538 (size: 0x20)

    class UBaseTargetEvaluation* BPF_GetTargetEvaluationFromTargetResult(const class AFightingCharacter* _character, const FTargetResult& _targetInfos);
    class AActor* BPF_GetTarget(const FSCGameplayAbilityActorInfo& _ActorInfo, const FGameplayEventData& _triggerEventData);
    InputAction BPF_GetFirstBestAction(const FSCGameplayAbilityActorInfo& _ActorInfo);
    FVector2D BPF_GetActionVectorValue(const FSCGameplayAbilityActorInfo& _actoInfos);
    void BPE_PreUpdatePayloadFromTargetting(class UAbilityPayload* _payload, class AActor* _self);
    void BPE_PostUpdatePayloadFromTargetting(class UAbilityPayload* _payload, class AActor* _self, InputAction _eInput, const FTargetResult& _target);
    void BPE_OnActivateAbility(const FSCGameplayAbilityActivationInfo& _activationInfos);
    void BPE_InitPayload(class UAbilityPayload* _ePayload);
    class AActor* BPE_GetTarget(const FSCGameplayAbilityActorInfo& _ActorInfo);
    uint8 BasePlayOrder(class USCGameplayAbility* _self, const FSCGameplayAbilityActivationInfo& _activationInfo, bool _bOnTarget, class AActor* _customTarget, EOrderType _eOrderType, FName _BPOrderID, FPlayOrderInfos _playOrderInfos, bool _bBindToAbility, class UScriptStruct* _baseNetOrderType, const FNetOrderStruct& _netOrderStruct);
}; // Size: 0x568

class USCGameplayAbilityActorInfoHelper : public UBlueprintFunctionLibrary
{

    class USCAbilitySystemComponent* BPF_GetSCAbilitySystem(const FSCGameplayAbilityActorInfo& _info);
    class AFightingPlayerController* BPF_GetFightingPlayerController(const FSCGameplayAbilityActorInfo& _info);
    class AFightingCharacter* BPF_GetFightingCharacter(const FSCGameplayAbilityActorInfo& _info);
}; // Size: 0x28

class USCGameplayAbilityLibrary : public UBlueprintFunctionLibrary
{

    void BPF_SetFloatAttribute(const class AActor* _actor, FGameplayAttribute _attribute, float _fDefaultValue);
    float BPF_GetFloatAttribute(const class AActor* _actor, FGameplayAttribute _attribute, float _fDefaultValue);
}; // Size: 0x28

class USCInputSettings : public UDeveloperSettings
{
    InputAction m_eInputAction;                                                       // 0x0038 (size: 0x1)
    InputAction m_eAltInputAction;                                                    // 0x0039 (size: 0x1)
    bool m_bVirtualCursorAcceleration;                                                // 0x003A (size: 0x1)
    float m_fVirtualCursorAcceleration;                                               // 0x003C (size: 0x4)
    float m_fVirtualCursorMaxSpeed;                                                   // 0x0040 (size: 0x4)
    float m_fVirtualCursorStickySlowdown;                                             // 0x0044 (size: 0x4)
    float m_fVirtualCursorDeadZone;                                                   // 0x0048 (size: 0x4)
    bool m_bSnapEnabled;                                                              // 0x004C (size: 0x1)
    float m_fSnapSpeed;                                                               // 0x0050 (size: 0x4)
    TSoftObjectPtr<UMenuDB> m_MenuDB;                                                 // 0x0058 (size: 0x28)
    bool m_bActivateRemapping;                                                        // 0x0080 (size: 0x1)
    TArray<FInputPriorityGroup> m_InputPriority;                                      // 0x0088 (size: 0x10)
    TArray<FAlwaysCollidingActions> m_AlwaysCollidingActions;                         // 0x0098 (size: 0x10)
    TArray<InputAction> m_ActionPriority;                                             // 0x00A8 (size: 0x10)
    TMap<class FInputPresetsEnumHandler, class FInputMappingData> m_Mapping;          // 0x00B8 (size: 0x50)
    TMap<class FInputMappingProfileEnumHandler, class FMappingProfileList> m_MappingProfileList; // 0x0108 (size: 0x50)
    TSet<InputAction> m_UnremappableActions;                                          // 0x0158 (size: 0x50)
    TArray<FRemappingIncompatibilityGroup> m_IncompatibilityGroups;                   // 0x01A8 (size: 0x10)
    TMap<class TSoftObjectPtr<UGenericInputData>, class FInputMappingCompatibilityRule> m_InputCustomCompatibilityRules; // 0x01B8 (size: 0x50)
    TArray<FActionMappingCompatibilityRule> m_ActionCompatibilityRules;               // 0x0208 (size: 0x10)
    TSoftObjectPtr<UGenericInputData> m_EmptyInputData;                               // 0x0218 (size: 0x28)
    FRemappingClasses m_BaseRemapClasses;                                             // 0x0240 (size: 0x10)
    TMap<class InputAction, class FRemappingClasses> m_CustomActionRemapping;         // 0x0250 (size: 0x50)
    TMap<class FInputPresetsEnumHandler, class FRemappingClasses> m_CustomPresetRemapping; // 0x02A0 (size: 0x50)
    class UMenuDB* m_CachedMenuDB;                                                    // 0x02F0 (size: 0x8)
    TArray<class UInputMappingProfileDB*> m_CachedProfiles;                           // 0x02F8 (size: 0x10)
    TArray<class UGenericInputData*> m_CachedInputDatas;                              // 0x0308 (size: 0x10)

}; // Size: 0x368

class USCLocalPlayer : public ULocalPlayer
{
}; // Size: 0x2B0

class USCNavModifierComponent : public UNavModifierComponent
{

    void BPF_CalcAndCacheBounds();
}; // Size: 0x150

class USCReplaySettings : public UDeveloperSettings
{
    TSoftClassPtr<ABaseReplayController> m_PhotoModeGameplayControllerClass;          // 0x0038 (size: 0x28)
    FString m_ScreenShotFileName;                                                     // 0x0060 (size: 0x10)
    FString m_ScreenShotDateFormat;                                                   // 0x0070 (size: 0x10)
    TArray<FString> m_StatesToSaveWhenStartRecording;                                 // 0x0080 (size: 0x10)
    TArray<FString> m_RTPCToSaveWhenStartRecording;                                   // 0x0090 (size: 0x10)
    FString m_EventToResetRTPCWhenStartRecording;                                     // 0x00A0 (size: 0x10)
    TSoftClassPtr<UReplaySaveGame> m_ReplaySaveGameClass;                             // 0x00B0 (size: 0x28)
    FReplayKeyDataCameraSettings m_DefaultCameraSettings;                             // 0x00D8 (size: 0x28)
    FCollisionResponseContainer m_CharacterNoCollisionContainer;                      // 0x0100 (size: 0x20)
    TArray<TEnumAsByte<ECollisionChannel>> m_MeshCollisionsChannels;                  // 0x0120 (size: 0x10)
    FGameplayTag m_ReplayEditorAllowedContentTag;                                     // 0x0130 (size: 0x8)
    bool m_bReplayEditorBuildEnabled;                                                 // 0x0138 (size: 0x1)
    bool m_bPhotomodeBuildEnabled;                                                    // 0x0139 (size: 0x1)
    bool m_bIsReplayEditorAllowedForPlatform;                                         // 0x013A (size: 0x1)
    TMap<class FString, class FText> m_LocalizedMapName;                              // 0x0140 (size: 0x50)
    int32 m_iReplaySkipTimeNoLoadingScreenMaxFrames;                                  // 0x0190 (size: 0x4)
    FFloatRange m_ReplayRecordingTimeRange;                                           // 0x0194 (size: 0x10)
    float m_fDistanceForObjectTransparency;                                           // 0x01A4 (size: 0x4)

    bool BPF_LocalizeMapName(FString& _inOutMapName);
    bool BPF_IsReplayEditorEnabled(const class UObject* _worldContextObject);
    bool BPF_IsPhotomodeEnabled();
    FFloatRange BPF_GetReplayRecordingTimeRangeMS();
    FReplayKeyDataCameraSettings BPF_GetDefaultCameraSettings();
}; // Size: 0x1A8

class USCSessionManager : public UObject
{
    class USCTrackingAuthentication* m_TrackingAuthenticationComponent;               // 0x0080 (size: 0x8)

}; // Size: 0x90

class USCSignificanceManager : public USignificanceManager
{
}; // Size: 0x120

class USCSignificanceSettings : public UObject
{
    float m_fRecentlyRenderedLimit;                                                   // 0x0028 (size: 0x4)
    float m_fHighBucketDist;                                                          // 0x002C (size: 0x4)
    float m_fMediumBucketDist;                                                        // 0x0030 (size: 0x4)

}; // Size: 0x38

class USCTools : public USCCoreTools
{

    EQuadrantTypes GetAttackQuadrant(EQuadrantTypes _eQuadrant, bool _bIsMirror);
    void BPF_ModifyObject(class UObject* _object);
    bool BPF_IsDesktopPlatform();
    bool BPF_HasEntitlement(const class UObject* _worldContextObject, const FName& _entitlement);
    FString BPF_GetMapPath(TSoftObjectPtr<UWorld> _map);
    FGameplayTag BPF_GetGameplayTagFromName(const FName& _tagName);
    class UGameInstance* BPF_GetGameInstanceNoWarning(const class UObject* _worldContextObject);
    class UObject* BPF_GetDefaultObject(UClass* _ObjectClass);
    EPlatform BPF_GetCurrentSubsystemPlatform(const class UObject* _worldContextObject);
    void BPF_FadeWithoutWait(class UObject* WorldContextObject, const float _fDuration, const bool _bToBlack);
    void BPF_Fade(class UObject* WorldContextObject, const float _fDuration, const bool _bToBlack, FLatentActionInfo LatentInfo);
}; // Size: 0x28

class USCTrackingAuthentication : public UObject
{
}; // Size: 0x40

class USCTrackingAuthenticationEOS : public USCTrackingAuthentication
{
}; // Size: 0x40

class USCTrackingAuthenticationNSA : public USCTrackingAuthentication
{
}; // Size: 0x40

class USCTrackingAuthenticationPSN : public USCTrackingAuthentication
{
}; // Size: 0x48

class USCTrackingAuthenticationSTEAM : public USCTrackingAuthentication
{
}; // Size: 0x50

class USCTriggerableActionsComboEvent : public UComboEvent
{
    TArray<class USCAITriggerableActions*> m_ActionsToTrigger;                        // 0x0028 (size: 0x10)

}; // Size: 0x38

class USCUserWidget : public USCBaseUserWidget
{
    FSCUserWidget_OnVisible m_OnVisible;                                              // 0x0278 (size: 0x10)
    void VisibilityChanged();
    FSCUserWidget_OnHidden m_OnHidden;                                                // 0x0288 (size: 0x10)
    void VisibilityChanged();
    ESlateVisibility m_ActiveVisibility;                                              // 0x0298 (size: 0x1)
    FSCUserWidget_GetDataDelegate m_GetDataDelegate;                                  // 0x029C (size: 0x10)
    class UWidgetData* GetDataDelegate();
    FSCUserWidget_InitializeDelegate m_InitializeDelegate;                            // 0x02AC (size: 0x10)
    void InitializeWidgetDelegate(class USCUserWidget* _widget);
    class UWidgetData* m_Data;                                                        // 0x02C0 (size: 0x8)
    TSubclassOf<class UWidgetData> m_DataClass;                                       // 0x02C8 (size: 0x8)
    ESlateVisibility m_eControllerInputModeVisibility;                                // 0x02D0 (size: 0x1)
    ESlateVisibility m_eMouseInputModeVisibility;                                     // 0x02D1 (size: 0x1)
    bool m_bGiveFocusIfNeededWithKeyboard;                                            // 0x02D2 (size: 0x1)
    ESlateVisibility m_eFocusedVisibility;                                            // 0x02DC (size: 0x1)
    bool m_bOnGiveFocusButtonOnly;                                                    // 0x02DD (size: 0x1)
    bool m_bNotifyPawnChanged;                                                        // 0x02DE (size: 0x1)
    bool m_bNotifyUIInputModeChanged;                                                 // 0x02DF (size: 0x1)
    bool m_bForceGamepadUI;                                                           // 0x02E3 (size: 0x1)
    bool m_bUpdateDataOnCharacterProgression;                                         // 0x0308 (size: 0x1)
    bool m_bUpdateDataOnVisible;                                                      // 0x0309 (size: 0x1)

    void VisibilityChanged__DelegateSignature();
    void OnDataUpdated();
    void InitializeWidgetDelegate__DelegateSignature(class USCUserWidget* _widget);
    class UWidgetData* GetDataDelegate__DelegateSignature();
    void BPF_SetData(class UWidgetData* _data);
    void BPF_PlayAnimationFromCurrentTime(class UWidgetAnimation* _inAnimation, int32 _iNumLoopsToPlay, TEnumAsByte<EUMGSequencePlayMode::Type> _ePlayMode);
    void BPF_NotifyDataUpdatedToChildren(class UPanelWidget* _root);
    void BPF_NotifyDataUpdated();
    bool BPF_IsVisibleInTree();
    bool BPF_IsPlayerLeaderInPvpAndHasAllies();
    bool BPF_IsCursorNavigationEnabled();
    void BPF_GiveFocusIfNeeded();
    EUIInputModes BPF_GetUIInputMode();
    class UThePlainesGameInstance* BPF_GetThePlainesGameInstance();
    class UStatsComponent* BPF_GetStatsComponent();
    class USocialManager* BPF_GetSocialManager();
    class USocialComponent* BPF_GetSocialComponent();
    class ASCPlayerController* BPF_GetPlayerController();
    EPlatform BPF_GetPlatform();
    class UMenuWidget* BPF_GetParentMenu();
    class UMenuDB* BPF_GetMenuDB();
    class UCharacterHealthComponent* BPF_GetHealthComponent();
    class AFightingPlayerController* BPF_GetFightingPlayerController();
    class AFightingCharacter* BPF_GetFightingCharacter();
    class UDefenseComponent* BPF_GetDefenseComponent();
    class UWidgetData* BPF_GetData();
    class UWorld* BPF_GetCurrentWorld();
    class UAttackComponent* BPF_GetAttackComponent();
    class USCAbilitySystemComponent* BPF_GetAbilitySystemComponent();
    bool BPF_CheckControllerHasAnyFocus();
    void BPE_UnbindFromDelegates();
    void BPE_OnVisible();
    void BPE_OnUIInputModeChanged(EUIInputModes _eMode, bool _bInit);
    void BPE_OnReturnToPool();
    void BPE_OnPawnChanged(class AFightingCharacter* _character);
    void BPE_OnHidden();
    void BPE_OnGetFromPool();
    void BPE_OnDataUpdated();
    void BPE_OnCultureChanged();
    void BPE_GiveFocus();
    class UWidgetData* BPE_CreateData();
    void BPE_BindToDelegates(bool _bPawnOnly);
}; // Size: 0x310

class USafeZoneEvaluationRange : public USCAnimNotifyState
{
}; // Size: 0x48

class USafeZoneOrderService : public UOrderService
{
    int32 m_iMaxIterations;                                                           // 0x0028 (size: 0x4)
    bool m_bUseTargetSnapToBlend;                                                     // 0x002C (size: 0x1)
    float m_fBlendDuration;                                                           // 0x0030 (size: 0x4)
    FFloatRange m_ClampZone;                                                          // 0x0034 (size: 0x10)
    FFloatRange m_ZoneAnimFrameRange;                                                 // 0x0044 (size: 0x10)
    float m_fMaxSpeed;                                                                // 0x0054 (size: 0x4)
    FVector m_vNavMeshExtraZone;                                                      // 0x0058 (size: 0xC)
    FVector m_vAdditionnalSpaceToTakeFromAnim;                                        // 0x0064 (size: 0xC)
    FName m_TargetBone;                                                               // 0x0070 (size: 0x8)

}; // Size: 0x78

class UScreenTextureDB : public UDataAsset
{
    TArray<FScreenTextureData> m_ScreenTextures;                                      // 0x0030 (size: 0x10)

}; // Size: 0x40

class USelfCondition : public UBaseActorTargetCondition
{
    FBaseActorConditionInstance m_condition;                                          // 0x0028 (size: 0x10)

}; // Size: 0x38

class USessionTimeManager : public UObject
{
    float m_fDelayBetweenSync;                                                        // 0x0058 (size: 0x4)
    float m_fTimeSinceLastSync;                                                       // 0x005C (size: 0x4)
    float m_fScaleTime;                                                               // 0x0060 (size: 0x4)

}; // Size: 0x80

class USetCameraBlackboardBoolNotify : public UAnimNotify
{
    FName m_blackboardKeyName;                                                        // 0x0038 (size: 0x8)
    bool m_bValueToApply;                                                             // 0x0040 (size: 0x1)

}; // Size: 0x48

class USetGameplayTagDialogAction : public UDialogActionBase
{
    bool m_bAdd;                                                                      // 0x0030 (size: 0x1)
    FName m_Owner;                                                                    // 0x0034 (size: 0x8)
    FGameplayTag m_GameplayTag;                                                       // 0x003C (size: 0x8)

}; // Size: 0x48

class USkeletalMeshHitDetectionDB : public UBaseHitDetectionDB
{
    TArray<FBoneHitDBInfo> m_bonesToWatch;                                            // 0x0060 (size: 0x10)

}; // Size: 0x70

class USkillButton : public UButtonUserWidget
{
    bool m_bUdateParallax;                                                            // 0x0820 (size: 0x1)
    FName m_SocketName;                                                               // 0x0824 (size: 0x8)
    TArray<class USkillButton*> m_ChildButtons;                                       // 0x0830 (size: 0x10)
    TSubclassOf<class USkillGameplayEffect> m_GameplayEffect;                         // 0x0840 (size: 0x8)
    class USkillsDB* m_DB;                                                            // 0x0848 (size: 0x8)

    void BPF_UpdateButtonLocation(class ASkillTree* SkillTree);
    void BPF_SetSkillTreeNode(const FSkillTreeNode& _node);
    void BPF_GetSkillTreeNode(FSkillTreeNode& _node);
}; // Size: 0x868

class USkillButtonHelper : public UBlueprintFunctionLibrary
{

    void BPF_RebuildDBFromButtons(class USkillsDB* _db, class USkillButton* _root);
}; // Size: 0x28

class USkillGameplayEffect : public USCGameplayEffect
{
    int32 m_iSkillPointCost;                                                          // 0x07F8 (size: 0x4)
    TArray<int32> m_ConsolidationSkillPointCosts;                                     // 0x0800 (size: 0x10)
    ECharacterStat m_eStatUsedToUnlockSkill;                                          // 0x0810 (size: 0x1)

}; // Size: 0x818

class USkillsChilds : public UObject
{
    TArray<FSkillTreeNode> m_Skills;                                                  // 0x0028 (size: 0x10)

    void EnumerateChildsDelegate__DelegateSignature();
    bool BPF_GetParent(const FSkillTreeNode& _node, FSkillTreeNode& _parent);
    bool BPF_FindSkillBySocket(FName _socketName, FSkillTreeNode& _node);
    void BPF_FindChilds(class USCAbilitySystemComponent* _component, const FSkillFilter& _filter, TArray<FSkillTreeNode>& _result, const class USkillsChilds* _rootToEnumerateVirtualChilds, bool _bStopOnFilterFailed);
    void BPF_FindChild(class USCAbilitySystemComponent* _component, const FSkillFilter& _filter, FSkillTreeNode& _result, const class USkillsChilds* _rootToEnumerateVirtualChilds);
    void BPF_EnumerateChilds(class USCAbilitySystemComponent* _component, const FSkillFilter& _filter, FBPF_EnumerateChildsEnumerator _enumerator, const class USkillsChilds* _rootToEnumerateVirtualChilds, bool _bStopOnFilterFailed);
    int32 BPF_CountChilds(class USCAbilitySystemComponent* _component, const FSkillFilter& _filter, bool _bStopOnFilterFailed);
}; // Size: 0x38

class USkillsDB : public UDataAsset
{
    class USkillsChilds* m_Root;                                                      // 0x0038 (size: 0x8)

}; // Size: 0x40

class USkinTonesDB : public UDataAsset
{
    TArray<FSkinToneGender> m_SkinTones;                                              // 0x0030 (size: 0x10)
    class UMaterialInterface* m_BaseFXMaterials;                                      // 0x0040 (size: 0x50)

}; // Size: 0x90

class USlapstickFightCheatData : public UCheatData
{

    void BPE_OnAIHit(class AFightingCharacter* _fightingCharHitted, const FHitDescription& _hitDescription);
}; // Size: 0x40

class USnapObjectNotify : public USCAnimNotify
{
}; // Size: 0x48

class USnapOrderService : public UOrderService
{
    bool m_bNeedTargetActor;                                                          // 0x0028 (size: 0x1)
    bool m_bTickBeforeTargetActor;                                                    // 0x0029 (size: 0x1)
    bool m_bMimicTargetFloorDist;                                                     // 0x002A (size: 0x1)
    FName m_SelfBoneName;                                                             // 0x002C (size: 0x8)
    FName m_TranslationCurve;                                                         // 0x0034 (size: 0x8)
    FName m_RotationCurve;                                                            // 0x003C (size: 0x8)
    bool m_bUseSelfBoneRatio;                                                         // 0x0044 (size: 0x1)
    float m_fSelfBoneRatio;                                                           // 0x0048 (size: 0x4)
    float m_fTargetRotationOffset;                                                    // 0x004C (size: 0x4)
    bool m_bSnapSelfBoneToGround;                                                     // 0x0050 (size: 0x1)
    FName m_TargetBoneName;                                                           // 0x0054 (size: 0x8)
    class UCurveFloat* m_Dynamic;                                                     // 0x0060 (size: 0x8)
    bool m_bUseTransitionFrames;                                                      // 0x0068 (size: 0x1)
    float m_fTransitionFrames;                                                        // 0x006C (size: 0x4)
    TSubclassOf<class UOrderService> m_TransitionUntilOrderService;                   // 0x0070 (size: 0x8)
    bool m_bStopWhenTransitionOrderServiceStarted;                                    // 0x0078 (size: 0x1)
    TSubclassOf<class UOrderService> m_StartSnappingAfterTargetService;               // 0x0080 (size: 0x8)
    bool m_bDisableCollisions;                                                        // 0x0088 (size: 0x1)
    bool m_bDisableCollisionsWithStaticMesh;                                          // 0x0089 (size: 0x1)
    bool m_bPredictTargetRedirection;                                                 // 0x008A (size: 0x1)
    bool m_bPredictTargetSnap;                                                        // 0x008B (size: 0x1)
    bool m_bSnapTranslationFollowDynamicCurve;                                        // 0x008C (size: 0x1)
    class UCurveFloat* m_SnapTranslationDynamic;                                      // 0x0090 (size: 0x8)
    bool m_bForceLinearSnap;                                                          // 0x0098 (size: 0x1)
    float m_fMaxSnapSpeed;                                                            // 0x009C (size: 0x4)
    float m_fMaxCumulatedDistance;                                                    // 0x00A0 (size: 0x4)
    float m_fMaxCumulatedAngularDistance;                                             // 0x00A4 (size: 0x4)
    float m_fMaxAngularSpeed;                                                         // 0x00A8 (size: 0x4)
    float m_fMaxDistanceToNavmesh;                                                    // 0x00AC (size: 0x4)
    FVector m_vWorldOffsetOnTargetPos;                                                // 0x00B0 (size: 0xC)

    void BPF_SetCustomSnapOrderServiceTransform(const FTransform& _transform, TSubclassOf<class USnapOrderService> _serviceClass, const class AFightingCharacter* _character, uint8 _uiOrderId);
    void BPF_BindTargetTransformDelegate(const FBPOrderServiceInstance& _self, const FBPOrderServiceInstance& _targetServiceInstance, const FBPF_BindTargetTransformDelegateDelegate& _delegate);
    FTransform BPE_GetTargetTransform(const FBPOrderServiceInstance& _instance, float _fDt, bool& _bOutTargetReady);
}; // Size: 0xC0

class USnapOrderServiceNotifyState : public UOrderServiceNotifyState
{
}; // Size: 0x68

class USocialComponent : public UActorComponent
{
    FSocialComponentOnEquippedEmoteChanged OnEquippedEmoteChanged;                    // 0x0260 (size: 0x10)
    void OnEquippedEmoteChanged(const FName& _emoteName, const uint8 _uiEmoteSlotIndex);
    class UDataTable* m_EmoteDataTable;                                               // 0x0278 (size: 0x8)
    float m_fReceivedRequestTimeout;                                                  // 0x0280 (size: 0x4)
    float m_fRequestBroadcastRange;                                                   // 0x0284 (size: 0x4)
    FNameArray m_FixedEmoteWheelContent;                                              // 0x0288 (size: 0x10)
    FNameArray m_DefaultCustomEmotesContent;                                          // 0x0298 (size: 0x10)
    FNameArray m_FixedRequestReponseContent;                                          // 0x02A8 (size: 0x50)
    uint8 m_uiHitCountThresholdForWarning;                                            // 0x02F8 (size: 0x1)
    float m_fHealthPercentThresholdForWarning;                                        // 0x02FC (size: 0x4)
    uint8 m_uiHitCountThresholdForFight;                                              // 0x0300 (size: 0x1)
    float m_fHealthPercentThresholdForFight;                                          // 0x0304 (size: 0x4)
    float m_fFightDetectionTimeOut;                                                   // 0x0308 (size: 0x4)
    float m_fFightTimeOut;                                                            // 0x030C (size: 0x4)
    float m_fFightRange;                                                              // 0x0310 (size: 0x4)
    float m_fCoopResolutionTimeOut;                                                   // 0x0314 (size: 0x4)
    TMap<class TWeakObjectPtr<AActor>, class ERelationshipTypes> m_Relationships;     // 0x0318 (size: 0x50)
    TArray<TWeakObjectPtr<AActor>> m_CoopGroup;                                       // 0x0368 (size: 0x10)
    TArray<FInFightPlayersInfo> m_InFightPlayers;                                     // 0x0378 (size: 0x10)

    void ServerStopCoop();
    void ServerReadyForCoopMatchMaking(EGameModeTypes _eGameModeType);
    void ServerPrepareForCoopMatchMaking(EGameModeTypes _eGameModeType);
    void ServerPerformEmoteActionWithGameMode(EEmoteAction _eEmoteAction, class AActor* _targetActor, EGameModeTypes _eGameModeType);
    void ServerPerformEmoteAction(EEmoteAction _eEmoteAction, class AActor* _targetActor);
    void ServerPerformBroadcastEmoteActionWithGameMode(EEmoteAction _eEmoteAction, const TArray<class AActor*>& _targetActors, EGameModeTypes _eGameModeType);
    void ServerPerformBroadcastEmoteAction(EEmoteAction _eEmoteAction, const TArray<class AActor*>& _targetActors);
    void ServerCoopPvPValidateAnswer(bool _bAccept, EGameModeTypes _eGameModeType);
    void ServerCancelRequest(ESocialRequest _eRequest);
    void ServerCancelCoopGameMode(EGameModeTypes _eGameModeType);
    void ServerApplyCoop(class AActor* _actor);
    void OnRep_CoopGroup();
    void OnEquippedEmoteChanged__DelegateSignature(const FName& _emoteName, const uint8 _uiEmoteSlotIndex);
    void OnCoopGroupRemoved(const FCoopGroup& _group);
    void OnCoopGroupMemberRemoved(const FUniqueNetIdRepl& _netId, class AActor* _actor);
    void OnActorRelationshipEndPlayCallBack(class AActor* _actor, TEnumAsByte<EEndPlayReason::Type> _eEndPlayReason);
    void MulticastStopCoop();
    void MulticastRemoveGroupMember(FUniqueNetIdRepl _groupMemberUniqueId, EGameModeTypes _eGameModeType);
    void MulticastPrepareForCoopMatchMaking(EGameModeTypes _eGameModeType);
    void MulticastCoopPvPUpdateAnswer(ECoopGameModeAnswerStatus _eAnswer, EGameModeTypes _eGameModeType);
    void MulticastCoopBondResolution(class AActor* _coopGroupMember, const TArray<TWeakObjectPtr<AActor>>& _coopGroup);
    void MulticastChangeRelationship(class AActor* _actor, ERelationshipTypes _eRelation);
    void MulticastCancelRequest(ESocialRequest _eRequestType);
    void MulticastCancelCoopGameMode(EGameModeTypes _eGameModeType);
    void CoopDangerStateChanged(EDangerStates _ePreviousDangerState, EDangerStates _eNewDangerState);
    void ClientSendRequestWithGameMode(class AActor* _requestInstigator, ESocialRequest _eSocialRequest, EGameModeTypes _eGameModeType);
    void ClientSendRequest(class AActor* _requestInstigator, ESocialRequest _eSocialRequest);
    void ClientReadyForCoopMatchMaking(EGameModeTypes _eGameModeType);
    void ClientApplyCoop(class AActor* _actor);
    void ClientAnswerRequest(class AActor* _requestAnswerer, bool _bAccept);
    void BPF_SetEmoteLock(bool _bLock, const FName& _name);
    void BPF_SetEmoteAsSeen(const FName& _name);
    void BPF_SetEmoteAsNew(const FName& _name);
    void BPF_ServerChangeRelationship(class AActor* _actor, ERelationshipTypes _eRelation);
    void BPF_LeaveCoopGroup();
    bool BPF_IsInCoopGroup();
    bool BPF_IsInCoopGameMode();
    bool BPF_IsEmoteUnlocked(const FName& _name);
    bool BPF_IsEmoteNew(const FName& _name);
    bool BPF_IsEmoteEquipped(const FName& _emoteName);
    bool BPF_HasCoopGroupReturningToPvE();
    ERelationshipTypes BPF_GetRelationship(class AActor* _actor);
    int32 BPF_GetNewEmotesCount();
    int32 BPF_GetCoopPlayerCount();
    int32 BPF_CountPlayerWithAnswer(ECoopGameModeAnswerStatus _eAnswer, EGameModeTypes _eGameMode);
    void BPF_CancelPendingCoopMatchMaking();
    void BPF_CancelPendingCoopGameModes(bool _bQuitTheGroup);
}; // Size: 0x4D8

class USocialManager : public UObject
{
    float m_fCoopResolutionTimeOut;                                                   // 0x00F0 (size: 0x4)
    float m_fCoopResolutionReturningPvETimeOut;                                       // 0x00F4 (size: 0x4)
    int32 m_NbNeededPlayersPerGameMode;                                               // 0x00F8 (size: 0xC)
    int32 m_NbMaxPlayersPerGameMode;                                                  // 0x0104 (size: 0xC)

}; // Size: 0x120

class USortMethodDB : public UDataAsset
{
    FSortMethodData m_SortMethodData;                                                 // 0x0030 (size: 0xF0)

    void BPF_GetSortMethodData(EInventorySearchOrder _sortMethod, FSortMethodData& _outSortMethodData);
}; // Size: 0x120

class USoundGroundAnimNotify : public UAnimNotify
{

    void BPE_NotifyGround(class USkeletalMeshComponent* _meshComp, uint8 _surface);
}; // Size: 0x38

class USoundSettings : public UDeveloperSettings
{
    bool m_bEnableSoundMoods;                                                         // 0x0038 (size: 0x1)
    FName m_MasterVolume;                                                             // 0x003C (size: 0x8)
    FName m_MusicVolume;                                                              // 0x0044 (size: 0x8)
    FName m_SFXVolume;                                                                // 0x004C (size: 0x8)
    FName m_GameplaySFXState;                                                         // 0x0054 (size: 0x8)
    FName m_GameplaySFXStateOn;                                                       // 0x005C (size: 0x8)
    FName m_GameplaySFXStateOff;                                                      // 0x0064 (size: 0x8)
    FName m_DialogVolume;                                                             // 0x006C (size: 0x8)
    FName m_AdvancedVibrationStrengthRTPC;                                            // 0x0074 (size: 0x8)
    FName m_AdvancedVibrationState;                                                   // 0x007C (size: 0x8)
    FName m_AdvancedVibrationStateON;                                                 // 0x0084 (size: 0x8)
    FName m_AdvancedVibrationStateOFF;                                                // 0x008C (size: 0x8)
    AkChannelConfiguration m_eDefaultChannelConfig;                                   // 0x0094 (size: 0x1)
    FAudioOutput m_AudioOutputList;                                                   // 0x0098 (size: 0x80)
    FName m_Audio3DRTPC;                                                              // 0x0118 (size: 0x8)
    TArray<FString> m_HandlingMonoBusList;                                            // 0x0120 (size: 0x10)
    FName m_VoiceArchetypeSwitchGroup;                                                // 0x0130 (size: 0x8)
    FName m_VoiceVariationSwitchGroup;                                                // 0x0138 (size: 0x8)
    FName m_VoiceGenderSwitchGroup;                                                   // 0x0140 (size: 0x8)
    FName m_VoiceGenderSwitchValues;                                                  // 0x0148 (size: 0x10)

}; // Size: 0x158

class USoundSettingsHelper : public UBlueprintFunctionLibrary
{

    FAudioOutput BPF_GetAudioOuputFromType(EAudioOutputType _eType, bool& _bOutFound);
}; // Size: 0x28

class USoundTensionPortalVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class USpawnExternalActorNotify : public USCAnimNotify
{
    TSubclassOf<class AActor> m_ActorClassToSpawn;                                    // 0x0048 (size: 0x8)
    FName m_CharacterBoneName;                                                        // 0x0050 (size: 0x8)
    FName m_WeaponBoneName;                                                           // 0x0058 (size: 0x8)
    FVector m_SpawnOffset;                                                            // 0x0060 (size: 0xC)

}; // Size: 0x70

class USpawnerGroupVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class USpawnerVisualizerComponent : public UActorComponent
{
}; // Size: 0xC0

class USpecialAbilityPropertyDB : public UDataAsset
{
    float m_fSuccessGuardGaugeRefill;                                                 // 0x0030 (size: 0x4)
    class UAvailabilityLayerData* m_PushLayerOnSuccess;                               // 0x0038 (size: 0x8)
    TArray<FSpecialAbilityDelayedLayer> m_DelayedLayersOnSuccess;                     // 0x0040 (size: 0x10)

}; // Size: 0x50

class USpecialAttackData : public UDataAsset
{
    class UTexture2D* m_AvoidPictos;                                                  // 0x0030 (size: 0x38)
    class UTexture2D* m_ParryPictos;                                                  // 0x0068 (size: 0x10)
    class UTexture2D* m_GuardBreakPicto;                                              // 0x0078 (size: 0x8)
    class UTexture2D* m_InterruptPicto;                                               // 0x0080 (size: 0x8)
    class UTexture2D* m_AbsorbPicto;                                                  // 0x0088 (size: 0x8)

    class UTexture2D* GetParryPicto(EParrySide _eParryType);
    class UTexture2D* GetAvoidPicto(EAvoidType _eAvoidType);
}; // Size: 0x90

class USpeedCondition : public UBaseActorCondition
{
    ESpeedState m_eSpeedState;                                                        // 0x0028 (size: 0x1)
    bool m_bAcceptMoveTransitions;                                                    // 0x0029 (size: 0x1)
    EOperationType m_eOperation;                                                      // 0x002A (size: 0x1)

}; // Size: 0x30

class USpeedPivotFootData : public UDataAsset
{
    class UPivotFootData* m_MoveData;                                                 // 0x0030 (size: 0x8)
    class UPivotFootData* m_StartData;                                                // 0x0038 (size: 0x8)
    class UPivotFootData* m_StopData;                                                 // 0x0040 (size: 0x8)

}; // Size: 0x48

class USphereHitDetectionDB : public UBaseShapeHitDetectionDB
{
    float m_fRadius;                                                                  // 0x0070 (size: 0x4)

}; // Size: 0x78

class USpringCameraMixerBlender : public UCameraMixerBlender
{
    float m_fSpeedFactor;                                                             // 0x0030 (size: 0x4)

    float BPE_GetTargetRatio(class UCameraComponentThird* _camera);
    float BPE_GetSpeedFactor(class UCameraComponentThird* _camera, float _fTargetRatio, float _fOldRatio);
}; // Size: 0x38

class UStaminaNotify : public UAnimNotify
{
}; // Size: 0x38

class UStaminaOrderService : public UOrderService
{
    EStaminaImpactType m_eImpactOnStart;                                              // 0x0028 (size: 0x1)
    float m_fImpactCostOnStart;                                                       // 0x002C (size: 0x4)
    EStaminaImpactType m_eImpactOnStop;                                               // 0x0030 (size: 0x1)
    float m_fImpactCostOnStop;                                                        // 0x0034 (size: 0x4)

}; // Size: 0x38

class UStarUnlockCondition : public UObject
{

    bool BPE_VerifyCondition();
    void BPE_BindCallbacks(class AFightingCharacter* _FightingCharacter);
}; // Size: 0x28

class UStartStaminaRecoveryNotify : public UStaminaNotify
{
}; // Size: 0x38

class UStartTraversalNotify : public USCAnimNotify
{
}; // Size: 0x48

class UStartUpComboDB : public UDataAsset
{
    TArray<FName> m_ComboSlotNames;                                                   // 0x0030 (size: 0x10)

}; // Size: 0x40

class UStartupMenu : public UBaseStartMenu
{
    EStartupMenuState m_eCurrentState;                                                // 0x03F0 (size: 0x1)
    EMenuEnum m_eEnumType;                                                            // 0x03F1 (size: 0x1)
    int32 m_iShowPopupOnLoadResultMask;                                               // 0x03F4 (size: 0x4)

    void OnSequenceFinished();
    void OnContinueWithoutSavingConfirm();
    void OnConfirmGeneric();
    void OnConfirmCancel();
    void BPF_SetCanLaunchDirectly(bool _bLaunchDirectly);
    void BPF_NewGame();
    void BPF_LaunchIdlingStartupSequence(const class ASCBasePlayerController* _controller);
    bool BPF_IsCameraShakeNeeded();
    bool BPF_HasSaveGames();
    class AActor* BPF_GetStartSpot();
    EPlayerScreenSide BPF_GetPlayerScreenSide();
    void BPF_ContinueGame();
    bool BPF_CanLaunchDirectly(bool _bLaunchDirectly);
    bool BPF_AreAllImpostorsStable();
    void BPE_UserNameChanged(FString _name);
    void BPE_ShowState(EStartupMenuState _eState);
    void BPE_OnUserPressedStart(int32 UserIndex);
    void BPE_OnSaveLoaded();
    void BPE_OnSaveCreated();
    void BPE_OnAllImpostorsStabilized();
    bool BPE_HandleNavigationBack();
}; // Size: 0x428

class UStatModifiersAttributeSet : public USCAttributeSet
{
    FGameplayAttributeData FocusGainMultiplier;                                       // 0x0048 (size: 0x10)
    FGameplayAttributeData AvoidFocusGainBonus;                                       // 0x0058 (size: 0x10)
    FGameplayAttributeData DeflectFocusGainBonus;                                     // 0x0068 (size: 0x10)
    FGameplayAttributeData ParryImpactOnStructureBonus;                               // 0x0078 (size: 0x10)
    FGameplayAttributeData ParryImpactOnWeaponBonus;                                  // 0x0088 (size: 0x10)
    FGameplayAttributeData StructureGainOnAvoidBonus;                                 // 0x0098 (size: 0x10)
    FGameplayAttributeData StructureImpactWithBluntBonus;                             // 0x00A8 (size: 0x10)
    FGameplayAttributeData WeaponHealthMultiplier;                                    // 0x00B8 (size: 0x10)
    FGameplayAttributeData WeaponDamageMultiplier;                                    // 0x00C8 (size: 0x10)
    FGameplayAttributeData WeaponStructureImpactMultiplier;                           // 0x00D8 (size: 0x10)
    FGameplayAttributeData BarehandsDamageMultiplier;                                 // 0x00E8 (size: 0x10)
    FGameplayAttributeData BarehandsStructureImpactMultiplier;                        // 0x00F8 (size: 0x10)
    FGameplayAttributeData TakedownHealthGainMultiplier;                              // 0x0108 (size: 0x10)
    FGameplayAttributeData DamageReceivedMultiplier;                                  // 0x0118 (size: 0x10)
    FGameplayAttributeData CheatDamageReceivedMultiplier;                             // 0x0128 (size: 0x10)
    FGameplayAttributeData WeaponDamageReceivedMultiplier;                            // 0x0138 (size: 0x10)
    FGameplayAttributeData WeaponStructureImpactReceivedMultiplier;                   // 0x0148 (size: 0x10)

}; // Size: 0x158

class UStatsComponent : public UActorComponent
{
    FStatsComponentOnGlobalXPGain OnGlobalXPGain;                                     // 0x00C0 (size: 0x10)
    void XPGain(float _fXP);
    FStatsComponentOnStatsChanged OnStatsChanged;                                     // 0x00D0 (size: 0x10)
    void StatsChanged();
    FStatsComponentOnStatChanged OnStatChanged;                                       // 0x00E0 (size: 0x10)
    void CharacterStatChangedDelegate(ECharacterStat _type, int32 _previousValue, int32 _currentValue);
    FStatsComponentOnNotifyLevelUp OnNotifyLevelUp;                                   // 0x00F0 (size: 0x10)
    void LevelUp();
    FStatsComponentOnNotifyProgressionRewardUnlocked OnNotifyProgressionRewardUnlocked; // 0x0100 (size: 0x10)
    void ProgressionRewardUnlocked(ECharacterProgressionRewardTypes _eRewardType, const FCharacterProgressionReward& _reward, class UCharacterProgressionUnlockDB* _unlock);
    FStatsComponentOnProgressionUpdated OnProgressionUpdated;                         // 0x0110 (size: 0x10)
    void ProgressionUpdated();
    FStatsComponentOnAttackDiscovered OnAttackDiscovered;                             // 0x0120 (size: 0x10)
    void AttackDiscovered(const FAttackDataRow& _attack, class AFightingCharacter* _opponent);
    FStatsComponentOnAttackUnlockProgress OnAttackUnlockProgress;                     // 0x0148 (size: 0x10)
    void AttackProgressionUpdated(const FAttackDataRow& _attack, int32 _iAmount);
    FStatsComponentOnAttackProgressionLost OnAttackProgressionLost;                   // 0x0158 (size: 0x10)
    void AttackProgressionLost(class AFightingCharacter* _opponent);
    FStatsComponentOnAttackPendingProgressionUpdated OnAttackPendingProgressionUpdated; // 0x0168 (size: 0x10)
    void AttackPendingProgressionUpdated(class AFightingCharacter* _opponent, FName _attack, int32 _XP, EPendingttackXPType _eXPType, bool _bDiscovered);
    FStatsComponentOnAttackPendingProgressionValidated OnAttackPendingProgressionValidated; // 0x0178 (size: 0x10)
    void AttackPendingProgressionValidated(class AFightingCharacter* _opponent);
    FStatsComponentOnAttackUnlocked OnAttackUnlocked;                                 // 0x0188 (size: 0x10)
    void AttackUnlocked(const FAttackDataRow& _attack);
    FStatsComponentOnSpecialAbilityUnlockProgress OnSpecialAbilityUnlockProgress;     // 0x0198 (size: 0x10)
    void FightingStyleUnlockProgress(int32 _iSpecialAbility, float _fPrevProgress, float _fIncrement, bool _bValidated);
    FStatsComponentOnResourceAmountChanged OnResourceAmountChanged;                   // 0x01A8 (size: 0x10)
    void OnResourceAmountChanged(int32 _iNewAmount);
    FStatsComponent_OnPendantIncremented m_OnPendantIncremented;                      // 0x01B8 (size: 0x10)
    void PendantIncrement(EPendantUpdate _ePendantUpdate, class AActor* _actorGivingCharge);
    FStatsComponent_OnDeathCounterDecrement m_OnDeathCounterDecrement;                // 0x01C8 (size: 0x10)
    void DeathCounterDecrement(int32 _iCount, class AActor* _actor, bool _bAllowDecrement);
    class UStatsDB* m_StatsDB;                                                        // 0x01D8 (size: 0x8)
    EWeightCategory m_eWeightCategory;                                                // 0x01E0 (size: 0x1)
    int32 m_iMaxAge;                                                                  // 0x01E4 (size: 0x4)
    bool m_bAgeReversed;                                                              // 0x01E8 (size: 0x1)
    bool m_bUsePendant;                                                               // 0x01E9 (size: 0x1)
    bool m_bAllowDeathCounterDecrement;                                               // 0x01EA (size: 0x1)
    float m_fAIPendingAttackXCancelDelay;                                             // 0x01EC (size: 0x4)
    class UCharacterProgressionDB* m_CharacterProgressionDB;                          // 0x01F0 (size: 0x8)
    TArray<int32> m_agingPerPendantCharge;                                            // 0x01F8 (size: 0x10)
    class UBaseWeaponData* m_weaponData;                                              // 0x0258 (size: 0x8)
    TArray<FFocusPointsGainStruct> m_FocusPointsGainDefinition;                       // 0x02B8 (size: 0x10)
    class UAbilitySystemComponent* m_AbilitySystem;                                   // 0x02D8 (size: 0x8)

    void XPGain__DelegateSignature(float _fXP);
    void StatsChanged__DelegateSignature();
    void ProgressionUpdated__DelegateSignature();
    void ProgressionRewardUnlocked__DelegateSignature(ECharacterProgressionRewardTypes _eRewardType, const FCharacterProgressionReward& _reward, class UCharacterProgressionUnlockDB* _unlock);
    void PendantIncrement__DelegateSignature(EPendantUpdate _ePendantUpdate, class AActor* _actorGivingCharge);
    void OnStatsChangedCallback();
    void OnResourceAmountChanged__DelegateSignature(int32 _iNewAmount);
    void OnPendingAttackXPOpponentEndPlay(class AActor* _actor, TEnumAsByte<EEndPlayReason::Type> _endPlayReason);
    void OnPendingAttackXPOpponentAITimeOut(class AFightingCharacter* _ai);
    void OnOwnerKilledSomething(class AActor* _victim, bool _bIsOnlyAssist, bool _bKillingBlow, class AActor* _Instigator, const FDamageInfos& _damage);
    void OnMatchStarted();
    void OnEffectAddedOrRemovedCallback(bool _bAdded, class UEffectData* _effectData);
    void LevelUp__DelegateSignature();
    int32 GetXPBonusOnKill(const class AActor* _victim);
    void FightingStyleUnlockProgress__DelegateSignature(int32 _iSpecialAbility, float _fPrevProgress, float _fIncrement, bool _bValidated);
    void DeathCounterDecrement__DelegateSignature(int32 _iCount, class AActor* _actor, bool _bAllowDecrement);
    void BPF_UpdateChargeLimit();
    void BPF_UnlockReward(ECharacterProgressionRewardTypes _eReward, bool _bNotify);
    void BPF_UnlockProgressionRewards(int32 _iPrevLevel, int32 _iNewLevel, TArray<ECharacterProgressionRewardTypes>& _rewards, bool _bNotify, ECharacterProgressionRewardConditions _eLevelType);
    void BPF_SetStat_Float(ECharacterStat _eStat, float _fValue);
    void BPF_SetStat(ECharacterStat _eStat, int32 _iValue);
    void BPF_SetCharacterAge(int32 _iAge);
    void BPF_ResetStat(ECharacterStat _eStat);
    void BPF_ResetDeathCounter(class AActor* _actorGivingCharge);
    void BPF_ResetCharacterStats();
    void BPF_LockReward(ECharacterProgressionRewardTypes _eReward);
    bool BPF_IsProgressionRewardUnlocked(const ECharacterProgressionRewardTypes _eReward);
    void BPF_IncrementPendantCharge(int32 _iChargesToAdd, class AActor* _actorGivingCharge);
    float BPF_GetWeightRatio(EStatsWeaponComputingMethod _eStatsComputingMethod, bool _bWithItemEffects);
    EWeightCategory BPF_GetWeightCategory();
    int32 BPF_GetTotalPendingAttackXP(class AFightingCharacter* _attacker);
    float BPF_GetStat_Float(ECharacterStat _eStat);
    int32 BPF_GetStat(ECharacterStat _eStat);
    int32 BPF_GetSparePoints();
    FText BPF_GetRewardNotificationText(ECharacterProgressionRewardTypes _eReward, class UCharacterProgressionUnlockDB* _unlock);
    TSoftObjectPtr<UTexture2D> BPF_GetRewardNotificationIcon(ECharacterProgressionRewardTypes _eReward, class UCharacterProgressionUnlockDB* _unlock);
    int32 BPF_GetRequiredXPForLevel(const int32 _iNewWantedLevel);
    int32 BPF_GetPendingAttackXP(class AFightingCharacter* _attacker, const FName& _attackName, EPendingttackXPType _eXPType);
    void BPF_GetPendingAttacks(class AFightingCharacter* _attacker, TArray<FName>& _outAttacks);
    int32 BPF_GetGlobalXP();
    int32 BPF_GetGlobalLevel();
    float BPF_GetFocusPointsRefillBonus(FSCUserDefinedEnumHandler _focusGainEnum);
    ECharacterStat BPF_GetCharacterStatFromAttribute(const FGameplayAttribute& _attribute);
    class UCharacterProgressionDB* BPF_GetCharacterProgressionDB();
    int32 BPF_GetCharacterAge();
    EAttackLearningState BPF_GetAttackLearningState(const FName& _attackName);
    int32 BPF_GetAgeIncrement(int32 _iPendantChargeIdx);
    void BPF_GenerateDeckDetailsForAttack(FCombatDeckDetails& _deckDetails, FName _attack, bool _bIsMirror, EStatsWeaponComputingMethod _eComputingMethod);
    void BPF_DecrementDeathCounter(int32 _iCount, class AActor* _actor);
    EWeightCategory BPF_ComputeWeightCategory(EStatsWeaponComputingMethod _eStatsComputingMethod, bool _bWithItemEffects);
    float BPF_ComputeDamageOnBlockingSword(float _fAttackDamage, float _fAttackingWeaponWeight, float _fBlockingWeaponWeight, bool _bGuardBroken);
    float BPF_ComputeDamageOnAttackingSword(float _fAttackDamage, float _fAttackingWeaponWeight, float _fBlockingWeaponWeight, bool _bGuardBroken, bool _bGuarding, float _fHittedCharNormalDefense, float _fHittedCharSpecialDefense);
    float BPF_ComputeDamage(float _fAttackDamage, float _fEquipmentDefense, bool _bSpecialDamage);
    bool BPF_CanResetStatPoints();
    void BPF_AddStat_Float(ECharacterStat _eStat, float _fAddedValue);
    void BPF_AddStat(ECharacterStat _eStat, int32 _iAddedValue);
    void BPF_AddPendingAttackXP(class AFightingCharacter* _attacker, const FName& _attackName, int32 _iXP, EPendingttackXPType _eXPType);
    void BPF_AddGlobalXP(EEarnXPInstigator _eXPInstigator, int32 _iXP, bool _bNotify);
    void BPF_AddAttackXP(const FName& _attackName, int32 _iXP, bool& _bLearnt);
    void BPE_WeightCategoryChanged(EWeightCategory _eWeightCategory);
    void BPE_StatChanged(ECharacterStat _eStat, int32 _previousValue, int32 _currentValue);
    void BPE_SparePointsWin(int32 _iNbSparePointsWin);
    void BPE_GetXPGain(class AActor* _victim, int32 VictimLevel, int32& XPLevel);
    void AttackUnlocked__DelegateSignature(const FAttackDataRow& _attack);
    void AttackProgressionUpdated__DelegateSignature(const FAttackDataRow& _attack, int32 _iAmount);
    void AttackProgressionLost__DelegateSignature(class AFightingCharacter* _opponent);
    void AttackPendingProgressionValidated__DelegateSignature(class AFightingCharacter* _opponent);
    void AttackPendingProgressionUpdated__DelegateSignature(class AFightingCharacter* _opponent, FName _attack, int32 _XP, EPendingttackXPType _eXPType, bool _bDiscovered);
    void AttackDiscovered__DelegateSignature(const FAttackDataRow& _attack, class AFightingCharacter* _opponent);
}; // Size: 0x2F8

class UStatsCondition : public UBaseActorCondition
{
    ECharacterStat m_eStat;                                                           // 0x0028 (size: 0x1)
    FSCMathExpressionInteger m_MathExpression;                                        // 0x0030 (size: 0x20)

}; // Size: 0x50

class UStatsDB : public UDataAsset
{
    int32 m_iRestatCost;                                                              // 0x0030 (size: 0x4)
    int32 m_iChangeSchoolCost;                                                        // 0x0034 (size: 0x4)
    float m_fFightingStyleStatScaleCoef;                                              // 0x0038 (size: 0x4)
    class UCurveFloat* m_FightingStyleStatScaleBonusCurves;                           // 0x0040 (size: 0x30)
    class UCurveFloat* m_StatScaleBonusCurves;                                        // 0x0070 (size: 0x30)
    class UCurveFloat* m_MaxStatDamageCurve;                                          // 0x00A0 (size: 0x8)
    class UCurveFloat* m_WRScaleBonusCurves;                                          // 0x00A8 (size: 0x30)
    class UCurveFloat* m_MaxWRDamageCurve;                                            // 0x00D8 (size: 0x8)
    float m_fMaxDamage;                                                               // 0x00E0 (size: 0x4)
    float m_fMaxRange;                                                                // 0x00E4 (size: 0x4)
    float m_fMinSpeed;                                                                // 0x00E8 (size: 0x4)
    float m_fMaxSpeed;                                                                // 0x00EC (size: 0x4)
    float m_fMaxDamageBonus;                                                          // 0x00F0 (size: 0x4)
    FSCInt32Range m_MaxWeightStatLevelRange;                                          // 0x00F4 (size: 0x8)
    FSCFloatRange m_MaxWeightAtLevelRange;                                            // 0x00FC (size: 0x8)
    int32 m_iMaxLevel;                                                                // 0x0104 (size: 0x4)
    int32 m_iStatBonusMaxLevel;                                                       // 0x0108 (size: 0x4)
    float m_WeightCategoryThresholds;                                                 // 0x010C (size: 0x10)
    float m_fXPGainRatioForAssist;                                                    // 0x011C (size: 0x4)
    float m_fXPGainRatioForKillingBlow;                                               // 0x0120 (size: 0x4)
    int32 m_iXPGainThresholdForKillingBlow;                                           // 0x0124 (size: 0x4)
    class UCurveFloat* m_StrengthAverageCurve;                                        // 0x0128 (size: 0x8)
    class UCurveFloat* m_AgilityAverageCurve;                                         // 0x0130 (size: 0x8)
    class UCurveFloat* m_WeightRatioAverageCurve;                                     // 0x0138 (size: 0x8)
    class UCurveFloat* m_WeaponDamageAverageCurve;                                    // 0x0140 (size: 0x8)
    class UCurveFloat* m_AttackBonusCurve;                                            // 0x0148 (size: 0x8)
    class UCurveFloat* m_GearAttackBonusScaleCurves;                                  // 0x0150 (size: 0x30)
    int32 m_iBonusXPWhenPendantIsFull;                                                // 0x0180 (size: 0x4)

}; // Size: 0x188

class UStatsTools : public UBlueprintFunctionLibrary
{

    EAttributeScales ConvertFloatToAttributeScale(float _fValue);
    float ConvertAttributeScaleToFloat(EAttributeScales _eAttributeScale);
    FText BPF_GetTextFromFloatAttributeScale(float _scale);
    FText BPF_GetTextFromAttributeScale(EAttributeScales _eScale);
}; // Size: 0x28

class UStealTargetWeapon_Notify : public USCAnimNotify
{
    bool m_bMirrorPickup;                                                             // 0x0048 (size: 0x1)

}; // Size: 0x50

class UStopLowStructureOnPrefightAction : public UDialogActionBase
{
    FName m_ActorKey;                                                                 // 0x0030 (size: 0x8)

    TArray<FName> GetActorOptions();
}; // Size: 0x38

class UStructureInfluenceTest : public UFloatInfluenceTest
{
}; // Size: 0x60

class USuspiciousBTService : public UBTService
{
}; // Size: 0x78

class USwapWeaponHandNotify : public USCAnimNotify
{
}; // Size: 0x48

class USwitchPhaseDialogAction : public UDialogActionBase
{
    FName m_NewPhase;                                                                 // 0x0030 (size: 0x8)

}; // Size: 0x38

class USwitchableOrderComponent : public UFightingOrderComponent
{
    TMap<class EOrderType, class TSubclassOf<UOrderDB>> m_ExtraOrderInfos;            // 0x03F8 (size: 0x50)

}; // Size: 0x458

class USynchronizedAttackHitActionLauncher : public UHitActionLauncher
{
    bool m_bMirrorByQuadrant;                                                         // 0x0038 (size: 0x1)
    EOrderType m_eInstigatorOrderType;                                                // 0x0039 (size: 0x1)
    EOrderType m_eVictimOrderType;                                                    // 0x003A (size: 0x1)
    bool m_bIsInstigatorSnaper;                                                       // 0x003B (size: 0x1)
    bool m_bIsVictimSnaper;                                                           // 0x003C (size: 0x1)
    TArray<EFightingState> m_InstigatorRemoveFightingStates;                          // 0x0040 (size: 0x10)
    TArray<EFightingState> m_VictimRemoveFightingStates;                              // 0x0050 (size: 0x10)
    FEditableOrderType m_OrderTypeInstigator;                                         // 0x0060 (size: 0x58)
    FEditableOrderType m_OrderTypeVictim;                                             // 0x00B8 (size: 0x58)
    bool m_bCanCounterGrab;                                                           // 0x0110 (size: 0x1)
    bool m_bUseVictimForQuadrantComputation;                                          // 0x0111 (size: 0x1)
    EQuadrantTypes m_eStartQuadrant;                                                  // 0x0112 (size: 0x1)
    bool m_bMirrorOnBackFrontQuadrant;                                                // 0x0113 (size: 0x1)

    bool BPF_AreHitLethal(class AFightingCharacter* _victimChar, const TArray<FOverridingHitBox>& _hitsToApply);
    void BPE_OnLaunch(const FHitDescription& _hitDescription, class AActor* _Instigator, uint8 _uiInstigatorOrder, class AActor* _victim, uint8 _uiVictimOrder);
    void BPE_GetSynchronizedAttackAnims(const FHitDescription& _hitDescription, class AFightingCharacter* _victimChar, FAnimSyncContainer& _outAnims, FWeaponAnimInfo& _outAttackerWeaponAnim, TArray<FOverridingHitBox>& _outHitsToApply, bool& _bOutDisableMirroring);
}; // Size: 0x118

class USynchronizedAttackLoopHitActionLauncher : public USynchronizedAttackHitActionLauncher
{
    FEditableOrderType m_grabOrderTypeInstigator;                                     // 0x0118 (size: 0x58)
    FEditableOrderType m_grabOrderTypeVictim;                                         // 0x0170 (size: 0x58)
    float m_fLoopDistance;                                                            // 0x01C8 (size: 0x4)
    float m_fFinalDistanceFromFengjie;                                                // 0x01CC (size: 0x4)

    void BPE_GetSynchronizedAttackLoopAnims(const FHitDescription& _hitDescription, class AFightingCharacter* _victimChar, bool& _bOutIsLethal, FAnimSyncContainer& _outAnimsEntry, FAnimSyncContainer& _outAnimsLoop, FAnimSyncContainer& _outAnimsExit, FWeaponAnimInfo& _outAttackerWeaponAnimEntry, FWeaponAnimInfo& _outAttackerWeaponAnimLoop, FWeaponAnimInfo& _outAttackerWeaponAnimExit, TArray<FOverridingHitBox>& _outHitsToApply);
}; // Size: 0x1D0

class UTC_ConditionGroup : public UEvaluateTargetCondition
{
    EConditionGroupOperators m_eOperator;                                             // 0x0030 (size: 0x1)
    TArray<class UEvaluateTargetCondition*> m_Conditions;                             // 0x0038 (size: 0x10)

}; // Size: 0x48

class UTC_ConditionOnTargettingType : public UEvaluateTargetCondition
{
    ETargetingPrio m_eTargettingType;                                                 // 0x0030 (size: 0x1)
    bool m_bDefaultValue;                                                             // 0x0031 (size: 0x1)
    class UEvaluateTargetCondition* m_condition;                                      // 0x0038 (size: 0x8)

}; // Size: 0x40

class UTC_Distance : public UEvaluateTargetCondition
{
    ESCMathCondition m_eCondition;                                                    // 0x0030 (size: 0x1)
    float m_fDistance;                                                                // 0x0034 (size: 0x4)

}; // Size: 0x38

class UTC_FromClass : public UEvaluateTargetCondition
{
    TSubclassOf<class UEvaluateTargetCondition> m_Class;                              // 0x0030 (size: 0x8)

}; // Size: 0x38

class UTC_GenericCondition : public UEvaluateTargetCondition
{
    FBaseActorTargetConditionInstance m_condition;                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

class UTC_Inverse : public UEvaluateTargetCondition
{
    class UEvaluateTargetCondition* m_condition;                                      // 0x0030 (size: 0x8)

}; // Size: 0x38

class UTE_AllInRange : public UBaseTargetEvaluation
{
}; // Size: 0x38

class UTE_CameraTarget : public UBaseTargetEvaluation
{
    bool m_bOnlyRelevantForOneTarget;                                                 // 0x0038 (size: 0x1)

}; // Size: 0x40

class UTE_CurrentAttacked : public UBaseTargetEvaluation
{
    float m_fAutoSelectTargetCooldown;                                                // 0x0038 (size: 0x4)

}; // Size: 0x40

class UTE_DesignatedPrecise : public UBaseTargetEvaluation
{
    InputAction m_eDirectionAction;                                                   // 0x0038 (size: 0x1)
    float m_fOnScreenToleranceTimeForDesignated;                                      // 0x003C (size: 0x4)
    bool m_bUseRetrainOnDesignatedToOnScreenTargets;                                  // 0x0040 (size: 0x1)

}; // Size: 0x48

class UTE_DesignatedRough : public UTE_DesignatedPrecise
{
}; // Size: 0x48

class UTE_DirectionalWeightEvaluation : public UBaseTargetEvaluation
{
    InputAction m_eAction;                                                            // 0x0038 (size: 0x1)
    bool m_bBlockWhenActionIsInactive;                                                // 0x0039 (size: 0x1)
    EWeightBinaryOperator m_eOperator;                                                // 0x003A (size: 0x1)
    TArray<class UBaseDirectionalTargetWeightEvaluation*> m_Evaluations;              // 0x0040 (size: 0x10)

}; // Size: 0x50

class UTE_GetOrderTarget : public UBaseTargetEvaluation
{
    FEditableOrderType m_OrderType;                                                   // 0x0038 (size: 0x58)
    bool m_bIncludeChildTypes;                                                        // 0x0090 (size: 0x1)

}; // Size: 0x98

class UTE_LockMoveTarget : public UBaseTargetEvaluation
{
}; // Size: 0x38

class UTE_Nearest : public UBaseTargetEvaluation
{
    float m_fOutOfSightTimer;                                                         // 0x0038 (size: 0x4)
    float m_fAutoSelectTargetCooldown;                                                // 0x003C (size: 0x4)
    bool m_bWantKeepPreviousTarget;                                                   // 0x0040 (size: 0x1)
    bool m_bAutoResetBestTarget;                                                      // 0x0041 (size: 0x1)

}; // Size: 0x48

class UTE_NearestMenace : public UTE_Nearest
{
}; // Size: 0x48

class UTE_NearestVirtual : public UBaseTargetEvaluation
{
}; // Size: 0x38

class UTE_NextHit : public UBaseTargetEvaluation
{
    float m_fMinHitboxTimeLeft;                                                       // 0x0038 (size: 0x4)

    bool BPF_TryGetTargetExtraInfos(const class AFightingCharacter* _character, const FTargetResult& _targetInfos, FETS_NextHitExtraInfos& _infos);
}; // Size: 0x40

class UTE_Preview : public UBaseTargetEvaluation
{
    float m_fCameraTargetDirectionCoeff;                                              // 0x0038 (size: 0x4)

}; // Size: 0x40

class UTE_TargetSlot : public UBaseTargetEvaluation
{
    FSCUserDefinedEnumHandler m_Slot;                                                 // 0x0038 (size: 0x50)
    bool m_bForced;                                                                   // 0x0088 (size: 0x1)

}; // Size: 0x90

class UTE_WeightEvaluation : public UBaseTargetEvaluation
{
    EWeightBinaryOperator m_eOperator;                                                // 0x0038 (size: 0x1)
    TArray<class UBaseTargetWeightEvaluation*> m_Evaluations;                         // 0x0040 (size: 0x10)

}; // Size: 0x50

class UTabWidget : public UUserWidget
{
    uint8 m_uiEnumValue;                                                              // 0x0268 (size: 0x1)

    uint8 BPF_GetEnumValue();
}; // Size: 0x270

class UTableWidget : public UVerticalBox
{
    bool m_bUseCustomLayout;                                                          // 0x0130 (size: 0x1)
    FMargin m_LeftItemPadding;                                                        // 0x0134 (size: 0x10)
    FMargin m_RightItemPadding;                                                       // 0x0144 (size: 0x10)
    FMargin m_CenterItemsPadding;                                                     // 0x0154 (size: 0x10)
    FSlateChildSize m_ItemSize;                                                       // 0x0164 (size: 0x8)
    TEnumAsByte<EHorizontalAlignment> m_ItemHorizontalAlignment;                      // 0x016C (size: 0x1)
    TEnumAsByte<EVerticalAlignment> m_ItemVerticalAlignment;                          // 0x016D (size: 0x1)
    FMargin m_RowPadding;                                                             // 0x0170 (size: 0x10)
    FSlateChildSize m_RowSize;                                                        // 0x0180 (size: 0x8)
    TEnumAsByte<EHorizontalAlignment> m_RowHorizontalAlignment;                       // 0x0188 (size: 0x1)
    TEnumAsByte<EVerticalAlignment> m_RowVerticalAlignment;                           // 0x0189 (size: 0x1)
    FTableWidget_OnItemClicked m_OnItemClicked;                                       // 0x0190 (size: 0x10)
    void ItemClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FTableWidget_OnItemRightClicked m_OnItemRightClicked;                             // 0x01A0 (size: 0x10)
    void ItemRightClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FTableWidget_OnItemFocused m_OnItemFocused;                                       // 0x01B0 (size: 0x10)
    void ItemDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FTableWidget_OnItemLostFocus m_OnItemLostFocus;                                   // 0x01C0 (size: 0x10)
    void ItemDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FTableWidget_OnItemSelected m_OnItemSelected;                                     // 0x01D0 (size: 0x10)
    void ItemSelectedDelegate(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    FTableWidget_OnItemNavigation m_OnItemNavigation;                                 // 0x01E0 (size: 0x10)
    void ItemNavigationDelegate(class UButtonUserWidget* _button, EUINavigation _eNavigation, int32 _iItemIndex);
    FTableWidget_OnItemClicked_Bindable m_OnItemClicked_Bindable;                     // 0x01F0 (size: 0x10)
    void BindableButtonUserWidgetClickDelegate(class UButtonUserWidget* _button, bool _bWithMouse);
    FTableWidget_OnItemFocused_Bindable m_OnItemFocused_Bindable;                     // 0x0200 (size: 0x10)
    void BindableButtonUserWidgetDelegate(class UButtonUserWidget* _button, EFocusCause _eCause);
    FTableWidget_OnItemLostFocus_Bindable m_OnItemLostFocus_Bindable;                 // 0x0210 (size: 0x10)
    void ItemDelegate_Bindable(class UButtonUserWidget* _button, EFocusCause _eCause);
    bool m_bUseCustomNavigation;                                                      // 0x0220 (size: 0x1)
    int32 m_iItemsPerRow;                                                             // 0x0224 (size: 0x4)
    TSubclassOf<class UHorizontalBox> m_RowWidgetClass;                               // 0x0228 (size: 0x8)

    void OnItemSelected(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    void OnItemRightClicked(class UButtonUserWidget* _button, bool _bWithMouse);
    void OnItemNavigation(class UButtonUserWidget* _button, EUINavigation _eNavigation);
    void OnItemLostFocus(class UButtonUserWidget* _button, EFocusCause _eCause);
    void OnItemFocused(class UButtonUserWidget* _button, EFocusCause _eCause);
    void OnItemClicked(class UButtonUserWidget* _button, bool _bWithMouse);
    void ItemSelectedDelegate__DelegateSignature(class UButtonUserWidget* _button, class UButtonUserWidget* _prevButton);
    void ItemRightClickDelegate__DelegateSignature(class UButtonUserWidget* _button, bool _bWithMouse);
    void ItemNavigationDelegate__DelegateSignature(class UButtonUserWidget* _button, EUINavigation _eNavigation, int32 _iItemIndex);
    void ItemDelegate_Bindable__DelegateSignature(class UButtonUserWidget* _button, EFocusCause _eCause);
    void ItemDelegate__DelegateSignature(class UButtonUserWidget* _button, EFocusCause _eCause);
    void ItemClickDelegate__DelegateSignature(class UButtonUserWidget* _button, bool _bWithMouse);
    class UButtonUserWidget* BPF_GetSelectedButton();
    class UWidget* BPF_GetNextItem(class UWidget* currentButton, ECycleDirection _eDirection, bool _bSkipDisabled);
    class UWidget* BPF_GetLastVisibleItem();
    int32 BPF_GetItemIndex(class UWidget* _item);
    class UUserWidget* BPF_GetItemAtIndex(int32 _iIndex);
    int32 BPF_GetChildrenCount();
    void BPF_AddItem(class UUserWidget* _widget);
}; // Size: 0x230

class UTakedownAnimRequest : public UObject
{

    void BPE_GetPushFromGrabAnimation(const class AFightingCharacter* _Instigator, const class AFightingCharacter* _victim, float _fAngleFromVictimToInstigator, ESCCardinalPoints _eCardinalDirection, const FNetOrderStructGrab& _grabInfos, const FNetOrderStructGrab& _grabbedInfos, const class UActorComponent* _environment, FAnimContainer& _instigatorAnims, FAnimContainer& _victimAnim);
    void BPE_GetAnimation(InputAction _eAction, const FTargetResult& _targetInfos, const class AFightingCharacter* _Instigator, const class AFightingCharacter* _victim, float _fAngleFromVictimToInstigator, const FNetOrderStructTakedown& _takedownInfos, const class UActorComponent* _environment, TArray<FAnimSyncContainer>& _anims, bool& _mirror, bool _bForceOnTraversal);
}; // Size: 0x28

class UTakedownInstigatorAbility : public USCGameplayAbility
{
    float m_fSearchWallRadius;                                                        // 0x0568 (size: 0x4)
    float m_fSearchMarginFromWallEdge;                                                // 0x056C (size: 0x4)
    float m_fSnapMarginFromWallEdge;                                                  // 0x0570 (size: 0x4)
    float m_fMaxDistFromWall;                                                         // 0x0574 (size: 0x4)
    float m_fMaxSnapDistance;                                                         // 0x0578 (size: 0x4)
    FHitBox m_WallEnvHit;                                                             // 0x0580 (size: 0x298)
    FName m_WallEnvHitBoneName;                                                       // 0x0818 (size: 0x8)
    float m_fMaxAngleWithNavMeshDeg;                                                  // 0x0820 (size: 0x4)
    bool m_bHandleEnvironmentalInteractionComponents;                                 // 0x0824 (size: 0x1)

}; // Size: 0x828

class UTakedownVictimAbility : public USCGameplayAbility
{
}; // Size: 0x568

class UTakendownImpactNotify : public UAnimNotify
{
}; // Size: 0x38

class UTargetActionTypePerCondition : public UTargetActionTypeRequest
{
    TMap<class EActionType, class FBaseActorConditionInstance> m_ActionTypePerCondition; // 0x0028 (size: 0x50)
    EActionType m_eDefaultValue;                                                      // 0x0078 (size: 0x1)

}; // Size: 0x80

class UTargetActionTypeRequest : public UObject
{

    EActionType BPE_GetTargetActionType(const class AActor* _owner);
}; // Size: 0x28

class UTargetCondition : public UBaseActorTargetCondition
{
    FBaseActorConditionInstance m_condition;                                          // 0x0028 (size: 0x10)

}; // Size: 0x38

class UTargetDB : public UDataAsset
{
    TEnumAsByte<ECollisionChannel> m_eTargetVisibleCollisionChannel;                  // 0x0030 (size: 0x1)
    uint32 m_uiFightingAiBehaviorMask;                                                // 0x0034 (size: 0x4)
    float m_fTargetVisibleTraceVerticalDelta;                                         // 0x0038 (size: 0x4)
    FCollisionResponseContainer m_TargetVisibleCollisionContainer;                    // 0x003C (size: 0x20)
    TArray<EActionType> m_PriorityWithoutTarget;                                      // 0x0060 (size: 0x10)
    TArray<EActionType> m_PriorityWithSameTarget;                                     // 0x0070 (size: 0x10)
    TArray<EActionType> m_PriorityWithDifferentTarget;                                // 0x0080 (size: 0x10)
    uint8 m_aUseTargetingReaction;                                                    // 0x0090 (size: 0x7)
    EMoveStatus m_MoveStatusOutOfFightRange;                                          // 0x0097 (size: 0x6)
    EMoveStatus m_MoveStatusInFightRange;                                             // 0x009D (size: 0x6)
    class UCurveFloat* m_MaxZDiff;                                                    // 0x00A8 (size: 0x8)
    float m_fTargetMaxRange;                                                          // 0x00B0 (size: 0x4)
    TMap<class EActionType, class TSubclassOf<UTargetSettingsDB>> m_Settings;         // 0x00B8 (size: 0x50)

}; // Size: 0x108

class UTargetReachableCondition : public UBaseActorTargetCondition
{
    float m_fNavigationCostHeuristicScale;                                            // 0x0028 (size: 0x4)
    float m_fMaxPathCost;                                                             // 0x002C (size: 0x4)
    float m_fMaxDistance;                                                             // 0x0030 (size: 0x4)
    bool m_bOutOfNavmeshResult;                                                       // 0x0034 (size: 0x1)
    TSubclassOf<class UNavigationQueryFilter> m_QueryFilter;                          // 0x0038 (size: 0x8)
    FRuntimeFloatCurve m_AutorizedAngleWithTargetPerDistance;                         // 0x0040 (size: 0x88)
    float m_fMaxVerticalDistanceFromProjection;                                       // 0x00C8 (size: 0x4)
    FVector m_vNavQueryExtent;                                                        // 0x00CC (size: 0xC)

}; // Size: 0xD8

class UTargetSettingsDB : public UObject
{
    FTargetSettings m_Settings;                                                       // 0x0028 (size: 0x40)

}; // Size: 0x68

class UTargetableActorComponent : public USceneComponent
{
    bool m_bShouldDisplayBP;                                                          // 0x0210 (size: 0x1)
    bool m_bAlwaysShowHUD;                                                            // 0x0211 (size: 0x1)
    EFactionsEnums m_eFaction;                                                        // 0x0218 (size: 0x1)
    class UCurveFloat* m_CustomMaxZDiff;                                              // 0x0220 (size: 0x8)
    bool m_bIsValidTarget;                                                            // 0x0228 (size: 0x1)
    float m_fMaxRange;                                                                // 0x022C (size: 0x4)
    TMap<class EActionType, class FTargetableConditions> m_ActionTypeConditions;      // 0x0230 (size: 0x50)
    TMap<class ETargetingPrio, class bool> m_mAllowedTargetingType;                   // 0x0280 (size: 0x50)
    TMap<class EActionType, class bool> m_mAllowedActionType;                         // 0x02D0 (size: 0x50)
    bool m_bCanBeTargetedByLockMove;                                                  // 0x0321 (size: 0x1)

    void BPF_SetShouldDisplay(bool _bSHould);
}; // Size: 0x330

class UTargetableActorHelper : public UBlueprintFunctionLibrary
{

    FVector BPF_GetTargetableLocation(const class AActor* _actor);
}; // Size: 0x28

class UTargetableComponent : public UActorComponent
{
    bool m_bShouldDisplayBP;                                                          // 0x00C8 (size: 0x1)

    void BPF_SetShouldDisplay(bool _bSHould);
}; // Size: 0xD8

class UTargetableWidget : public UHUDUserWidget
{
    bool m_bSetVisibleWhenRelatedActorSet;                                            // 0x0398 (size: 0x1)

    void BPF_SetRelatedActor(class AActor* _actor);
    void BPF_RemoveAttachedWidget(class UWidget* _widget);
    class AActor* BPF_GetRelatedActor();
    void BPF_AddAttachedWidget(class UWidget* _widget, FVector _vOffset3D, FVector2D _vOffset2D, class USceneComponent* _sceneComponent, FName _socket);
    void BPE_RelatedActorRelationshipChanged(ERelationshipTypes _eRelation);
    void BPE_RelatedActorChanged(class AActor* _actor);
    void BPE_OnAIPhaseChanged(int32 _iPreviousPhase, int32 _iPhase, FName _archetypeName);
    void BPE_FightDetectionWarning();
}; // Size: 0x440

class UTargetableWidgetUpdaterComponent : public UActorComponent
{
    TSubclassOf<class UTargetableWidget> m_TargetWidgetToUse;                         // 0x00F8 (size: 0x8)
    float m_fMaxDisplayDist;                                                          // 0x0100 (size: 0x4)
    TArray<class UTargetableWidget*> m_WidgetPool;                                    // 0x0108 (size: 0x10)

    void UnRegisterTargetActor(class AActor* _actor);
    void RegisterTargetActor(class AActor* _actor);
    void OnLeavingMap();
    void BPF_UpdateWidgetVisibility();
    class UTargetableWidget* BPF_GetAssociatedWidget(class AActor* _actor);
}; // Size: 0x158

class UTargettingHelper : public UBlueprintFunctionLibrary
{

    FString GetEditorTitle(const FTargetEvaluationSettings& _settings);
    FString GetEditorDesc(const FTargetEvaluationSettings& _settings);
}; // Size: 0x28

class UTauntAbility : public USCGameplayAbility
{
    class URandomAnimDB* m_randomAnimDB;                                              // 0x0568 (size: 0x8)

}; // Size: 0x570

class UTextBlockScroll : public USCUserWidget
{
    float m_fRestartDelay;                                                            // 0x0328 (size: 0x4)
    float m_fPixelPerSeconds;                                                         // 0x032C (size: 0x4)
    class UMaterialInstanceDynamic* m_MaterialInstance;                               // 0x0358 (size: 0x8)
    class UMaterialInterface* m_Material;                                             // 0x0360 (size: 0x8)
    float m_fMargin;                                                                  // 0x0368 (size: 0x4)

    void BPF_SetOpacity(const float& _fOpacity);
    void BPF_ScrollTextIfNeeded(class UTextBlock* _textBlock, class URetainerBox* _retainerBox);
    void BPF_RestartScroll();
    void BPE_OnScrollingStarted();
    void BPE_OnScrollingReset(bool _bScrollingNeeded);
    void BPE_OnScrollingEnded();
}; // Size: 0x370

class UThePlainesGameInstance : public USCGameInstance
{
    FThePlainesGameInstanceBPE_OnErrorRaised BPE_OnErrorRaised;                       // 0x02A8 (size: 0x10)
    void OnErrorRaised();
    FThePlainesGameInstanceOnFadeOver OnFadeOver;                                     // 0x02B8 (size: 0x10)
    void FadeOverDelegate();
    FThePlainesGameInstanceOnCinematicCompleted OnCinematicCompleted;                 // 0x02C8 (size: 0x10)
    void CinematicCompleted();
    TSubclassOf<class UUserWidget> m_loadingScreenClass;                              // 0x0318 (size: 0x8)
    class UUserWidget* m_loadingScreen;                                               // 0x0320 (size: 0x8)
    class UAkAudioEvent* m_MuteEvent;                                                 // 0x0328 (size: 0x8)
    TArray<FAkExternalSourceInfo> m_MuteExternalSourceInfos;                          // 0x0330 (size: 0x10)
    class UAkAudioEvent* m_UnmuteEvent;                                               // 0x0340 (size: 0x8)
    TArray<FAkExternalSourceInfo> m_UnmuteExternalSourceInfos;                        // 0x0348 (size: 0x10)
    class UWGGameFlow* m_GameFlow;                                                    // 0x0378 (size: 0x8)
    FName m_AntiCheatMapTagName;                                                      // 0x0380 (size: 0x8)
    class UItemsDB* m_ItemsDB;                                                        // 0x03A8 (size: 0x8)
    class UInputManager* m_InputManager;                                              // 0x03B0 (size: 0x8)
    class UFactionsManager* m_FactionsManager;                                        // 0x03C0 (size: 0x8)
    TSubclassOf<class UPredictionManager> m_PredictionManagerClass;                   // 0x03D0 (size: 0x8)
    class UCinematicManager* m_CinematicManager;                                      // 0x03D8 (size: 0x8)
    TSubclassOf<class UCinematicManager> m_CinematicManagerClass;                     // 0x03E0 (size: 0x8)
    class UMessageManager* m_MessageManager;                                          // 0x03E8 (size: 0x8)
    class USCSessionManager* m_sessionManager;                                        // 0x03F0 (size: 0x8)
    class USessionTimeManager* m_SessionTimeManager;                                  // 0x03F8 (size: 0x8)
    class UReplaySystem* m_ReplaySystem;                                              // 0x0478 (size: 0x8)

    void TriggerTakeKinectResources(bool _bTake);
    void TriggerResetGameFlowTags();
    void TriggerReloadConfig();
    void TriggerRaiseGameFlowTag(FName _gameplayTag);
    void TriggerCrashAfterDelay(int32 _iDelay);
    void TriggerAchievementProgress(FString _achievementId, float _fCompletionPercent);
    void TravelToNextMap();
    void TravelToLoadedMap(FString _sMapToTravelTo);
    void Replay_Stop();
    void Replay_Start();
    void Replay_Play();
    void Replay_PauseRecording();
    void OnErrorRaised__DelegateSignature();
    void Logout(int32 _index);
    void LoadMapAsync(FString _sPackageName);
    void GoToNextMap();
    void GoToMapInGameFlow(FString _sMapToTravelTo);
    void GiveBestScoreToAllChallenges();
    class USCLocalPlayer* GetLocalPlayer();
    void FadeOverDelegate__DelegateSignature();
    void DumpWorlds();
    void DumpLoadedLevels();
    void CinematicCompleted__DelegateSignature();
    bool BPF_WantToDisplayGamerTagOnLoadingScreen();
    void BPF_StopSequence(class ALevelSequenceActor* _levelSequenceActor);
    void BPF_SetLoadingScreenTickTime(float _fNewTime);
    void BPF_SetDebugFlow(bool _bDebugFlow);
    void BPF_ResetNextMapTags();
    void BPF_RaiseNextMapTags(FGameplayTag _tagToRaise);
    void BPF_RaiseError(const FSCError& _error);
    void BPF_PlaySequence(class ALevelSequenceActor* _levelSequenceActor, bool _bHideLoadingScreen);
    bool BPF_IsDebugFlow();
    bool BPF_IsCultureHasBeenSet();
    void BPF_HideLoadingScreen(bool _bFade, float _fFadeDuration);
    class UReplaySystem* BPF_GetReplaySystem();
    class ASCPlayerStart* BPF_GetPlayerStartUsedAtSpawn();
    bool BPF_GetPlayerNameFromControllerID(int32 _iControllerID, FString& _outPlayerName);
    FString BPF_GetPlayerId(class ULocalPlayer* _player);
    float BPF_GetLoadingScreenTickTime();
    class UWGGameFlow* BPF_GetGameFlow();
    bool BPF_ConsumeNextError(FSCError& _error);
    bool BPF_CanTargetFaction(EFactionsEnums _eMyFaction, EFactionsEnums _eTargetFaction);
    void BPF_BeginLoadingScreen();
    bool BPE_OnGameActivityActivationRequestComplete(FString _activityID, bool _bStartedGameFromActivity);
    void BPE_OnAchievementObjectUnlocked(FGameplayTag ObjectUnlockedTag);
}; // Size: 0x570

class UThrowAttackInfluenceTest : public UAIInfluenceTest
{
    TSubclassOf<class AThrowableActor> m_ThrowableTypeToTest;                         // 0x0050 (size: 0x8)
    TSubclassOf<class UBaseWeaponData> m_WeaponDataTypeToTest;                        // 0x0058 (size: 0x8)

}; // Size: 0x60

class UThrowMultipleObjectsNotify : public UThrowObjectNotify
{
    float m_fHorizontalAngleRange;                                                    // 0x0080 (size: 0x4)
    uint8 m_uiNbThrowables;                                                           // 0x0084 (size: 0x1)
    TSubclassOf<class AThrowableActor> m_ThrowableClass;                              // 0x0088 (size: 0x8)
    bool m_bBreakThrowableAfterThrow;                                                 // 0x0090 (size: 0x1)
    float m_fVerticalOffsetSpawnPosition;                                             // 0x0094 (size: 0x4)
    float m_fVerticalOffsetTargetDirection;                                           // 0x0098 (size: 0x4)

}; // Size: 0xB0

class UThrowObjectAnimRequest : public UObject
{

    class UAttackDB* BPE_GetThrowComboAttack(const class AActor* _Instigator, const FVector& _vTargetDir, const class AThrowableActor* _throwable, const class AActor* _target, bool& _bOutMirror);
}; // Size: 0x28

class UThrowObjectNotify : public USCAnimNotify
{
    FVector m_vRotationAxisWhileFlying;                                               // 0x0058 (size: 0xC)
    float m_fRotationSpeed;                                                           // 0x0064 (size: 0x4)
    float m_fRandomRangeForRotationSpeed;                                             // 0x0068 (size: 0x4)
    bool m_bUseRandomRotationAxisWhileFlying;                                         // 0x006C (size: 0x1)
    bool m_bInvertAxisOnMirror;                                                       // 0x006D (size: 0x1)
    bool m_bUseThrowPivot;                                                            // 0x006E (size: 0x1)
    bool m_bForceThrowableOrientationAtStart;                                         // 0x006F (size: 0x1)
    FRotator m_RotationOffsetAtStart;                                                 // 0x0070 (size: 0xC)

}; // Size: 0x80

class UThrowableData : public UObject
{
    int32 m_iHitByCharaDamage;                                                        // 0x0028 (size: 0x4)
    int32 m_iHitByObjectDamage;                                                       // 0x002C (size: 0x4)
    FHitBox m_DefaultHitInfos;                                                        // 0x0030 (size: 0x298)
    FHitBox m_HitOnMCInfos;                                                           // 0x02C8 (size: 0x298)
    float m_fDistToThrow;                                                             // 0x0560 (size: 0x4)
    float m_fFallingSpeedThreshold;                                                   // 0x0564 (size: 0x4)
    float m_fColScaleDuration;                                                        // 0x0568 (size: 0x4)
    float m_fOnTargetHitSpeedReduction;                                               // 0x056C (size: 0x4)
    float m_fMissingSpeedReduc;                                                       // 0x0570 (size: 0x4)
    float m_fMissedDistance;                                                          // 0x0574 (size: 0x4)
    bool m_bApplyGravityWhenFlyingFreely;                                             // 0x0578 (size: 0x1)
    class UCurveFloat* m_BounceBackAngle;                                             // 0x0580 (size: 0x8)
    FFloatRange m_BounceBackRange;                                                    // 0x0588 (size: 0x10)
    float m_fSoundNoiseRadius;                                                        // 0x0598 (size: 0x4)
    EHeight m_eTargettedHeight;                                                       // 0x059C (size: 0x1)
    EHeight m_eAltTargettedHeight;                                                    // 0x059D (size: 0x1)
    bool m_bUseAlternateHeightForFreeThrow;                                           // 0x059E (size: 0x1)
    TSubclassOf<class UTargetSettingsDB> m_throwTargetSettingsDB;                     // 0x05A0 (size: 0x8)
    float m_fHeightLimitForFootAnimation;                                             // 0x05A8 (size: 0x4)
    float m_fOffsetDistTrace;                                                         // 0x05AC (size: 0x4)
    float m_fDistToCheckCollOnPathFreely;                                             // 0x05B0 (size: 0x4)
    bool m_bStayVisibleAfterBeingDestroyed;                                           // 0x05B4 (size: 0x1)
    float m_fThrowFreelyZForceHands;                                                  // 0x05B8 (size: 0x4)
    float m_fThrowFreelyZForceFeet;                                                   // 0x05BC (size: 0x4)
    float m_fThrowFreelyZForceFeetAlt;                                                // 0x05C0 (size: 0x4)
    float m_fTargetDistMaxToSwitchToFreely;                                           // 0x05C4 (size: 0x4)
    class UCurveFloat* m_SpeedCurve;                                                  // 0x05C8 (size: 0x8)
    float m_fInitialSpeedOnThrow;                                                     // 0x05D0 (size: 0x4)
    float m_fProjectileGravityScale;                                                  // 0x05D4 (size: 0x4)
    float m_fBounciness;                                                              // 0x05D8 (size: 0x4)
    float m_fFrictionOnBounce;                                                        // 0x05DC (size: 0x4)
    EBounceType m_eBounceType;                                                        // 0x05E0 (size: 0x1)

}; // Size: 0x5E8

class UThrowableInfoForAIDataAsset : public UDataAsset
{
    TArray<class TSubclassOf<AThrowableActor>> m_ThrowableInfo;                       // 0x0030 (size: 0x10)

}; // Size: 0x40

class UThrowableObjMovementComponent : public UProjectileMovementComponent
{
    float m_fThrowFreelyZForceHands;                                                  // 0x01E0 (size: 0x4)
    float m_fThrowFreelyZForceFeet;                                                   // 0x01E4 (size: 0x4)
    float m_fThrowFreelyZForceFeetAlt;                                                // 0x01E8 (size: 0x4)
    class UCurveFloat* m_SpeedCurve;                                                  // 0x01F0 (size: 0x8)
    float m_fFrictionForce;                                                           // 0x01F8 (size: 0x4)

}; // Size: 0x280

class UTicketSettings : public UObject
{
    int32 m_iSerializeVersion;                                                        // 0x0028 (size: 0x4)
    TMap<EAIWuguanTicketEvaluation, float> m_AttackTicketScoreFactors;                // 0x0030 (size: 0x50)
    TMap<EAIWuguanTicketEvaluation, float> m_PositionTicketScoreFactors;              // 0x0080 (size: 0x50)
    TMap<EAIWuguanTicketEvaluation, float> m_WeaponTicketScoreFactors;                // 0x00D0 (size: 0x50)
    TMap<class EAIAttackTicketJokerSituation, class FAIAttackJokerSituationConfigsPerDominationStep> m_AttackTicketJokerSituationsConfigs; // 0x0120 (size: 0x50)
    TMap<class TSoftClassPtr<UOrderDB>, class EAIAttackTicketJokerSituation> m_OrderDBToJokerSituationMap; // 0x0170 (size: 0x50)
    bool m_bActivateWeaponTicketManager;                                              // 0x01C0 (size: 0x1)
    float m_fDefaultWeaponTicketCooldown;                                             // 0x01C4 (size: 0x4)
    float m_fWeaponTicketCooldownIncreaseValue;                                       // 0x01C8 (size: 0x4)
    float m_fWeaponTicketCooldownDecreaseValue;                                       // 0x01CC (size: 0x4)
    float m_fDefaultMaxDistanceToWeapon;                                              // 0x01D0 (size: 0x4)
    float m_fMinDistanceForCandidateAttackCancel;                                     // 0x01D4 (size: 0x4)
    float m_fMinDistanceForAttackTicketTimeOut;                                       // 0x01D8 (size: 0x4)
    float m_fPathHeightTolerance;                                                     // 0x01DC (size: 0x4)
    float m_fPathFallHeightTolerance;                                                 // 0x01E0 (size: 0x4)
    float m_fPathHeightDifferenceWeight;                                              // 0x01E4 (size: 0x4)
    float m_fPathNavlinkWeight;                                                       // 0x01E8 (size: 0x4)
    TMap<class FSCAITicketEnum, class TSoftObjectPtr<UAIAttackTicketData>> m_AttackTicketsMap; // 0x01F0 (size: 0x50)

}; // Size: 0x240

class UTimeHelper : public UBlueprintFunctionLibrary
{

    float GetDiffBetweenToDateTimeInSeconds(const FDateTime& _dateTimeA, const FDateTime& _dateTimeB);
    FDateTime GetCurrentSynchedTimeInDateTime(const class UWorld* _world);
    float BPF_GetDeltaTimeSlowMotionIndependant(class UObject* _worldContextObject, float _fCurrentDt, float _fSlowMotionFactor);
    FText BPF_AsTimeZoneTime(const FDateTime& _inDateTime, const ESCDateTimeTextStyle _eDateStyle, const ESCDateTimeTextStyle _eTimeStyle);
    FText BPF_AsTimeZoneDate(const FDateTime& _inDateTime, const ESCDateTimeTextStyle _eDateStyle);
    FDateTime AddDelayToDateTime(const FDateTime& _dateTime, float _fDelayInSeconds);
}; // Size: 0x28

class UTimeParticleEffectNotifyStateExtended : public UAnimNotifyState_TimedParticleEffect
{
}; // Size: 0x60

class UTintDB : public UDataAsset
{
    TMap<class ETintEnum, class FTintData> m_TintsData;                               // 0x0030 (size: 0x50)

}; // Size: 0x80

class UToolTipWidget : public USCUserWidget
{
    TWeakObjectPtr<class UButtonUserWidget> m_Button;                                 // 0x0310 (size: 0x8)

}; // Size: 0x328

class UTrackingBlueprintHelper : public UBlueprintFunctionLibrary
{

    void BPF_SendTrackingEventTU4Launched();
    void BPF_SendTrackingEventChallengeStart(const FText _sChallengeName);
    void BPF_SendTrackingEventChallengeEnd(const FText _sChallengeName, const int32 _iHighScore, const uint8 _uiNumberStars);
    void BPF_SendTrackingEventAccessedArenaFirstTimeAfterBeatingYang();
    void BPF_SendTrackingEventAccessedArena();
    void BPF_SendTrackingEvent_UnlockAllSkillsPermanently(int64 _iTimePlayed);
    void BPF_SendTrackingEvent_OutfitUnlocked(const FGameplayTag& _outfitTag);
    void BPF_SendTrackingEvent_ModifierUnlocked(const FGameplayTag& _tag);
    void BPF_SendTrackingEvent_HideoutStarted(FString _mapName);
    void BPF_SendTrackingEvent_HideoutCompleted(FString _mapName);
    void BPF_SendTrackingEvent_GoalUnlocked(const FGameplayTag& _goalTag);
    void BPF_SendTrackingEvent_GoalsAvailable();
    void BPF_SendTrackingEvent_Ending(bool _bIsWudeEnding);
    FString BPF_OpenTrackingContext_GeographicalLocation(FString _text);
    FString BPF_OpenTrackingContext_AISituation(FString _text);
    void BPF_CloseTrackingContext(FString _GuidString);
}; // Size: 0x28

class UTrailNotifyStateExtended : public UAnimNotifyState_Trail
{
    bool m_bCheckInPerfectLink;                                                       // 0x0058 (size: 0x1)
    bool m_bCheckNotInPerfectLink;                                                    // 0x0059 (size: 0x1)
    FString m_BaseName;                                                               // 0x0060 (size: 0x10)

}; // Size: 0x70

class UTransitionAnimMetadata : public UAnimMetaData
{
    int32 m_iLastPrevDirectionMarkerIndex;                                            // 0x0028 (size: 0x4)

}; // Size: 0x30

class UTransitionAnimRequest : public UObject
{
    bool m_bMirrorAllowed;                                                            // 0x0028 (size: 0x1)
    FLocomotionTransitionsAnimContainer m_Transitions;                                // 0x0030 (size: 0xF60)
    FLocomotionTransitionsAnimContainer m_WeaponTransitions;                          // 0x0F90 (size: 0xF60)
    FAnimContainer m_MediumLanding;                                                   // 0x1EF0 (size: 0x18)
    FAnimContainer m_OnPlaceMediumLanding;                                            // 0x1F08 (size: 0x18)

}; // Size: 0x1F20

class UTransitionCanInterruptNotifyState : public USCAnimNotifyState
{
    FBool m_TransitionAllowance;                                                      // 0x0048 (size: 0x56)
    FName m_BaseName;                                                                 // 0x00A0 (size: 0x8)

    void InvertUTurn();
    void InvertTurnInPlace();
    void InvertStrafe();
    void InvertStop();
    void InvertStart();
    void InvertAll();
    void AllowNone();
    void AllowAll();
}; // Size: 0xA8

class UTransitionCanTurnNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UTransitionChangeSystemAxisToDirNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UTransitionTeleportRestraintNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UTranslateToTargetOrderService : public UOrderService
{
    bool m_bUseAnimRootMotion;                                                        // 0x0028 (size: 0x1)

    FVector BPE_GetTarget(const FBPOrderServiceInstance& _instance);
}; // Size: 0x30

class UTranslationOSNotifyState : public UOrderServiceNotifyState
{
    bool m_bUseAnimRootMotion;                                                        // 0x0068 (size: 0x1)

}; // Size: 0x70

class UTraversalAbility : public USCGameplayAbility
{
    uint8 m_uiEntryTypes;                                                             // 0x0568 (size: 0x1)

}; // Size: 0x638

class UTraversalActorCondition : public UBaseActorCondition
{
    ETraversalPhase m_ePhase;                                                         // 0x0028 (size: 0x1)

}; // Size: 0x30

class UTraversalAnimRequest : public UObject
{

    void BPE_GetTraversalAnimations(const FTraversalInfo& _request, ESCCardinalPoints _eCardinalPoint, ESpeedState _eSpeedState, FTraversalAnimContainer& _outResult);
    void BPE_GetCustomTraversalLandingAnimation(class AActor* _requester, const FTraversalInfo& _request, const float _fFallHeight, const FAnimContainer& _defaultLandAnimContainer, ESCCardinalPoints _eCardinalPoint, ESpeedState _eSpeedState, FAnimContainer& _outLandAnimContainer);
}; // Size: 0x28

class UTraversalAnimStructHelper : public UBlueprintFunctionLibrary
{

    FAnimContainer BPF_GetAnimContainerFromPhase(class UPlayerAnim* _playerAnim, const FAnimStructTraversal& _animStructTraversal, ETraversalPhase _eTraversalPhase);
}; // Size: 0x28

class UTraversalBTTask : public UBTTaskNode
{
    InputAction m_CancelOnActionAvailable;                                            // 0x0070 (size: 0x1)

}; // Size: 0x78

class UTraversalCameraTransitionInfo : public UCameraTransitionInfo
{
    bool m_bApplyCurveToDynamicRatio;                                                 // 0x0070 (size: 0x1)

}; // Size: 0x78

class UTraversalComponent : public UBoxComponent
{
    FTraversalComponent_OnStartBeingUsed m_OnStartBeingUsed;                          // 0x04B8 (size: 0x10)
    void TraversalUsageDelegate(class UTraversalComponent* _traversalComponent);
    FTraversalComponent_OnStopBeingUsed m_OnStopBeingUsed;                            // 0x04C8 (size: 0x10)
    void TraversalUsageDelegate(class UTraversalComponent* _traversalComponent);
    FTraversalComponentOnGetCinematicEndPoint OnGetCinematicEndPoint;                 // 0x04D8 (size: 0x10)
    FVector TraversalPointDelegate();
    float m_traversalWaitTimePerCombatRole;                                           // 0x0500 (size: 0x10)
    bool m_bTraversalActive;                                                          // 0x0510 (size: 0x1)
    bool m_bOverrideTraversalEntryAngle;                                              // 0x0511 (size: 0x1)
    float m_fTraversalEntryAngle;                                                     // 0x0514 (size: 0x4)
    bool m_bOverrideTraversalExitAngle;                                               // 0x0518 (size: 0x1)
    float m_fTraversalExitAngle;                                                      // 0x051C (size: 0x4)
    TArray<FTraversalAxisConstraint> m_traversalAxisConstraint;                       // 0x0520 (size: 0x10)
    ESimpleAxis m_eForbiddenAxis;                                                     // 0x0530 (size: 0x1)
    ESimpleAxisSide m_eAuthorizedAxisSide;                                            // 0x0531 (size: 0x1)
    bool m_bUseEntryMaxDistFromTraversalCenter;                                       // 0x0532 (size: 0x1)
    float m_fEntryMaxDistFromTraversalCenter;                                         // 0x0534 (size: 0x4)
    FTraversalComponentMargin m_EntryMargin_X;                                        // 0x0538 (size: 0x8)
    FTraversalComponentMargin m_EntryMargin_Y;                                        // 0x0540 (size: 0x8)
    float m_fLengthBetweenTwoNavLinks;                                                // 0x0548 (size: 0x4)
    uint8 m_AllowedEntryTypes;                                                        // 0x054C (size: 0x1)
    bool m_bIsLethal;                                                                 // 0x054D (size: 0x1)
    TSubclassOf<class UNavArea> m_cinematicNavAreaClass;                              // 0x0550 (size: 0x8)
    bool m_bUseMeshAsTraversalCollider;                                               // 0x0558 (size: 0x1)
    bool m_bUseRushInput;                                                             // 0x0559 (size: 0x1)
    bool m_bForceUseAnimDrivenCamera;                                                 // 0x055A (size: 0x1)
    bool m_bForceDisplayHint;                                                         // 0x055B (size: 0x1)
    bool m_bCustomNavLinkCooldownDuration;                                            // 0x055C (size: 0x1)
    float m_fNavLinkCooldownDuration;                                                 // 0x0560 (size: 0x4)
    bool m_bUseClimbUIForCine;                                                        // 0x0564 (size: 0x1)
    TArray<TSoftObjectPtr<AActor>> m_ActorsWithReferencedInNavLinkComponent;          // 0x0600 (size: 0x10)

    void TraversalUsageDelegate__DelegateSignature(class UTraversalComponent* _traversalComponent);
    FVector TraversalPointDelegate__DelegateSignature();
    void ComputeTraversalAIInfo();
    void BPF_SetTraversalActive(bool _bActive, bool _bForce);
    bool BPF_IsTraversalActive();
    bool BPF_IsEntryTypeAllowed(ETraversalEntryType _eEntryType);
    bool BPF_IsAnimDrivenCameraForced();
    void BPE_StartBeingUsed();
    void BPE_EndBeingUsed();
}; // Size: 0x610

class UTraversalDB : public UObject
{
    TSubclassOf<class UTraversalAnimRequest> m_TraversalAnimRequestBlueprint;         // 0x0028 (size: 0x8)
    int32 m_iNbOfFrameToUseAtEndOfPreExitForMeanFallingVelocity;                      // 0x0030 (size: 0x4)
    float m_fMaxTrackingAngleFromStartDegree;                                         // 0x0034 (size: 0x4)
    float m_RaycastLengthBySpeedState;                                                // 0x0038 (size: 0x10)
    float m_fPreExitPhaseSnapRaycastOffsetAbove;                                      // 0x0048 (size: 0x4)
    float m_fPreExitPhaseSnapRaycastOffsetBelow;                                      // 0x004C (size: 0x4)
    FVector m_vBoxExtentsToSnapToNavmesh;                                             // 0x0050 (size: 0xC)
    float m_fMaxTraversalDepth;                                                       // 0x005C (size: 0x4)
    float m_fMaxTraversalHeight;                                                      // 0x0060 (size: 0x4)
    float m_fMaxTraversalHeightClimb;                                                 // 0x0064 (size: 0x4)
    float m_fMaxDepthToConsideredAsFenceWhenClimbingUp;                               // 0x0068 (size: 0x4)
    float m_fMinDurationBeforeEndOfEntrySnap;                                         // 0x006C (size: 0x4)
    float m_fMaximumSpeedStretchUp;                                                   // 0x0070 (size: 0x4)
    FTraversalInputBehavior m_InputBehaviorBySpeed;                                   // 0x0074 (size: 0x20)
    uint8 m_uiAllowedEntryTypes;                                                      // 0x0094 (size: 0x1)
    FHitBox m_HitBox;                                                                 // 0x0098 (size: 0x298)
    float m_fEvasionMaxDistBetweenInstigatorAndTarget;                                // 0x0330 (size: 0x4)
    float m_fEvasionDetectionDistance;                                                // 0x0334 (size: 0x4)
    uint8 m_uiTraversalTypeToDisplayHint;                                             // 0x0338 (size: 0x1)
    bool m_bUseCamDirForVisualHintDisplay;                                            // 0x0339 (size: 0x1)
    float m_fRaycastDistForVisualOnly;                                                // 0x033C (size: 0x4)
    float m_fMinTraversalClimbHeightForHint;                                          // 0x0340 (size: 0x4)
    float m_fStrideLengthTraversalHint;                                               // 0x0344 (size: 0x4)
    float m_fClimbHeightOffsetToDisplayHint;                                          // 0x0348 (size: 0x4)
    float m_fClimbOnEdgeOffsetToDisplayHint;                                          // 0x034C (size: 0x4)
    float m_fCineHeightOffsetToDisplayHint;                                           // 0x0350 (size: 0x4)
    FTraversalTypeSettings m_DefaultSettings;                                         // 0x0354 (size: 0xC)
    TMap<class ETraversalEntryType, class FTraversalTypeSettings> m_CustomSettings;   // 0x0360 (size: 0x50)

}; // Size: 0x3B0

class UTraversalEvadeBTTask : public UTraversalBTTask
{
}; // Size: 0x78

class UTraversalEvasionInfluenceTest : public UAIInfluenceTest
{
    bool m_bOverrideTraversalEntryType;                                               // 0x0050 (size: 0x1)
    ETraversalEntryType m_eTraversalEntry;                                            // 0x0051 (size: 0x1)

}; // Size: 0x58

class UTraversalNavLinkCustomComponent : public UNavLinkCustomComponent
{
    FTraversalInfo m_TraversalInfo;                                                   // 0x01B0 (size: 0xC8)
    uint8 m_uiCurrentTraversalVersion;                                                // 0x0278 (size: 0x1)
    TSoftObjectPtr<AActor> m_ExternalLinkedTraversalActor;                            // 0x0280 (size: 0x28)
    ELinkWithExternalBehavior m_eExternalLinkBehavior;                                // 0x02B0 (size: 0x1)

}; // Size: 0x330

class UTraversalOrderServiceCondition : public UOrderServiceActivationConditions
{
    ETraversalPhase m_ePhase;                                                         // 0x0028 (size: 0x1)

}; // Size: 0x30

class UTraversalPushExitNotifyState : public USCAnimNotifyState
{
}; // Size: 0x48

class UTriangleStatsWidget : public UWidget
{
    FSlateBrush m_Brush;                                                              // 0x0108 (size: 0x88)
    float DownLeftStat;                                                               // 0x0190 (size: 0x4)
    FTriangleStatsWidgetDownLeftStatDelegate DownLeftStatDelegate;                    // 0x0194 (size: 0x10)
    float GetFloat();
    float UpStat;                                                                     // 0x01A4 (size: 0x4)
    FTriangleStatsWidgetUpStatDelegate UpStatDelegate;                                // 0x01A8 (size: 0x10)
    float GetFloat();
    float DownRightStat;                                                              // 0x01B8 (size: 0x4)
    FTriangleStatsWidgetDownRightStatDelegate DownRightStatDelegate;                  // 0x01BC (size: 0x10)
    float GetFloat();
    FColor m_color;                                                                   // 0x01CC (size: 0x4)
    FColor m_TriangleColor;                                                           // 0x01D0 (size: 0x4)
    FColor m_CrossColor;                                                              // 0x01D4 (size: 0x4)
    float m_fTriangleLineWidth;                                                       // 0x01D8 (size: 0x4)
    float m_fCrossLineWidth;                                                          // 0x01DC (size: 0x4)

    void BPF_SetUpValue(float _fValue);
    void BPF_SetDownRightValue(float _fValue);
    void BPF_SetDownLeftValue(float _fValue);
}; // Size: 0x1F0

class UTriggerAbandonDialogAction : public UDialogActionBase
{
}; // Size: 0x30

class UTriggerBlackBarsDialogAction : public UDialogActionBase
{
}; // Size: 0x30

class UTriggerBossKillSpareDialogAction : public UDialogActionBase
{
    EBossKillingWay m_eBossKillingWay;                                                // 0x0030 (size: 0x1)

}; // Size: 0x38

class UTriggerFightDialogAction : public UDialogActionBase
{
    FName m_ActorSentToFight;                                                         // 0x0030 (size: 0x8)

    TArray<FName> GetActorOptions();
}; // Size: 0x38

class UTriggerFriendlyDialogAction : public UDialogActionBase
{
}; // Size: 0x30

class UTriggerGenericEventDialogAction : public UDialogActionBase
{
    FName m_EventName;                                                                // 0x0030 (size: 0x8)

}; // Size: 0x38

class UTriggerTauntEffectsNotify : public UAnimNotify
{
}; // Size: 0x38

class UTrumpetSkewData : public UDataAsset
{
    float m_fSkewZoneAngleDeg;                                                        // 0x0030 (size: 0x4)
    float m_fSkewZoneRadius;                                                          // 0x0034 (size: 0x4)
    class UCurveFloat* m_Curve;                                                       // 0x0038 (size: 0x8)
    ETrumpetSkewType m_eTrumpetSkewType;                                              // 0x0040 (size: 0x1)

}; // Size: 0x48

class UUIHelper : public UBlueprintFunctionLibrary
{

    void UpdateXPProgressBar(int32 _iCurrentLevelXP, int32 _iNextLevelXP, int32 _iStartXP, int32 _iIncrementXP, float _fProgress, float _fDuration, float _fDelta, float& _fNewProgress, float& _fLevelProgress, int32& _iCurrentXP);
    void LerpXPProgressBar(int32 _iCurrentLevelXP, int32 _iNextLevelXP, int32 _iStartXP, int32 _iIncrementXP, float _fProgress, float _fProgressDelta, float& _fLevelProgress, int32& _iCurrentXP, bool& _bLevelUp, int32 _iLoopXP);
    void FocusWidget(class UWidget* _widget);
    void FocusFirstFocusableWidget(TArray<class UWidget*> _widgets);
    void BPF_StopAllAnimations(class UUserWidget* _widget);
    void BPF_SetVirtualCursorWidget(class ULocalPlayer* _player, TEnumAsByte<EMouseCursor::Type> Cursor, class UUserWidget* Widget);
    void BPF_SetLastFocusedButton(class UWidget* _lastFocusedButton);
    void BPF_SetCursorPosition(const FVector2D& _vCursor);
    void BPF_SetAutoWrapTextBlock(class UTextBlock* _textBlock, bool _bAutoWrap);
    void BPF_RefreshButtonFocus();
    class UWidget* BPF_GetNextWidgetInArray(const TArray<class UWidget*>& _widgets, class UWidget* _currentWidget, ECycleDirection _eDirection, bool _bSkipDisabled);
    uint8 BPF_GetNextIndex(uint8 _uiCurrentIndex, ECycleDirection _eDirection, uint8 _uiLimitValue, bool _bLoopAtLimit, bool _bIncludeLimit);
    class UWidget* BPF_GetNextChildWidget(class UPanelWidget* container, class UWidget* currentWidget, ECycleDirection _eDirection, bool _bSkipDisabled);
    EUIInputModes BPF_GetLastNavigationMode();
    bool BPF_GetIsPIE();
    bool BPF_GetIsEditor();
    class UWidget* BPF_GetFocusedButton();
    FVector2D BPF_GetCursorPosition();
    class UButtonUserWidget* BPF_FindSelectedChildButton(class UPanelWidget* _panel);
    class UButtonUserWidget* BPF_FindSelectedButtonInArray(const TArray<class UWidget*>& _widgets);
    void BPF_EndAnimation(class UUserWidget* _widget, class UWidgetAnimation* _animation);
    void BPF_EndAllAnimations(class UUserWidget* _widget);
    void BPF_DeselectAllChildButtons(class UPanelWidget* _panel);
    class UWidget* BPF_CycleChildren(class UPanelWidget* _panel, class UWidget* _currentChild, ECycleDirection _eDirection, bool _bSkipDisabled);
    void BPF_ClearUserFocus();
}; // Size: 0x28

class UUILibrary : public UWidgetBlueprintLibrary
{

    void BPF_ShowPopup(const class APlayerController* _playerController, FText _txtMessage, FText _txtConfirm, FText _txtCancel, FBPF_ShowPopupOnConfirm _onConfirm, FBPF_ShowPopupOnCancel _onCancel);
    void BPF_SetAllSCButtonsTintsInUserWidget(class UUserWidget* _userWidget, FLinearColor _focusedColor, FLinearColor _noFocusColor);
    void BPF_ProjectWorldLocationToScreen(class APlayerController* _playerController, const FVector& _vInPosition, bool _bUseViewportBounds, float _fViewportBoundsOffset, FVector2D& _vOutScreenPosition, float& _fOutAngle, bool& _bOutIsOfScreen);
    bool BPF_Intersect2DPositionWithViewportBounds(class APlayerController* _playerController, const FVector2D& _vInPosition, FVector2D& _vOutIntersection, EIntersectDirection& _eOutIntersectDirection);
    void BPF_GetWidget2DPosFrom3D(class UWidget* _widget, FVector _location, FVector _3DOffset, FVector2D _2DOffset, float _f2DMinY, FVector2D& _2DPos, bool& _2DProjSuccess);
    void BPF_Get2DPosFrom3DBehindCam(const class UObject* WorldContextObject, FVector _location, FVector _3DOffset, FVector2D _2DOffset, FVector2D& _2DPos, bool& _LocationInFrontOfCamera);
    void BPF_Get2DPosFrom3D(class APlayerController* _playerController, FVector _location, FVector _3DOffset, FVector2D _2DOffset, FVector2D& _2DPos, bool& _2DProjSuccess);
    void BPF_ClosePopup(const class APlayerController* _playerController);
}; // Size: 0x28

class UUnlockNotification : public USCUserWidget
{

    void BPE_InitWithProgressionDoorStruct(const FProgressionDoorStruct& _progressionDoorStruct, const class UQuestItemData* _lastFulfilledQuest);
    void BPE_InitWithLootBox(const FLootBoxTypeCountStruct& _LootBoxes);
    void BPE_InitWithLoot(const FLootBaseItemStruct& _loot);
    void BPE_InitWithCharacterProgression(ECharacterProgressionRewardTypes _reward, class UCharacterProgressionUnlockDB* _unlock);
}; // Size: 0x310

class UUntargettableByCameraOrderService : public UOrderService
{
}; // Size: 0x28

class UUntargettableOrderService : public UOrderService
{
    bool m_bInverse;                                                                  // 0x0028 (size: 0x1)
    TArray<FDisabledTargetInfos> m_DisabledTargets;                                   // 0x0030 (size: 0x10)

}; // Size: 0x40

class UUpdateCameraBlackboardBTService : public UBTService_BlueprintBase
{

    void BPF_UpdateIsInFlyModeKey(FBlackboardKeySelector _IsInFlyModeKey);
    void BPF_UpdateIsInDialogKey(FBlackboardKeySelector _IsInDialogKey);
    void BPF_UpdateIsDuckingKey(FBlackboardKeySelector _DuckingKey);
    FPlayerStatesStatus BPF_GetPlayerStateStatus(EFightingActionState _eFightingState);
    class UPlayerFightingComponent* BPF_GetPlayerFightingComponent();
    class AFightingCharacter* BPF_GetFightingCharOwner();
    EDirections BPF_GetCharacterSideOnScreen();
    class UCameraComponentThird* BPF_GetCameraComponent();
    class UAttackComponent* BPF_GetAttackComponent();
    class UASMComponent* BPF_GetASMComponent();
    void BPE_OnOrderStarting(EOrderType _eOrderType, uint8 _orderID);
    void BPE_OnOrderEnding(EOrderType _eOrderType, uint8 _orderID);
    void BPE_ExitState(EFightingActionState _eStateEntered);
    void BPE_EnterState(EFightingActionState _eStateEntered);
}; // Size: 0x238

class UUpdateMovementMode : public UBTService
{
}; // Size: 0x70

class UUsableItemData : public UBaseItemData
{
    float m_fCooldown;                                                                // 0x0078 (size: 0x4)
    FAnimContainer m_Anims;                                                           // 0x0080 (size: 0x60)
    TSubclassOf<class AUsableItem> m_UsableItemClass;                                 // 0x00E0 (size: 0x8)
    FText m_Description;                                                              // 0x00E8 (size: 0x18)
    FName m_DBItemRowName;                                                            // 0x0100 (size: 0x8)
    int32 m_iTargetRecquirements;                                                     // 0x0108 (size: 0x4)

}; // Size: 0x110

class UUseFrameRangeFromOrderService : public UOrderServiceFrameRangeRequest
{
    bool m_bOnTarget;                                                                 // 0x0028 (size: 0x1)
    FFloatRange m_DefaultRange;                                                       // 0x002C (size: 0x10)
    bool m_bKeepDefaultLowerRange;                                                    // 0x003C (size: 0x1)
    bool m_bKeepDefaultUpperRange;                                                    // 0x003D (size: 0x1)
    TSubclassOf<class UOrderService> m_OrderSerice;                                   // 0x0040 (size: 0x8)

}; // Size: 0x48

class UUseInteractiveObjectAbility : public USCGameplayAbility
{
    TArray<InputAction> m_eCarriedMovableInputs;                                      // 0x0568 (size: 0x10)
    TArray<InputAction> m_eMovableInputs;                                             // 0x0578 (size: 0x10)

}; // Size: 0x588

class UV2BlockerComponent : public UActorComponent
{

    void OnActorEndOverlap(class AActor* _overlappedActor, class AActor* _otherActor);
    void OnActorBeginOverlap(class AActor* _overlappedActor, class AActor* _otherActor);
}; // Size: 0xD0

class UVectorInputData : public UGenericInputData
{
    FRuntimeFloatCurve m_ResetInputScaleOverTime;                                     // 0x00C0 (size: 0x88)
    FName m_unrealActionX;                                                            // 0x0148 (size: 0x8)
    FName m_unrealActionY;                                                            // 0x0150 (size: 0x8)
    float m_fInnerBound;                                                              // 0x0158 (size: 0x4)
    float m_fOuterBound;                                                              // 0x015C (size: 0x4)
    bool m_bBoundPerAxis;                                                             // 0x0160 (size: 0x1)
    class UCurveFloat* m_Curve;                                                       // 0x0168 (size: 0x8)
    class UTrumpetSkewData* m_trumpetSkewData;                                        // 0x0170 (size: 0x8)
    bool m_bInvertXAxis;                                                              // 0x0178 (size: 0x1)
    bool m_bInvertYAxis;                                                              // 0x0179 (size: 0x1)
    bool m_bInvertAxises;                                                             // 0x017A (size: 0x1)
    bool m_bDebugIsXAxisVertical;                                                     // 0x017B (size: 0x1)
    bool m_bNoInputTreatment;                                                         // 0x017C (size: 0x1)

}; // Size: 0x180

class UVelocityCondition : public UBaseActorCondition
{
    EOperationType m_eOperation;                                                      // 0x0028 (size: 0x1)
    float m_fVelocity;                                                                // 0x002C (size: 0x4)

}; // Size: 0x30

class UVersionWidget : public USCUserWidget
{
    FString m_displayedText;                                                          // 0x0310 (size: 0x10)

}; // Size: 0x320

class UVisibleWeaponData : public UBaseWeaponData
{
    TArray<FWeaponVisuals> m_WeaponVisuals;                                           // 0x0190 (size: 0x10)

}; // Size: 0x1A0

class UVitalPointAttachComponent : public USceneComponent
{
    class UVitalPointData* m_VitalPointData;                                          // 0x0208 (size: 0x8)

}; // Size: 0x210

class UVitalPointCheckCondition : public UObject
{
    FGameplayTagContainer m_attackerRequiredTags;                                     // 0x0028 (size: 0x20)
    FGameplayTagContainer m_defenderRequiredTags;                                     // 0x0048 (size: 0x20)
    FGameplayTagContainer m_defenderForbiddenTags;                                    // 0x0068 (size: 0x20)

    bool BPE_CanActivate(const class AFightingCharacter* _attacker, const class AFightingCharacter* _defender);
}; // Size: 0x88

class UVitalPointDB : public UInheritedDataAsset
{
    class UVitalPointDB* m_BaseVitalPoints;                                           // 0x0038 (size: 0x8)
    TArray<FVitalPointDataDefinition> m_VitalPointDefinitionArray;                    // 0x0040 (size: 0x10)

}; // Size: 0x50

class UVitalPointData : public UInheritedDataAsset
{
    FText m_Name;                                                                     // 0x0038 (size: 0x18)
    class UTexture* m_Texture;                                                        // 0x0050 (size: 0x8)
    FSCUserDefinedEnumHandler m_Slot;                                                 // 0x0058 (size: 0x50)
    TSubclassOf<class UVitalPointEvents> m_events;                                    // 0x00A8 (size: 0x8)
    TSubclassOf<class AAimingBillboardActor> m_ClassOfBillBoardToSpawn;               // 0x00B0 (size: 0x8)
    FAnimSyncContainer m_SyncAnimToPlay;                                              // 0x00B8 (size: 0x30)
    int32 m_iFocusPointsCost;                                                         // 0x00E8 (size: 0x4)
    FOverridingHitBox m_FocusAttackEffect;                                            // 0x00F0 (size: 0x340)
    bool m_bUseCustomOrder;                                                           // 0x0430 (size: 0x1)
    FEditableOrderType m_CustomInstigatorOrderType;                                   // 0x0438 (size: 0x58)
    FEditableOrderType m_CustomVictimOrderType;                                       // 0x0490 (size: 0x58)
    TSubclassOf<class UVitalPointCheckCondition> m_CheckConditionBlueprint;           // 0x04E8 (size: 0x8)

}; // Size: 0x4F0

class UVitalPointEvents : public UObject
{

    void BPE_OnWillExecute(const class UVitalPointData* _vitalPoint, class AFightingCharacter* _Instigator, class AFightingCharacter* _victim, bool& _bOutShouldDismiss);
}; // Size: 0x28

class UVitalPointWidget : public USCUserWidget
{

    class AVitalPointActor* BPF_GetVitalPointActor();
    void BPE_OnVitalPointActorSet(class AVitalPointActor* _vitalPointOwner);
    void BPE_OnVitalPointActorRemove(class AVitalPointActor* _vitalPointPreviousOwner);
}; // Size: 0x318

class UWCollisionSettings : public UDeveloperSettings
{
    float m_fFindMovePreventingCompsEpsilon;                                          // 0x0038 (size: 0x4)
    TEnumAsByte<ECollisionChannel> m_eThrowableCheckCollisionChannel;                 // 0x003C (size: 0x1)
    FSCCollisionResponseBuilder m_ThrowableCheckCollisionResponseBuilder;             // 0x0040 (size: 0x18)
    bool m_bForceCCDOnThrowables;                                                     // 0x0058 (size: 0x1)
    FCollisionProfileName m_WakeBreakableProximityProfile;                            // 0x005C (size: 0x8)
    FCollisionProfileName m_TraversalProfileName;                                     // 0x0064 (size: 0x8)
    TEnumAsByte<ECollisionChannel> m_eTraversalCheckCollisionChannel;                 // 0x006C (size: 0x1)
    FSCCollisionResponseBuilder m_TraversalCheckCollisionResponseBuilder;             // 0x0070 (size: 0x18)
    TEnumAsByte<ECollisionChannel> m_eEnvironmentalInteractionZoneChannel;            // 0x0088 (size: 0x1)
    TEnumAsByte<ECollisionChannel> m_eTraversalCollisionChannel;                      // 0x0089 (size: 0x1)
    TEnumAsByte<ECollisionChannel> m_eWallJumpChannel;                                // 0x008A (size: 0x1)
    TEnumAsByte<ECollisionChannel> m_eSpectatorCollisionChannel;                      // 0x008B (size: 0x1)

}; // Size: 0x110

class UWGAchievementUnlockCondition : public UAchievementUnlockCondition
{
    TArray<class AAISituationActor*> m_ResolvedSituations;                            // 0x00D0 (size: 0x10)
    bool m_bIsActive;                                                                 // 0x00E0 (size: 0x1)
    TArray<TSoftObjectPtr<AAISituationActor>> m_SpecificUnlockSituations;             // 0x00E8 (size: 0x10)
    TArray<TSoftObjectPtr<ASpawnerGroup>> m_SituationIgnoredSpawnerGroups;            // 0x00F8 (size: 0x10)
    int32 m_WantedDifficulties;                                                       // 0x0108 (size: 0x4)
    int32 m_iCheatsUnlockPointsToAdd;                                                 // 0x010C (size: 0x4)
    bool m_bAddCheatsUnlockPoints;                                                    // 0x0110 (size: 0x1)
    FText m_Title;                                                                    // 0x0118 (size: 0x18)
    FText m_Description;                                                              // 0x0130 (size: 0x18)
    ERunType m_eAllowedRunType;                                                       // 0x0148 (size: 0x1)
    TMap<class FGameplayTag, class FString> m_NeededCheatsWithArguments;              // 0x0150 (size: 0x50)
    bool m_bWantSpecificDifficulty;                                                   // 0x01A0 (size: 0x1)
    EOrderType m_eMonitoredOrder;                                                     // 0x01A8 (size: 0x1)
    bool m_bMonitorOrder;                                                             // 0x01A9 (size: 0x1)
    bool m_bAuthorizeSpecificPlatform;                                                // 0x01AA (size: 0x1)
    int32 m_AuthorizedPlatform;                                                       // 0x01AC (size: 0x4)

    bool BPF_IsPlatformAuthorized(EPlatform _ePlatform);
    void BPE_OnSituationResolved(class AAISituationActor* _situation, bool _bHasActiveSituation);
    void BPE_OnSituationActivated(class AAISituationActor* _situation);
    void BPE_OnOrderStarted(uint8 _orderID, class UOrderComponent* _OrderComponent);
    void BPE_OnFirstConditionActive();
    void BPE_OnConditionStops();
    void BPE_OnAllSituationResolved();
    void BPE_GetTitleAndDescription(FText& _title, FText& _description);
}; // Size: 0x1C8

class UWGAiAction : public USCAiAction
{
    ESpeedState m_eDesiredSpeedState;                                                 // 0x0088 (size: 0x1)
    bool m_bLockSpeedStateOnSchedule;                                                 // 0x0089 (size: 0x1)
    TMap<class FName, class FUOrderParamsClassInstance> m_orderParams;                // 0x0090 (size: 0x50)
    TMap<class FName, class FUOrderParamsInstanceStruct> m_OrderParamsInstances;      // 0x00E0 (size: 0x50)
    bool m_bCancelOnGlobalBehaviorChange;                                             // 0x0130 (size: 0x1)
    bool m_bCancellable;                                                              // 0x0131 (size: 0x1)
    TArray<FAICancelCondition> m_CancelConditions;                                    // 0x0138 (size: 0x10)
    EComboAIConditionGroupOperator m_CancelConditionOperator;                         // 0x0148 (size: 0x1)
    bool m_bForceIdleExit;                                                            // 0x0149 (size: 0x1)

    void OnGlobalBehaviorChanged(EGlobalBehaviors _eBehavior, const bool _bFromDialog);
    void BPF_RemoveAbilitySystemGameplayTag(const FGameplayTag& _tag);
    class AFightingPlayerController* BPF_GetFirstPlayerController();
    class AFightingCharacter* BPF_GetFirstPlayerCharacter();
    class AFightingCharacter* BPF_GetFightingCharacter();
    class AFightingCharacter* BPF_GetEnemyCharacter();
    class AFightingCharacter* BPF_GetCurrentTarget();
    class AFightingAIController* BPF_GetAIFightingController();
    class UAIFightingComponent* BPF_GetAIFightingComponent();
    class USCCrowdFollowingComponent* BPF_GetAICrowdFollingComponent();
    void BPF_AddAbilitySystemGameplayTag(const FGameplayTag& _tag);
    void BPE_OnCreatedOrderParams(FName _paramsName, class UOrderParams* _orderParams);
}; // Size: 0x150

class UWGCharacterPoseData : public USCCharacterPoseData
{
}; // Size: 0x98

class UWGDialogRealOverrideDb : public USCDialogRealOverrideDb
{
    EJoinDialogActors m_eJoinDialogActorsOnStart;                                     // 0x0050 (size: 0x1)

}; // Size: 0x58

class UWGGameFlow : public UGameFlow
{
    FWGGameFlowOnNextMapPreloadOver OnNextMapPreloadOver;                             // 0x0180 (size: 0x10)
    void DynamicMulticast();
    FGameplayTag m_StoryMapTag;                                                       // 0x01B8 (size: 0x8)
    TArray<class ULevelStreaming*> m_pendingLoadingLevels;                            // 0x0250 (size: 0x10)

    void TravelToPendingMapInternal(EWorldTravelLoadSaveStrategy _eLoadSaveStrategy, int32 _iSnapshotToOverrideFrom, bool _bDeleteWorldStateSave, int32 _iPartOfSaveToResetMask, bool _bKeepCheats);
    void SCOnSessionStateChanged__DelegateSignature(ESCGameInstanceState _previous, ESCGameInstanceState _current);
    void OnControllerReconnectConfirm();
    void BPF_TravelToPendingMap(bool _bSaveBefore, int32 _iSnapshotToOverrideFrom, bool _bDeleteWorldStateSave, bool _bReloadFirstSaveBefore, int32 _iPartOfSaveToResetMask, float _fFadeDuration, bool _bKeepCheats, bool _bUseDefaultSave);
    void BPF_RestartCurrentMap();
    void BPF_ResetTags();
    void BPF_RaiseTag(FGameplayTag _tagToRaise);
    void BPF_LoadNextMap(bool _bForceClassicTravel);
    void BPF_LoadMap(FName _mapTag, EGameFlowTravelType _eTravelTypeWanted, EMenuEnum _eMenuToShow, FGameplayTagContainer _mapOptions);
    bool BPF_IsPendingTravel();
    void BPF_GoToNextMap(bool _bWantsToSave, bool _bWantsToReloadSave, bool _bUseDefaultSave);
    bool BPF_GotoMap(FName _mapTag, FGameplayTagContainer _specificMapOptions, bool _bWantsToSave, int32 _iSnapshotToOverrideFrom, bool _bDeleteWorldStateSave, EMenuEnum _eMenuToShow, bool _bWantsToReloadSave, int32 _iPartOfSaveToResetMask, bool _bKeepCheats, bool _bUseDefaultSave);
    FName BPF_GetFirstPlayableMapTagName();
    FName BPF_GetCurrentMapTag();
    int32 BPF_GetCurrentHideoutIndex();
    bool BPF_CurrentMapHasMapOption(EWGGameFlowMapOption _eMapOption);
}; // Size: 0x268

class UWGGameFlowController : public UGameFlowController
{

    bool BPF_FindMapOptionInTags(const FGameplayTagContainer& _tagsToSearch, EWGGameFlowMapOption _eMapOption);
    FGameplayTag BPE_GetMapOptionTag(EWGGameFlowMapOption _eMapOption);
    int32 BPE_GetHideoutIndexFromTag(FName _hideoutTag);
}; // Size: 0x28

class UWGGameFlowNextMap : public UGameFlowNextMap
{
    EMenuEnum m_eMenuToShow;                                                          // 0x0098 (size: 0x1)

}; // Size: 0xA0

class UWGGameFlowNodeMap : public UGameFlowNodeMap
{
    EMenuEnum m_eMenuToShow;                                                          // 0x0080 (size: 0x1)
    ESCGameInstanceState m_eGameState;                                                // 0x0081 (size: 0x1)

}; // Size: 0x88

class UWGGameUserSettings : public UGameUserSettings
{
    UDLSSMode DLSSQuality;                                                            // 0x0120 (size: 0x1)

}; // Size: 0x128

class UWGGameplayStatics : public UBlueprintFunctionLibrary
{

    FName BPF_StartConversation(class ACharacter* _character, FName _startingSegment, const bool _bGenericSubtitles, class ACharacter* _secondary, bool _bCutOtherDialogs, bool _bLookAtEnabled, bool _bIgnoreCharacterCanSpeak);
    void BPF_SetGameDifficulty(EGameDifficulty _eDifficulty);
    bool BPF_IsGameOver(class UObject* _worldContext);
    bool BPF_IsChallengeGameMode(class UObject* _worldContext);
    EGameDifficulty BPF_GetGameDifficulty(bool _bNeedSaveGame);
    void BPF_CutDialog();
    bool BPF_CorsairSetState(FString _event);
    bool BPF_CorsairSetGame(FString _gameName);
    bool BPF_CorsairSetEvent(FString _event);
    bool BPF_CorsairRequestControl();
    void BPF_CorsairPerformProtocolHandshake();
    bool BPF_CorsairClearState(FString _event);
    bool BPF_CorsairClearAllStates();
}; // Size: 0x28

class UWGLevelSequence : public USCLevelSequence
{

    void BPF_SetCharacterPickedObjectVisibility(FName _roleName, bool _bVisible);
    void BPF_PushInputContext();
    void BPF_PopInputContext();
    class UWGLevelSequenceDirectorData* BPF_GetWGData();
}; // Size: 0x100

class UWGLevelSequenceDirectorData : public USCLevelSequenceDirectorData
{
    InputContext m_InputContext;                                                      // 0x00C8 (size: 0x1)
    EPlayerCameraForcedSide m_eForcedPlayerCameraSide;                                // 0x00C9 (size: 0x1)
    bool m_bHideOwnerCarriedWeaponOnPlay;                                             // 0x00CA (size: 0x1)
    bool m_bShowOwnerCarriedWeaponOnFinished;                                         // 0x00CB (size: 0x1)
    bool m_bForceOutOfIdle;                                                           // 0x00CC (size: 0x1)
    TArray<class UAkAudioEvent*> m_AudioEventsOnStart;                                // 0x00D0 (size: 0x10)
    TArray<class UAkAudioEvent*> m_AudioEventsOnFinish;                               // 0x00E0 (size: 0x10)

}; // Size: 0xF0

class UWGLevelSequenceRoleData : public USCLevelSequenceRoleData
{
    EQuadrantTypes m_ForcedQuadrant;                                                  // 0x0048 (size: 0x1)
    ELevelSequenceAIBehavior m_ForcedAIBehavior;                                      // 0x0049 (size: 0x1)

}; // Size: 0x50

class UWGRetargetingOverrideData : public UDataAsset
{
    class USkeleton* m_Skeleton;                                                      // 0x0038 (size: 0x8)
    TMap<FBoneReference, TEnumAsByte<EBoneTranslationRetargetingMode::Type>> m_BoneRetargetingOverrideMap; // 0x0040 (size: 0x50)

}; // Size: 0x90

class UWGSaveManagerBlueprintHelper : public USaveManagerBlueprintHelper
{

    void BPF_SnapshotPartOfSave(int32 _iSaveTypeBitmask, int32 _iSaveEntryToExclude);
    void BPF_SetNeedSaveProfile();
    void BPF_SetNeedSaveGame(int32 _iSaveTypeBitmask);
    void BPF_ResetSnapshotWithMask(int32 _iSaveTypeBitmask);
    void BPF_ResetPartOfSave(int32 _iSaveTypeBitmask);
    void BPF_ResetForbiddenSaveMask();
    int32 BPF_PushForbiddenSaveMask(int32 _iSaveTypeBitmask, const FString _contextString);
    void BPF_PushBlockWorldStateSave(FString _contextString);
    void BPF_PopForbiddenSaveMask(int32 _iHandle);
    void BPF_PopBlockWorldStateSave();
    void BPF_OverrideSaveWithSnapshot(int32 _iSaveTypeBitmask);
    bool BPF_HasSnapshotOfMask(int32 _iSaveTypeBitmask);
    void BPF_GetSnapshotSavedData(int32 _iSaveTypeBitmask, FDuplicatedSaveData& _snapshotSavedData);
    int32 BPF_GetForbiddenMask();
}; // Size: 0x28

class UWGSaveObjectGameData : public USCSaveObjectGameData
{
    FGameSaveData m_SavedData;                                                        // 0x01C0 (size: 0x250)

    void ReloadDefaultStatsFromDataTable();
    void BPF_RemoveGameplayTag(FGameplayTag _gameplayTagToAdd);
    bool BPF_HasGameplayTag(FGameplayTag _gameplayTagToAdd);
    float BPF_GetDefaultStatValue(ECharacterStat _eStat, bool& _bFound);
    void BPF_AddOrUpdateMaskSnapshot(int32 _iMask, const FDuplicatedSaveData& _duplicatedData);
    void BPF_AddGameplayTag(FGameplayTag _gameplayTagToAdd);
    bool BPE_SynchronizeAchievementProgress(const TMap<FString, float>& _achievementProgress);
    FString BPE_SnapshotSaveMask(int32 _iSaveMaskToBackup, int32 _iSaveEntryToExclude);
    bool BPE_ShouldLoadAntiCheatMap();
    FString BPE_OverrideSaveMaskWithSnapshot(int32 _iSnapshotIdx);
    int32 BPE_GenerateGlobalAllowedSaveMask();
    void BPE_CopyToSaveWithMask(class USCSaveObjectGameData* _inSaveTo, int32 _iTestMask);
}; // Size: 0x410

class UWGSaveObjectPlayerProfile : public USCSaveObjectPlayerProfile
{
    FProfileData m_WGProfileData;                                                     // 0x0108 (size: 0x3D0)

    void BPF_AddUnlockedCheat(FGameplayTag _tagToAdd);
}; // Size: 0x4D8

class UWGSaveSettings : public USaveSettings
{
    TSoftObjectPtr<UCharacterBuildDB> m_DefaultBuild;                                 // 0x0098 (size: 0x28)
    FGameOptionMappingRange m_GameOptionValue;                                        // 0x00C0 (size: 0x334)

}; // Size: 0x3F8

class UWaitForActorConditionTask : public UBTTaskNode
{
    float m_fMaxWaitDuration;                                                         // 0x0070 (size: 0x4)
    FBaseActorConditionInstance m_condition;                                          // 0x0078 (size: 0x10)

}; // Size: 0x88

class UWaitOrderTask : public UBTTaskNode
{
    TArray<EOrderType> m_Orders;                                                      // 0x0070 (size: 0x10)

}; // Size: 0x80

class UWallEnvironmentalAttackSettings : public UObject
{
    FHitBox m_HitOnWall;                                                              // 0x0028 (size: 0x298)
    FSCUserDefinedEnumHandler m_EnvironementImpactType;                               // 0x02C0 (size: 0x50)
    TEnumAsByte<ECollisionChannel> m_eRayCastCollisionChannel;                        // 0x0310 (size: 0x1)
    float m_fMaxRefCharSnapDistance;                                                  // 0x0314 (size: 0x4)
    float m_fSplineMargin;                                                            // 0x0318 (size: 0x4)
    float m_fMaxRaycastAngleWithSnap;                                                 // 0x031C (size: 0x4)
    float m_fMaxRaycastAngleWithoutSnap;                                              // 0x0320 (size: 0x4)
    float m_fMaxDistToProjection;                                                     // 0x0324 (size: 0x4)
    FName m_ImpactBoneName;                                                           // 0x0328 (size: 0x8)
    float m_fImpactBoneYawRotation;                                                   // 0x0330 (size: 0x4)
    bool m_bUseInstigatorAsRef;                                                       // 0x0334 (size: 0x1)
    bool m_bMirrorAnimOnRightSide;                                                    // 0x0335 (size: 0x1)
    TSubclassOf<class UTakedownAnimRequest> m_animRequest;                            // 0x0338 (size: 0x8)

}; // Size: 0x340

class UWallJumpGeneratorComponent : public UActorComponent
{
    float m_fMinWallLength;                                                           // 0x00C8 (size: 0x4)
    float m_fDetectionDistance;                                                       // 0x00CC (size: 0x4)
    float m_fMaxSegmentVerticalAngle;                                                 // 0x00D0 (size: 0x4)
    float m_fLeanHeight;                                                              // 0x00D4 (size: 0x4)
    float m_fMaxWallAngleDegree;                                                      // 0x00D8 (size: 0x4)
    int32 m_iWallActorCount;                                                          // 0x00DC (size: 0x4)
    TSubclassOf<class AActor> m_ActorClass;                                           // 0x00E0 (size: 0x8)
    TArray<FGeneratedWallInfos> m_Walls;                                              // 0x0150 (size: 0x10)

}; // Size: 0x160

class UWeaponDB : public UDataAsset
{
    float m_fWeaponDurabilityRegenRate;                                               // 0x0030 (size: 0x4)
    float m_fDurabilityDamageRateOnAbsorb;                                            // 0x0034 (size: 0x4)
    float m_fDurabilityDamageRateOnParried;                                           // 0x0038 (size: 0x4)

}; // Size: 0x40

class UWeaponDestructionComponent : public UInteractiveDestructionComponent
{
    FWeaponDestructionComponent_OnDamagedWeaponSwitch m_OnDamagedWeaponSwitch;        // 0x0230 (size: 0x10)
    void OnDamagedWeaponSwitch(int32 _iWeaponIdx);
    TArray<FDamagedWeaponInfo> m_DamagedWeaponInfos;                                  // 0x0240 (size: 0x10)
    float m_fDelayForCurrentOrderStop;                                                // 0x0250 (size: 0x4)

    void OnDamagedWeaponSwitch__DelegateSignature(int32 _iWeaponIdx);
    int32 BPF_GetNumDamagedWeaponIndex();
    int32 BPF_GetDamagedWeaponIndex();
}; // Size: 0x258

class UWeaponGameplayData : public UObject
{
    TSubclassOf<class UTargetSettingsDB> m_throwFromPickUpTargetSettingsDB;           // 0x0028 (size: 0x8)
    float m_afDamageReceiveFromAttackPower;                                           // 0x0030 (size: 0xC)
    class UCurveFloat* m_SlowMotionCurve;                                             // 0x0040 (size: 0x8)
    float m_fSlowMotionScale;                                                         // 0x0048 (size: 0x4)
    FMainCharWeaponOverrideInfo m_MainCharOverrides;                                  // 0x0050 (size: 0x20)

    void BPE_WeaponDataRef();
    void BPE_OnChangeCombo(class AFightingCharacter* _owner, bool _bDroppingWeapon);
}; // Size: 0x70

class UWeaponInfoForAIDataAsset : public UDataAsset
{
    TMap<class TSubclassOf<ABaseWeapon>, class TSubclassOf<UBaseWeaponData>> m_WeaponsInfo; // 0x0030 (size: 0x50)
    TMap<class TSubclassOf<ABaseWeapon>, class FUsableWeaponInfo> m_WeaponsGameplayInfo; // 0x0080 (size: 0x50)

}; // Size: 0xD0

class UWeaponTrailsNotifyState : public UTrailNotifyStateExtended
{
    EWeaponSlot m_eWeaponSlot;                                                        // 0x0070 (size: 0x1)

}; // Size: 0xC8

class UWidgetData : public UObject
{

    void BPF_NotifyDataUpdated();
}; // Size: 0x48

class UWidgetPoolComponent : public UActorComponent
{
    TArray<FWidgetPoolEntryTemplate> m_WidgetPoolTemplate;                            // 0x00C8 (size: 0x10)
    TMap<class FName, class FWidgetPoolElementArray> m_WidgetPool;                    // 0x00D8 (size: 0x50)

    void BPF_ReleaseWidget(const FSCUserDefinedEnumHandler& _userEnum, class USCUserWidget* _userWidget);
    class USCUserWidget* BPF_GetWidget(const FSCUserDefinedEnumHandler& _userEnum);
}; // Size: 0x130

class UWuguanTestControllerBase : public UGauntletTestController
{
    TArray<class ASCTestingLocationsBase*> m_TestingLocations;                        // 0x0070 (size: 0x10)

    void StopProfiling();
    void StartProfiling();
    void OnTestLevelVisible();
}; // Size: 0x80

class UWuguanTestControllerMapLaunch : public UWuguanTestControllerBase
{
}; // Size: 0x80

class UWuguanTestControllerMemoryTest : public UWuguanTestControllerBase
{
}; // Size: 0x80

class UWuguanTestControllerPerfTest : public UWuguanTestControllerBase
{
}; // Size: 0x80

#endif
